<!DOCTYPE HTML>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Xuxx,Galileo,blog" />
    <meta name="generator" content="Maverick 1.0" />
    <meta name="template" content="Galileo" />
    <link rel="alternate" type="application/rss+xml" title="Xuxx的个人博客。 &raquo; RSS 2.0" href="/Xuxx_Blogs/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Xuxx的个人博客。 &raquo; ATOM 1.0" href="/Xuxx_Blogs/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/assets/galileo-ec40839efa.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/assets/ExSearch/ExSearch-182e5a8868.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/39c2abe125266b95342b84df6a55bee3.json"
        }
    </script>
    
<title>Dockerfile笔记 - Xuxx的个人博客。</title>
<meta name="author" content="Xuxx" />
<meta name="description" content="笔记" />
<meta property="og:title" content="Dockerfile笔记 - Xuxx的个人博客。" />
<meta property="og:description" content="笔记" />
<meta property="og:site_name" content="Xuxx的个人博客。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/Xuxx_Blogs/archives/bj32/" />
<meta property="og:image" content="" />
<meta property="article:published_time" content="2020-09-20T13:30:00-00.00" />
<meta name="twitter:title" content="Dockerfile笔记 - Xuxx的个人博客。" />
<meta name="twitter:description" content="笔记" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="" />


    
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="//cdn.jsdelivr.net" />

    </head>
    
    <body>
        
        <div class="container">
            <header id="ga-header">
                <div first>
                    <aside id="ga-logo">
                        <a href="/Xuxx_Blogs/" target="_self">
                            <img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/logo.png" alt="Xuxx的个人博客。">
                        </a>
                    </aside>
                    <aside id="ga-brand">
                        <h1 class="brand"><a class="no-style" href="/Xuxx_Blogs/">Xuxx的个人博客。</a></h1>
                        <p>坚持有效行动，改变自然发生——致自己。</p>
                    </aside>
                </div>
                <div second id="ga-nav">
                    <nav class="navs">
                        <ul><li><a class="ga-highlight" href="/Xuxx_Blogs/" target="_self">首页</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/Xuxx_Blogs/archives/" target="_self">归档</a></li><span class="separator">·</span><li><a class="ga-highlight" href="/Xuxx_Blogs/about/" target="_self">关于</a></li><span class="separator">·</span><li><a href="#" target="_self" class="search-form-input ga-highlight">搜索</a></li></ul>
                    </nav>
                    <nav class="social-links">
                        <ul><li><a class="no-style" title="Twitter" href="https://twitter.com/xuxx3309" target="_blank"><i class="gi gi-twitter"></i>Twitter</a></li><span class="separator">·</span><li><a class="no-style" title="GitHub" href="https://github.com/QQ1820582487" target="_blank"><i class="gi gi-github"></i>GitHub</a></li></ul>
                    </nav>
                </div>
            </header>
            <div class="wrapper">
                
<main>    
    <section class="ga-section ga-content">
        <article class="yue">
            <h1 class="ga-post_title">Dockerfile笔记</h1>
            <span class="ga-post_meta ga-mono">
                <span>Xuxx</span>
                <time>
                    2020-09-20
                </time>
                
                in <a no-style class="category" href="/Xuxx_Blogs/category/笔记/">
                    笔记
                </a>
                
                
            </span>
            <div class="ga-content_body">
                <h2>概述</h2>
<p>从 <a href="https://yeasy.gitbook.io/docker_practice/image/commit">docker commit</a> 的学习中，可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>以 tomcat 镜像为例，这次使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为<code>Dockerfile</code></p>
<div class="highlight"><pre><span></span>mkdir myshop
<span class="nb">cd</span> myshop
touch Dockerfile
</pre></div>
<p>其内容为：</p>
<div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">tomcat</span>
<span class="k">RUN</span> <span class="nb">echo</span> Hello,Docker! &gt; /usr/local/tomcat/webapps/ROOT/index.jsp
</pre></div>
<h2>FROM-指定基础镜像</h2>
<p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而FROM就是指定基础镜像，因此<strong>一个 Dockerfile 中 FROM是必备的指令，并且必须是第一条指令</strong>。</p>
<p>除了选择(在Docker Hub上)现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为<code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<h2>RUN 执行命令</h2>
<p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<ul>
<li><em>shell</em> 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">RUN</span> <span class="nb">echo</span> Hello,Docker! &gt; /usr/local/tomcat/webapps/ROOT/index.jsp
</pre></div>
<ul>
<li><em>exec</em> 格式：<code>RUN ["可执行文件", "参数1", "参数2"]</code>，这更像是函数调用中的格式。</li>
</ul>
<p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">debian:stretch</span>

<span class="k">RUN</span> apt-get update
<span class="k">RUN</span> apt-get install -y gcc libc6-dev make wget
<span class="k">RUN</span> wget -O redis.tar.gz <span class="s2">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span>
<span class="k">RUN</span> mkdir -p /usr/src/redis
<span class="k">RUN</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span class="o">=</span><span class="m">1</span>
<span class="k">RUN</span> make -C /usr/src/redis
<span class="k">RUN</span> make -C /usr/src/redis install
</pre></div>
<p>之前说过，<strong>Dockerfile 中每一个指令都会建立一层</strong>，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和手动建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p>
<p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p>
<div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">debian:stretch</span>

<span class="k">RUN</span> <span class="nb">set</span> -x<span class="p">;</span> <span class="nv">buildDeps</span><span class="o">=</span><span class="s1">&#39;gcc libc6-dev make wget&#39;</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get update <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get install -y <span class="nv">$buildDeps</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> wget -O redis.tar.gz <span class="s2">&quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&quot;</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> mkdir -p /usr/src/redis <span class="se">\</span>
    <span class="o">&amp;&amp;</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span class="o">=</span><span class="m">1</span> <span class="se">\</span>
    <span class="o">&amp;&amp;</span> make -C /usr/src/redis <span class="se">\</span>
    <span class="o">&amp;&amp;</span> make -C /usr/src/redis install <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/* <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm redis.tar.gz <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm -r /usr/src/redis <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get purge -y --auto-remove <span class="nv">$buildDeps</span>
</pre></div>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<h2>构建镜像</h2>
<p><code>docker build</code> 命令进行镜像构建。其语法为：</p>
<div class="highlight"><pre><span></span>docker build <span class="o">[</span>选项<span class="o">]</span> &lt;上下文路径/URL/-&gt;
</pre></div>
<p>在 <code>Dockerfile</code> 文件所在目录执行：</p>
<div class="highlight"><pre><span></span><span class="o">[</span>root@localhost myshop<span class="o">]</span><span class="c1"># docker build -t myshop .</span>
Sending build context to Docker daemon  <span class="m">3</span>.072kB
Step <span class="m">1</span>/2 : FROM tomcat:latest
 ---&gt; 2eb5a120304e
Step <span class="m">2</span>/2 : COPY index.jsp /usr/local/tomcat/webapps/ROOT
 ---&gt; f44b1d0d1366
Successfully built f44b1d0d1366
Successfully tagged myshop:latest
</pre></div>
<h2>镜像构建上下文（Context）</h2>
<p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。<code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p>
<p>当进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>

<pre><code>COPY ./package.json /app/</code></pre>
<p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p>
<p><strong>其它</strong> <code>docker build</code> <strong>的用法</strong></p>
<ul>
<li><p>直接用 Git repo 进行构建</p>

<pre><code>docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world</code></pre>
<p>这行命令指定了构建所需的 Git repo，并且指定分支为 <code>master</code>，构建目录为 <code>/amd64/hello-world/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
</li>
<li><p>用给定的 tar 压缩包构建</p>

<pre><code>$ docker build http://server/context.tar.gz</code></pre>
<p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
</li>
<li><p>从标准输入中读取 Dockerfile 进行构建</p>

<pre><code>docker build - &lt; Dockerfile</code></pre>
<p>或</p>

<pre><code>cat Dockerfile | docker build -</code></pre>
<p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p>
</li>
<li><p>从标准输入中读取上下文压缩包进行构建</p>

<pre><code>$ docker build - &lt; context.tar.gz</code></pre>
<p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
</li>
</ul>
<h2>Dockerfile 指令详解</h2>
<h3>COPY 复制文件</h3>
<p>格式：</p>
<ul>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径&gt;... &lt;目标路径&gt;</code></li>
<li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] ["&lt;源路径1&gt;",... "&lt;目标路径&gt;"]</code></li>
</ul>
<p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。比如：</p>

<pre><code>COPY package.json /usr/src/app/</code></pre>
<p><code>&lt;源路径&gt;</code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href="https://golang.org/pkg/path/filepath/#Match"><code>filepath.Match</code></a> 规则，如：</p>

<pre><code>COPY hom* /mydir/COPY hom?.txt /mydir/</code></pre>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>

<pre><code>COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/</code></pre>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。</p>
<h3>ADD 更高级的复制文件</h3>
<p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p>
<p>比如 <code>&lt;源路径&gt;</code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 <code>&lt;源路径&gt;</code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code> 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p>

<pre><code>FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /...</code></pre>
<p>但在某些情况下，如果真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p>
<p>在 Docker 官方的 <a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p>在使用该指令的时候还可以加上 <code>--chown=&lt;user&gt;:&lt;group&gt;</code> 选项来改变文件的所属用户及所属组。</p>
<h3>CMD 容器启动命令</h3>
<p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p>
<ul>
<li><code>shell</code> 格式：<code>CMD &lt;命令&gt;</code></li>
<li><code>exec</code> 格式：<code>CMD ["可执行文件", "参数1", "参数2"...]</code></li>
<li>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li>
</ul>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p>
<p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p>

<pre><code>CMD echo $HOME</code></pre>
<p>在实际执行中，会将其变更为：</p>

<pre><code>CMD [ "sh", "-c", "echo $HOME" ]</code></pre>
<p>这就是为什么可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 <code>CMD</code> 写为：</p>

<pre><code>CMD service nginx start</code></pre>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p>

<pre><code>CMD ["nginx", "-g", "daemon off;"]</code></pre>
<h3>ENTRYPOINT 入口点</h3>
<p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p>
<p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p>
<p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令，换句话说实际执行时，将变为：</p>

<pre><code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code></pre>
<p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</code> 有什么好处么？让来看几个场景。</p>
<h4>场景一：让镜像变成像命令一样使用</h4>
<p>假设需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p>
<div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">ubuntu:18.04</span>
<span class="k">RUN</span> apt-get update <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get install -y curl <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/*
<span class="k">CMD</span> <span class="p">[</span> <span class="s2">&quot;curl&quot;</span><span class="p">,</span> <span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;http://myip.ipip.net&quot;</span> <span class="p">]</span>
</pre></div>
<p>假如使用 <code>docker build -t myip .</code> 来构建镜像的话，如果需要查询当前公网 IP，只需要执行：</p>
<div class="highlight"><pre><span></span>$ docker run myip
当前 IP：61.148.226.66 来自：北京市 联通
</pre></div>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p>
<div class="highlight"><pre><span></span>$ docker run myip -i
docker: Error response from daemon: invalid header field value <span class="s2">&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;exec: \\\&quot;-i\\\&quot;: executable file not found in </span><span class="nv">$PATH</span><span class="s2">\&quot;\n&quot;</span>.
</pre></div>
<p>可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p>
<p>那么如果希望加入 <code>-i</code> 这参数，就必须重新完整的输入这个命令：</p>
<div class="highlight"><pre><span></span>$ docker run myip curl -s http://myip.ipip.net -i
</pre></div>
<p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p>
<div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">ubuntu:18.04</span>
<span class="k">RUN</span> apt-get update <span class="se">\</span>
    <span class="o">&amp;&amp;</span> apt-get install -y curl <span class="se">\</span>
    <span class="o">&amp;&amp;</span> rm -rf /var/lib/apt/lists/*
<span class="k">ENTRYPOINT</span> <span class="p">[</span> <span class="s2">&quot;curl&quot;</span><span class="p">,</span> <span class="s2">&quot;-s&quot;</span><span class="p">,</span> <span class="s2">&quot;http://myip.ipip.net&quot;</span> <span class="p">]</span>
</pre></div>
<p>这次再来尝试直接使用 <code>docker run myip -i</code>：</p>
<div class="highlight"><pre><span></span>$ docker run myip
当前 IP：61.148.226.66 来自：北京市 联通

$ docker run myip -i
HTTP/1.1 <span class="m">200</span> OK
Server: nginx/1.8.0
Date: Tue, <span class="m">22</span> Nov <span class="m">2016</span> <span class="m">05</span>:12:40 GMT
Content-Type: text/html<span class="p">;</span> <span class="nv">charset</span><span class="o">=</span>UTF-8
Vary: Accept-Encoding
X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
X-Cache: MISS from cache-2
X-Cache-Lookup: MISS from cache-2:80
X-Cache: MISS from proxy-2_6
Transfer-Encoding: chunked
Via: <span class="m">1</span>.1 cache-2:80, <span class="m">1</span>.1 proxy-2_6:8006
Connection: keep-alive
​
当前 IP：61.148.226.66 来自：北京市 联通
</pre></div>
<p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了预期的效果。</p>
<h4>场景二：应用运行前的准备工作</h4>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD&gt;</code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p>
<div class="highlight"><pre><span></span><span class="k">FROM</span> <span class="s">alpine:3.4</span>
...
<span class="k">RUN</span> addgroup -S redis <span class="o">&amp;&amp;</span> adduser -S -G redis redis
...
<span class="k">ENTRYPOINT</span> <span class="p">[</span><span class="s2">&quot;docker-entrypoint.sh&quot;</span><span class="p">]</span>

<span class="k">EXPOSE</span><span class="s"> 6379</span>
<span class="k">CMD</span> <span class="p">[</span> <span class="s2">&quot;redis-server&quot;</span> <span class="p">]</span>
</pre></div>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p>
<div class="highlight"><pre><span></span><span class="ch">#!/bin/sh</span>
...
<span class="c1"># allow the container to be started with `--user`</span>
<span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;</span><span class="nv">$1</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s1">&#39;redis-server&#39;</span> -a <span class="s2">&quot;</span><span class="k">$(</span>id -u<span class="k">)</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s1">&#39;0&#39;</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
    find . <span class="se">\!</span> -user redis -exec chown redis <span class="s1">&#39;{}&#39;</span> +
    <span class="nb">exec</span> gosu redis <span class="s2">&quot;</span><span class="nv">$0</span><span class="s2">&quot;</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
<span class="k">fi</span>

<span class="nb">exec</span> <span class="s2">&quot;</span><span class="nv">$@</span><span class="s2">&quot;</span>
</pre></div>
<p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p>
<div class="highlight"><pre><span></span>$ docker run -it redis id
<span class="nv">uid</span><span class="o">=</span><span class="m">0</span><span class="o">(</span>root<span class="o">)</span> <span class="nv">gid</span><span class="o">=</span><span class="m">0</span><span class="o">(</span>root<span class="o">)</span> <span class="nv">groups</span><span class="o">=</span><span class="m">0</span><span class="o">(</span>root<span class="o">)</span>
</pre></div>
<h3>ENV 设置环境变量</h3>
<p>格式有两种：</p>
<ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<div class="highlight"><pre><span></span><span class="k">ENV</span> <span class="nv">VERSION</span><span class="o">=</span><span class="m">1</span>.0 <span class="nv">DEBUG</span><span class="o">=</span>on <span class="se">\</span>
    <span class="nv">NAME</span><span class="o">=</span><span class="s2">&quot;Happy Feet&quot;</span>
</pre></div>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p>
<div class="highlight"><pre><span></span><span class="k">ENV</span> NODE_VERSION <span class="m">7</span>.2.0

<span class="k">RUN</span> curl -SLO <span class="s2">&quot;https://nodejs.org/dist/v</span><span class="nv">$NODE_VERSION</span><span class="s2">/node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz&quot;</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> curl -SLO <span class="s2">&quot;https://nodejs.org/dist/v</span><span class="nv">$NODE_VERSION</span><span class="s2">/SHASUMS256.txt.asc&quot;</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc <span class="se">\</span>
  <span class="o">&amp;&amp;</span> grep <span class="s2">&quot; node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz\$&quot;</span> SHASUMS256.txt <span class="p">|</span> sha256sum -c - <span class="se">\</span>
  <span class="o">&amp;&amp;</span> tar -xJf <span class="s2">&quot;node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz&quot;</span> -C /usr/local --strip-components<span class="o">=</span><span class="m">1</span> <span class="se">\</span>
  <span class="o">&amp;&amp;</span> rm <span class="s2">&quot;node-v</span><span class="nv">$NODE_VERSION</span><span class="s2">-linux-x64.tar.xz&quot;</span> SHASUMS256.txt.asc SHASUMS256.txt <span class="se">\</span>
  <span class="o">&amp;&amp;</span> ln -s /usr/local/bin/node /usr/local/bin/nodejs
</pre></div>
<p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p>
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3>VOLUME 定义匿名卷</h3>
<p>格式为：</p>
<ul>
<li><code>VOLUME ["&lt;路径1&gt;", "&lt;路径2&gt;"...]</code></li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>之前说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<div class="highlight"><pre><span></span><span class="k">VOLUME</span><span class="s"> /data</span>
</pre></div>
<p>这里的 <code>/data</code> 目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<div class="highlight"><pre><span></span>docker run -d -v mydata:/data xxxx
</pre></div>
<p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p>
<h3>EXPOSE 暴露端口</h3>
<p>格式为 <code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code>。</p>
<p><code>EXPOSE</code> 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3>WORKDIR 指定工作目录</h3>
<p>格式为 <code>WORKDIR &lt;工作目录路径&gt;</code>。</p>
<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<div class="highlight"><pre><span></span><span class="k">RUN</span> <span class="nb">cd</span> /app
<span class="k">RUN</span> <span class="nb">echo</span> <span class="s2">&quot;hello&quot;</span> &gt; world.txt
</pre></div>
<p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器。这就是对 <code>Dockerfile</code> 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p>
<div class="highlight"><pre><span></span><span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="k">RUN</span> <span class="nb">echo</span> <span class="s2">&quot;hello&quot;</span> &gt; world.txt
</pre></div>
<p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关：</p>
<div class="highlight"><pre><span></span><span class="k">WORKDIR</span><span class="s"> /a</span>
<span class="k">WORKDIR</span><span class="s"> b</span>
<span class="k">WORKDIR</span><span class="s"> c</span>

<span class="k">RUN</span> pwd
</pre></div>
<p><code>pwd</code> 输出的结果为 <code>/a/b/c</code>。</p>

            </div>
        </article>
        <div id="ga-tags">
    
    <span class="ga-tag">
        <a class="ga-highlight" href="/Xuxx_Blogs/tag/Docker/">#Docker</a>
    </span>
    
    <span class="ga-tag">
        <a class="ga-highlight" href="/Xuxx_Blogs/tag/Dockerfile/">#Dockerfile</a>
    </span>
    
</div>
    </section>

    
<section id="ga-content_pager">

    <div class="next">
        <a class="ga-highlight" href="/Xuxx_Blogs/archives/bj33/">Docker Compose笔记</a>
        <p class="yue">笔记</p>
    </div>


    <div class="prev">
        <a class="ga-highlight" href="/Xuxx_Blogs/archives/bj31/">Docker笔记</a>
        <p class="yue">笔记</p>
    </div>

</section>


    

</main>

                <footer class="ga-mono" id="ga-footer">
                    <section>
                        <span id="ga-uptime"></span>
                        <span class="brand">Xuxx的个人博客。</span>
                    </section>
                    <section>
                        <p class="copyright">
                            <span>Copyright © 2020 Xuxx</span>
                            <span>Powered by <a no-style href="https://github.com/AlanDecode/Maverick" target="_blank">Maverick & Galileo</a></span>
                        </p>
                        <div class="copyright">
                            <span class="footer-addon">
                                
                            </span>
                            <nav class="social-links">
                                <ul><li><a class="no-style" title="Twitter" href="https://twitter.com/xuxx3309" target="_blank"><i class="gi gi-twitter"></i>Twitter</a></li><span class="separator">·</span><li><a class="no-style" title="GitHub" href="https://github.com/QQ1820582487" target="_blank"><i class="gi gi-github"></i>GitHub</a></li></ul>
                            </nav>
                        </div>
                    </section>
                    <script>
                        var site_build_date = "2019-12-26T02:30+08:00"
                    </script>
                    <script src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/assets/galileo-d8a0a06eff.js"></script>
                </footer>
            </div>
        </div>
    </div>
        
        
        <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="pswp__bg"></div>
        <div class="pswp__scroll-wrap">
            <div class="pswp__container">
                <div class="pswp__item"></div>
                <div class="pswp__item"></div>
                <div class="pswp__item"></div>
            </div>
            <div class="pswp__ui pswp__ui--hidden">
                <div class="pswp__top-bar">
                    <div class="pswp__counter"></div>
                    <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                    <button class="pswp__button pswp__button--share" title="Share"></button>
                    <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                    <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                    <div class="pswp__preloader">
                        <div class="pswp__preloader__icn">
                          <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                          </div>
                        </div>
                    </div>
                </div>
                <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                    <div class="pswp__share-tooltip"></div> 
                </div>
                <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
                </button>
                <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
                </button>
                <div class="pswp__caption">
                    <div class="pswp__caption__center"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/assets/ExSearch/ExSearch-493cb9cd89.js"></script>
    
    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/assets/katex.min.js"></script>
    <script>
    mathOpts = {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "\\[", right: "\\]", display: true},
            {left: "$", right: "$", display: false},
            {left: "\\(", right: "\\)", display: false}
        ]
    };
    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
    </body>
</html>