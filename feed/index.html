<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Xuxx的个人博客。</title><link>/Xuxx_Blogs/</link><description>坚持有效行动，改变自然发生——致自己。</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>${static_prefix}logo.png</url><title>Xuxx的个人博客。</title><link>/Xuxx_Blogs/</link></image><language>zh-CN</language><lastBuildDate>Tue, 01 Dec 2020 08:47:36 +0806</lastBuildDate><pubDate>Tue, 01 Dec 2020 08:47:36 +0806</pubDate><item><title>图解 Java 内存模型</title><link>/Xuxx_Blogs/archives/bj28/</link><description>&lt;p&gt;&lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxOTc4NjEyMw==&amp;amp;mid=2247492802&amp;amp;idx=3&amp;amp;sn=20c345eba118d855b950991306af37fe&amp;amp;chksm=f9f6ff26ce817630dbdf18969226aa04db78fc9171b08365ba071074c42afaa5874ec0970cf2&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=09054ZHbGeWMRAhwVgNKdEEl&amp;amp;sharer_sharetime=1599315785410&amp;amp;sharer_shareid=0581665d51df24ce3ec1b889fd40265c#rd"&gt;转自&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1. 内存模型 &amp;amp; 分区&lt;/h2&gt;
&lt;p&gt;Java虚拟机在运行Java程序时，会管理着一块内存区域：运行时数据区&lt;/p&gt;
&lt;p&gt;在运行时数据区里，会根据用途进行划分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java虚拟机栈（栈区）&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;Java堆（堆区）&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 86.24454148471615" data-width="790" data-height="458"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/ab0aba19931485908a0e6986f22e7d1f.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;2. Java堆&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.04761904761905" data-width="790" data-height="420"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/487027ef1610070e35b274bfc597037a.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 80.4769001490313" data-width="1080" data-height="671"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/4d0c4e9e3d03dadd2f3df73af439d755.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java堆是垃级收集器管理的主要区域，因此被称为:"GC堆";&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从内存回收的角度可分为:新生代&amp;amp;老年代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新生代可细分:Eden 空间、From Survivor 空间、To Survivor 空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从内存分配的角度:多个线程私有的分配缓冲区&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. Java虚拟机栈&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 100.76530612244898" data-width="790" data-height="392"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/f9d472efe072ac386040d10f37f9ff36.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 67.9245283018868" data-width="1080" data-height="795"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/14e19ff71547c592ddf03ff4e9b7013b.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;4. 本地方法栈&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.04761904761905" data-width="790" data-height="420"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e38a2647ca57500b88226672a2abaf4c.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;p&gt;本地方法栈十分类似Java虚拟机栈&lt;/p&gt;
&lt;p&gt;与Java虚拟机区别在于：服务对象，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java虚拟机栈为执行 Java 方法服务；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地方法栈为执行 Native方法服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. 方法区&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.04761904761905" data-width="790" data-height="420"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/64fd88018fefac462c98db246aab8783.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 75.9493670886076" data-width="1080" data-height="711"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/7b628f86eabe274d724f93c151cc5c95.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注：其内部包含一个&lt;strong&gt;运行时常量池&lt;/strong&gt;，具体介绍如下：&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 82.82208588957056" data-width="1080" data-height="652"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/0e18c57c5acb2dd873c57e8554edb0b9.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;6. 程序计数器&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.04761904761905" data-width="790" data-height="420"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/53d8ad5573475c282b00bc5255f099d0.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 65.77344701583435" data-width="1080" data-height="821"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/d4ebaabf8c2de348e19dd956487fc5ec.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;7. 额外知识：直接内存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定义：NIO类（JDK1.4引入）中基于通道和缓冲区的I/O方式 通过使用Native函数库 直接分配 的堆外内存&lt;/li&gt;
&lt;li&gt;特点：不受堆大小限制&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;p&gt;不属于虚拟机运行时数据区的一部分 &amp;amp; 不在堆中分配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应用场景：适用于频繁调用的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;p&gt;通过一个 存储在Java堆中的DirectByteBuffer对象 作为这块内存的引用 进行操作，从而避免在 Java 堆和 Native堆之间来回复制数据，提高使用性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;抛出的异常：OutOfMemoryError，即与其他内存区域的总和 大于 物理内存限制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;8. 总结&lt;/h2&gt;
&lt;p&gt;本文全面讲解JVM中的内存模型 &amp;amp; 分区，总结如下&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 144.0" data-width="1080" data-height="375"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/10936d10647a2b939c1bd64c8f774d6b.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj28/</guid><pubDate>Sat, 05 Sep 2020 21:50:00 +0806</pubDate></item><item><title>Liunx基础</title><link>/Xuxx_Blogs/archives/bj29/</link><description>&lt;h1&gt;Liunx目录管理&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/root&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;根目录，万物起源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;strong&gt;boot&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），和启动加载程序 &lt;strong&gt;有趣的文件&lt;/strong&gt;： /boot/grub/grub.conf or menu.lst，被用来配置启动；加载程序 /boot/vmlinuz， Linux 内核&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/bin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;包含系统启动和运行所必须的二进制程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/sbin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/usr&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。usr (unix software resource | unix 软件资源)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/usr/bin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统用户使用的应用程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/usr/sbin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;超级用户使用的比较高级的管理程序和系统守护程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/usr/src&lt;/td&gt;
&lt;td&gt;内核源代码默认的放置目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/proc&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统内存的映射目录，提供内核与进程信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/lost+found&lt;/td&gt;
&lt;td&gt;一般情况下是空的，当系统非法关机后，这里就存放了一些文件，文件系统恢复时的恢复文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/var&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。存放邮件、系统日志等变化文件，存放系统或程序运行过程中的数据文件(variable)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/tmp&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这个目录是用来存放一些临时文件的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/etc&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;存放系统配置文件。它也包含一系列的 shell 脚本，在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。  &lt;code&gt;/etc/crontab&lt;/code&gt;，定义自动运行的任务。 &lt;code&gt;/etc/fstab&lt;/code&gt;，包含存储设备的列表，以及与他们相关的 挂载点。 &lt;code&gt;/etc/passwd&lt;/code&gt;，包含用户帐号列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/home&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;用户主目录，在通常的配置环境下，系统会在 /home 下，给每个用户分配一个目录。普通只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/dev&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这是一个包含设备结点的特殊目录。“一切都是文件”，也使用于设备。在这个目录里，内核维护着它支持的设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/lib&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;动态连接共享库，&lt;code&gt;.so&lt;/code&gt; 文件，类似于 Windows 里的 dll 文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/mnt&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/media&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统会自动识别一些设备，例如 U 盘、光驱等等，把识别的设备挂载到这个目录下。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/sys&lt;/td&gt;
&lt;td&gt;sys 虚拟文件系统挂载点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/srv&lt;/td&gt;
&lt;td&gt;存放服务相关数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/opt&lt;/td&gt;
&lt;td&gt;这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/srv&lt;/td&gt;
&lt;td&gt;该目录存放一些服务启动之后需要提取的数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/selinux&lt;/td&gt;
&lt;td&gt;这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux 相关的文件的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;操作文件目录&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;常用选项说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ls&lt;/td&gt;
&lt;td&gt;显示文件和目录列表&lt;/td&gt;
&lt;td&gt;ls [选项] [dest]&lt;/td&gt;
&lt;td&gt;-a：列出目录下的所有文件，包含.开头的隐藏文件&lt;br/&gt;-l：列出文件的详细信息&lt;br/&gt;-h：以容易读取的方式显示文件大小&lt;br/&gt;-d：仅列出目录本身，而不显示目录中的文件&lt;br/&gt;-t：按照时间顺序排序，时间越早越早下面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mkdir&lt;/td&gt;
&lt;td&gt;创建目录&lt;/td&gt;
&lt;td&gt;mkdir [-选项] dest&lt;/td&gt;
&lt;td&gt;-p 创建多级目录（跨级创建）&lt;br/&gt;-v 查看目录创建的过程（创建目录可视化）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rmdir&lt;/td&gt;
&lt;td&gt;仅删除空白目录&lt;/td&gt;
&lt;td&gt;rmdir dest&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cd&lt;/td&gt;
&lt;td&gt;切换目录&lt;/td&gt;
&lt;td&gt;cd dest&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;touch&lt;/td&gt;
&lt;td&gt;生成一个空文件&lt;/td&gt;
&lt;td&gt;touch dest&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;echo&lt;/td&gt;
&lt;td&gt;生成一个带内容的文件&lt;/td&gt;
&lt;td&gt;echo 内容 &amp;gt; dest&lt;/td&gt;
&lt;td&gt;-e：激活转义字符&lt;br/&gt;&amp;gt;：复写&lt;br/&gt;&amp;gt;&amp;gt;：追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cat&lt;/td&gt;
&lt;td&gt;显示文本文件内容&lt;/td&gt;
&lt;td&gt;cat [-选项] dest&lt;/td&gt;
&lt;td&gt;-n：有1开始对所有输出的行数编号；&lt;br/&gt;-b：和-n相似，只不过对于空白行不编号；&lt;br/&gt;-s：当遇到有连续两行以上的空白行，就代换为一行的空白行；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cp&lt;/td&gt;
&lt;td&gt;复制文件或目录&lt;/td&gt;
&lt;td&gt;cp [-选项] source  dest&lt;/td&gt;
&lt;td&gt;-a：此参数的效果和同时指定"-dpR"参数相同； &lt;br/&gt;-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；&lt;br/&gt;-f：强行复制文件或目录，不论目标文件或目录是否已存在； &lt;br/&gt;-i：覆盖既有文件之前先询问用户； &lt;br/&gt;-l：对源文件建立硬连接，而非复制文件； &lt;br/&gt;-p：保留源文件或目录的属性； &lt;br/&gt;-R/r：递归处理，将指定目录下的所有文件与子目录一并处理； &lt;br/&gt;-s：对源文件建立符号连接，而非复制文件； &lt;br/&gt;-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； &lt;br/&gt;-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀； &lt;br/&gt;-b：覆盖已存在的文件目标前将目标文件备份； &lt;br/&gt;-v：详细显示命令执行的操作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rm&lt;/td&gt;
&lt;td&gt;删除文件或目录&lt;/td&gt;
&lt;td&gt;rm [选项] dest&lt;/td&gt;
&lt;td&gt;-f：强制删除文件或目录； &lt;br/&gt;-i：删除已有文件或目录之前先询问用户； &lt;br/&gt;-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理； &lt;br/&gt;-v：显示指令的详细执行过程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mv&lt;/td&gt;
&lt;td&gt;移动/重命名文件或目录&lt;/td&gt;
&lt;td&gt;mv [选项] dest&lt;/td&gt;
&lt;td&gt;常用：mv 文件名或目录  目标目录&lt;br/&gt;mv a.txt ../    将a文件移动到上级目录（将一个文件移动到另一个目录没有重命名）&lt;br/&gt;mv a.txt  ../b.txt   将a文件移动到上一级并改名为b文件（将一个文件移动到另一个目录并重命名）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;find&lt;/td&gt;
&lt;td&gt;查找文件&lt;/td&gt;
&lt;td&gt;find [选项] [起始目录] dest&lt;/td&gt;
&lt;td&gt;常用选项有：&lt;br/&gt;find  . -name *.log    在当前目录查找以.log结尾的文件&lt;br/&gt;find  / -name  log   在根目录查找log命名的目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;grep&lt;/td&gt;
&lt;td&gt;在指定文件中查找字符（串）并打印该行&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;用法：grep  字符串 文件名&lt;br/&gt;grep 123 fileName  在file文件中寻找字符串123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tree&lt;/td&gt;
&lt;td&gt;用于以树状图列出目录内容&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;td&gt;显示当前工作目录&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ln&lt;/td&gt;
&lt;td&gt;为文件创件连接&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;more&lt;/td&gt;
&lt;td&gt;分屏/页显示文本文件内容&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;切换至下一屏：空格键 &lt;br/&gt;切换至上一屏：Ctrl+B&lt;br/&gt;查看文档的总行数，使用命令：wc -l&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;head&lt;/td&gt;
&lt;td&gt;显示文件开头的内容&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tail&lt;/td&gt;
&lt;td&gt;显示文件结尾的内容&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;压缩/解压缩&lt;/h2&gt;
&lt;h3&gt;tar&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;tar命令&lt;/strong&gt;可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。&lt;/p&gt;
&lt;p&gt;首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。&lt;/p&gt;
&lt;p&gt;为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（&lt;code&gt;gzip&lt;/code&gt; &lt;code&gt;bzip2&lt;/code&gt;)命令）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：tar  [选项]   打包后文档的名称   欲打包的目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-c：打包&lt;/li&gt;
&lt;li&gt;-x：解包&lt;/li&gt;
&lt;li&gt;-z：通过gzip指令处理备份文件&lt;/li&gt;
&lt;li&gt;-j：支持bzip2解压文件&lt;/li&gt;
&lt;li&gt;-v：显示操作过程&lt;/li&gt;
&lt;li&gt;-f：指定备份文件&lt;/li&gt;
&lt;li&gt;-t：列出备份文件的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;将文件全部打包成tar包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tar -cvf log.tar log2012.log    仅打包，不压缩
tar -czvf log.tar.gz log2012.log   打包后，以 gzip 压缩 
tar -cjvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在选项&lt;code&gt;f&lt;/code&gt;之后的文件档名是自己取的，习惯上都用 .tar 来作为辨识。 如果加&lt;code&gt;z&lt;/code&gt;选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加&lt;code&gt;j&lt;/code&gt;选项，则以.tar.bz2来作为tar包名。&lt;/p&gt;
&lt;p&gt;将tar包解压缩：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tar -xzvf ./log.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;gzip&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;gzip命令&lt;/strong&gt;用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。&lt;/p&gt;
&lt;p&gt;gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和&lt;code&gt;tar&lt;/code&gt;命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：gzip  [选项]     [欲打包的目录]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-d或--decompress或----uncompress 　解开压缩文件。&lt;/li&gt;
&lt;li&gt;-f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。&lt;/li&gt;
&lt;li&gt;-h或--help 　在线帮助。&lt;/li&gt;
&lt;li&gt;-l或--list 　列出压缩文件的相关信息。&lt;/li&gt;
&lt;li&gt;-q或--quiet 　不显示警告信息。&lt;/li&gt;
&lt;li&gt;-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。&lt;/li&gt;
&lt;li&gt;-t或--test 　测试压缩文件是否正确无误。&lt;/li&gt;
&lt;li&gt;-v或--verbose 　显示指令执行过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;把当前目录下的每个文件压缩成.gz文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把上例中每个压缩的文件解压，并列出详细的信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip -dv *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细显示例1中每个压缩的文件的信息，并不解压&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzip -l *&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;压缩一个tar备份文件，此时压缩文件的扩展名为 .tar.gz&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip -r log.tar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归的压缩test目录&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip -rv &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;这样，所有test下面的文件都变成了 .gz，目录依然存在，只是目录里面的文件相应变成了 .gz，这就是压缩，和打包不同。因为是对目录操作，所以需要加上 -r 选项，这样也可以对子目录进行递归了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;递归地解压目录&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip -dr &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;bzip2&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;bzip2命令&lt;/strong&gt;用于创建和管理（包括解压缩）“.bz2”格式的压缩包。&lt;/p&gt;
&lt;h1&gt;Liunx系统管理&lt;/h1&gt;
&lt;h2&gt;系统管理命令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;td&gt;显示指定文件的相关信息,比&lt;code&gt;Is&lt;/code&gt;命令显示内容更多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;who&lt;/td&gt;
&lt;td&gt;显示在线登录用户&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hostname&lt;/td&gt;
&lt;td&gt;显示主机名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uname&lt;/td&gt;
&lt;td&gt;显示系统信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;top&lt;/td&gt;
&lt;td&gt;显示当前系统中耗费资源最多的进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ps&lt;/td&gt;
&lt;td&gt;显示瞬间的进程状态（-A|e：显示所有程序。）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;du&lt;/td&gt;
&lt;td&gt;显示指定的文件(目录)当前已使用的磁盘空间的总量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;df&lt;/td&gt;
&lt;td&gt;显示文件系统磁盘空间的使用情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;free&lt;/td&gt;
&lt;td&gt;显示当前内存和交换空间的使用情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifconfig&lt;/td&gt;
&lt;td&gt;显示网络接口信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ping&lt;/td&gt;
&lt;td&gt;测试网络的连通性(心跳检测)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;netstat&lt;/td&gt;
&lt;td&gt;显示网络状态信息(可以查看端口)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clear&lt;/td&gt;
&lt;td&gt;清屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kill&lt;/td&gt;
&lt;td&gt;杀死一个进程(-9：强制终止)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;开关机命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;shutdown 命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序&lt;/li&gt;
&lt;li&gt;shutdown 也可以用来重开机。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;参数说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;shutdown&lt;/td&gt;
&lt;td&gt;shutdown [-t seconds] [-rkhncfF] time [message]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-t seconds&lt;/td&gt;
&lt;td&gt;设定在几秒钟之后进行关机程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;并不会真的关机，只是将警告讯息传送给所有只用者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;关机后重新开机（重启）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-h&lt;/td&gt;
&lt;td&gt;关机后停机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;取消目前已经进行中的关机动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;关机时，不做 fcsk 动作(检查 Linux 档系统)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-F&lt;/td&gt;
&lt;td&gt;关机时，强迫进行 fsck 动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;time&lt;/td&gt;
&lt;td&gt;设定关机的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;传送给所有使用者的警告讯息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;重启&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;reboot&lt;/p&gt;
&lt;p&gt;sudo：提权，以其他身份来执行命令，预设的身份为 root&lt;/p&gt;
&lt;p&gt;reboot提示没有权限时使用：sudo reboot&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;shutdown -r now&lt;/p&gt;
&lt;p&gt;同上，加 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shutdown -h now&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Vim编辑器&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;Vim是从vi发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。&lt;/p&gt;
&lt;p&gt;简单的来说，vi是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。Vim则可以说是程序开发者的一项很好用的工具。&lt;/p&gt;
&lt;h2&gt;运行模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编辑模式：等待编辑命令输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;插入模式：编辑模式下，输入&lt;code&gt;i&lt;/code&gt;进入插入模式，插入文本信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令模式：在编辑模式下，输入&lt;code&gt;:&lt;/code&gt;进行命令模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;命令模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt;：退出vim&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq&lt;/code&gt;：保存后退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q!&lt;/code&gt;：强制退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq!&lt;/code&gt;：强制保存后退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w file&lt;/code&gt;：将当前内容保存成某个文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt;：查找字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set number&lt;/code&gt;：显示行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set nonumber&lt;/code&gt;：不显示行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set paste&lt;/code&gt;：开启原样粘贴&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Liunx文件和目录访问权限设置&lt;/h1&gt;
&lt;p&gt;Linux用 户分为：拥有者(owner)、组群(group)、其他(other)，Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信息， 都是记录在&lt;code&gt;/etc/passwd&lt;/code&gt;文件中。每个用户的密码则是记录在&lt;code&gt;/etc/shadow&lt;/code&gt;文件下。 此外，所有的组群名称记录在&lt;code&gt;/etc/group&lt;/code&gt;內。&lt;/p&gt;
&lt;p&gt;Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 59.642147117296226" data-width="600" data-height="503"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/0f631055251b1aade9ed18c81c4788db.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;权限数字对应权限组说明：&lt;/p&gt;
&lt;p&gt;总共分为4部分&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;文件或文件夹&lt;/th&gt;
&lt;th&gt;owner权限&lt;/th&gt;
&lt;th&gt;group权限&lt;/th&gt;
&lt;th&gt;others权限&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;文件是 - ，文件夹是 d&lt;/td&gt;
&lt;td&gt;r/w/x相加&lt;/td&gt;
&lt;td&gt;r/w/x相加&lt;/td&gt;
&lt;td&gt;r/w/x相加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;r(read)  可读 --  4；w(write) 可写   --   2；x(execute) 可执行   --  1；-  表示相应的权限还没有被授予&lt;/p&gt;
&lt;h2&gt;chown命令&lt;/h2&gt;
&lt;p&gt;chown是 change owner (改变所有者) 的意思，主要作用就是改变某个文件或目录的所有者和所属的组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;chown  [-R]  用户名称   文件或目录&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;chown  [-R]    用户名称   用户组名称   文件或目录&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;chmod命令&lt;/h2&gt;
&lt;p&gt;chmod命令用来变更文件或目录的权限。用户可以使用 chmod 命令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。&lt;/p&gt;
&lt;h3&gt;语法&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;chmod &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;操作对象&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;操作符合&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;mode&lt;span class="o"&gt;]&lt;/span&gt; 文件或目录
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作对象&lt;/p&gt;
&lt;p&gt;可以是以下字母的一个或者组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;u：拥有者&lt;/li&gt;
&lt;li&gt;g：组&lt;/li&gt;
&lt;li&gt;o：其他&lt;/li&gt;
&lt;li&gt;a：所有用户(默认)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;操作符合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;+：表示添加某个权限&lt;/li&gt;
&lt;li&gt;-：表示取消某个权限&lt;/li&gt;
&lt;li&gt;=：赋予给定的权限，覆盖文件/目录原有的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;mode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r 表示可读取&lt;/li&gt;
&lt;li&gt;w 表示可写入&lt;/li&gt;
&lt;li&gt;x 表示可执行&lt;/li&gt;
&lt;li&gt;X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数字设定法&lt;/h3&gt;
&lt;p&gt;数字设定法中数字表示的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 表示没有任何权限&lt;/li&gt;
&lt;li&gt;1 表示有可执行权限 = x&lt;/li&gt;
&lt;li&gt;2 表示有可写权限 = w&lt;/li&gt;
&lt;li&gt;4 表示有可读权限 = r&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以用数字来表示权限如：&lt;code&gt;chmod 755 fileName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chmod u+x file                　　　   给file的属主增加执行权限&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod 751 file                　　　   给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod u=rwx,g=rx,o=x file         上例的另一种形式&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod =r file                 　　　　为所有用户分配读权限&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod 444 file              　　　   同上例&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod a-wx,a+r   file   　　 　    同上例&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod -R u+r directory       　    递归地给directory目录下所有文件和子目录的属主分配读的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;附: centos防火墙基本使用&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;启动： systemctl start firewalld  
关闭： systemctl stop firewalld  
查看状态： systemctl status firewalld   
开机禁用： systemctl disable firewalld  
开机启用： systemctl enable firewalld&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://frank-lam.github.io/fullstack-tutorial/#/Linux"&gt;学习指南&lt;/a&gt;&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj29/</guid><pubDate>Tue, 15 Sep 2020 15:30:00 +0806</pubDate></item><item><title>Docker基础</title><link>/Xuxx_Blogs/archives/bj30/</link><description>&lt;h1&gt;Docker概述&lt;/h1&gt;
&lt;h3&gt;Docker是什么？&lt;/h3&gt;
&lt;p&gt;Docker是Docker.Lnc公司开源的一个基于LXC技术之上搭建的 Container 容器引擎，源代码托管在Github上，使用 Google 公司的 Go 语言，基于Go语言并遵从Apache2.0协议开源。Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。
总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;/p&gt;
&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;
&lt;p&gt;简单来说：Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。&lt;/p&gt;
&lt;h3&gt;Docker的设计理念和概念&lt;/h3&gt;
&lt;p&gt;docker设想是交付运行环境如同海运，OS如同一个货轮，每一个在OS基础上的软件都如同一个集装箱，用户可以通过标准化手段自由组装运行环境，同时集装箱的内容可以由用户自定义，也可以由专业人员制造。这样，交付一个软件，就是一系列标准化组件的集合的交付，如同乐高积木，用户只需要选择合适的积木组合，并且在最顶端署上自己的名字(最后一个标准化组件是用户的app)。这也就是基于 docker 的 PaaS 产品的原型。&lt;/p&gt;
&lt;p&gt;所以Docker的主要目标是“&lt;code&gt;Build，Ship and Run Any App,Anywhere&lt;/code&gt;(在任何地方构建、发布和运行任何应用程序)”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个Web应用或数据库应用等等）及其运行环境能够做到&lt;strong&gt;“一次封装，到处运行”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Docker是开发人员和系统管理员使用容器开发、部署和运行应用程序的平台。使用Linux容器来部署应用程序称为集装箱化。使用docker轻松部署应用程序。目前，Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），学习时用社区版就可以了。&lt;/p&gt;
&lt;h3&gt;Docker的组成&lt;/h3&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 97.50996015936255" data-width="979" data-height="502"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e039df4cc61e644108026a13e8852aae.png" alt="Docker组成" /&gt;&lt;figcaption&gt;Docker组成&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;镜像(image)：&lt;/h4&gt;
&lt;p&gt;Docker镜像就相当于是一个文件系统，通俗来说就是为容器用来创建容器的&lt;/p&gt;
&lt;h4&gt;容器(Container)：&lt;/h4&gt;
&lt;p&gt;Docker 利用容器 (Container) 独立运行的一个或一组应用，容器是用镜像创建的运行实例，它可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台，可以把容器看做是一个简易版的Linux系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器就相当于Java中的对象，镜像相当于Java中的类&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;仓库(Repository)&lt;/h4&gt;
&lt;p&gt;仓库是集中存放镜像文件的场所
仓库注册服务器 (Registry) 上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签 
仓库分为公开仓库和私有仓库两种形式
最大的公开仓库是&lt;a href="https://hub.docker.com"&gt;DockerHub&lt;/a&gt;存放了数量庞大的镜像供用户下载，国内的公开仓库包括阿里云等&lt;/p&gt;
&lt;h3&gt;Docker对比传统虚拟化方式的优势&lt;/h3&gt;
&lt;h4&gt;更高效的利用系统资源&lt;/h4&gt;
&lt;p&gt;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的&lt;/p&gt;
&lt;p&gt;主机，往往可以运行更多数量的应用。&lt;/p&gt;
&lt;h4&gt;一致的运行环境&lt;/h4&gt;
&lt;p&gt;开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现「&lt;strong&gt;这段代码在我机器上没问题啊&lt;/strong&gt;」这类问题。&lt;/p&gt;
&lt;h4&gt;更快速的启动时间&lt;/h4&gt;
&lt;p&gt;传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整&lt;/p&gt;
&lt;p&gt;的操作系统，因此可以做到种级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。&lt;/p&gt;
&lt;h4&gt;持续交付和部署&lt;/h4&gt;
&lt;p&gt;对开发和运维( DevOps ）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。&lt;/p&gt;
&lt;p&gt;使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfi1e来进行镜像构建，并结合 &lt;strong&gt;持续集成(Continuous Integration)&lt;/strong&gt; 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 &lt;strong&gt;持续部署(Continuous Delivery/Deployment)&lt;/strong&gt; 系统进行自动部署。&lt;/p&gt;
&lt;p&gt;而且使用 &lt;code&gt;Dockerfile&lt;/code&gt;使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。&lt;/p&gt;
&lt;h4&gt;更轻松的迁移&lt;/h4&gt;
&lt;p&gt;由于Docker确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。&lt;/p&gt;
&lt;h4&gt;更轻松的维护和扩展&lt;/h4&gt;
&lt;p&gt;Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。&lt;/p&gt;
&lt;h4&gt;对比传统虚拟机总结&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Docker&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;传统虚拟机&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;启动&lt;/td&gt;
&lt;td&gt;秒级&lt;/td&gt;
&lt;td&gt;分钟级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;硬盘使用&lt;/td&gt;
&lt;td&gt;一般为MB&lt;/td&gt;
&lt;td&gt;一般为GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;接近原生&lt;/td&gt;
&lt;td&gt;弱于原生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;上千个&lt;/td&gt;
&lt;td&gt;一般几十个&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;Docker的进程隔离&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 121.44846796657382" data-width="872" data-height="359"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/d8fb7b9df7e611067e2f927b22554f0a.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1&gt;Docker安装&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/u014069688/article/details/100532774"&gt;转自☞&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境：虚拟机装的Centos7，linux 3.10 内核&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;root账户登录，查看内核版本如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# uname -a&lt;/span&gt;
Linux localhost.localdomain &lt;span class="m"&gt;3&lt;/span&gt;.10.0-1062.12.1.el7.x86_64 &lt;span class="c1"&gt;#1 SMP Tue Feb 4 23:02:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把 yum 包更新到最新(非必须，方便小白)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum update&lt;/span&gt;
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: centos.ustc.edu.cn
 * extras: mirrors.aliyun.com
 * updates: mirrors.cn99.com
base                                                                                                  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;.6 kB  &lt;span class="m"&gt;00&lt;/span&gt;:00:00     
extras                                                                                                &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;.4 kB  &lt;span class="m"&gt;00&lt;/span&gt;:00:00     
updates                                                                                               &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;.4 kB  &lt;span class="m"&gt;00&lt;/span&gt;:00:00     
正在解决依赖关系
--&amp;gt; 正在检查事务
---&amp;gt; 软件包 NetworkManager.x86_64.1.1.12.0-6.el7 将被 升级
---&amp;gt; 软件包 NetworkManager.x86_64.1.1.12.0-10.el7_6 将被 更新
&lt;span class="c1"&gt;##（期间要选择确认，输入 y 即可）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum install -y yum-utils device-mapper-persistent-data lvm2&lt;/span&gt;
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: centos.ustc.edu.cn
 * extras: mirrors.aliyun.com
 * updates: mirrors.cn99.com
软件包 device-mapper-persistent-data-0.7.3-3.el7.x86_64 已安装并且是最新版本
软件包 &lt;span class="m"&gt;7&lt;/span&gt;:lvm2-2.02.180-10.el7_6.8.x86_64 已安装并且是最新版本
正在解决依赖关系
--&amp;gt; 正在检查事务
---&amp;gt; 软件包 yum-utils.noarch.0.1.1.31-50.el7 将被 安装
--&amp;gt; 正在处理依赖关系 python-kitchen，它被软件包 yum-utils-1.1.31-50.el7.noarch 需要
...
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补充：LVM是Logical Volume Manager（逻辑卷管理器）的简写，又译为逻辑卷宗管理器、逻辑扇区管理器、逻辑磁盘管理器。是Linux核心所提供的逻辑卷管理（Logical Volume Management）功能。它在硬盘的硬盘分区之上，又创建了一个逻辑层以方便系统管理硬盘分区系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置 yum 源（选择其中一个）&lt;/p&gt;
&lt;p&gt;yum-config-manager --add-repo &lt;a href="http://download.docker.com/linux/centos/docker-ce.repo（中央仓库）"&gt;http://download.docker.com/linux/centos/docker-ce.repo（中央仓库）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;yum-config-manager --add-repo &lt;a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库）"&gt;http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库）&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum-config-manager --add-repo &lt;/span&gt;
https://download.docker.com/linux/centos/docker-ce.repo
已加载插件：fastestmirror
adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
grabbing file https://download.docker.com/linux/centos/docker-ce.repo to 
/etc/yum.repos.d/docker-ce.repo
repo saved to /etc/yum.repos.d/docker-ce.repo
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以查看所有仓库中所有docker版本，并选择特定版本安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum list docker-ce --showduplicates | sort -r&lt;/span&gt;
已加载插件：fastestmirror
可安装的软件包
 * updates: mirrors.cn99.com
Loading mirror speeds from cached hostfile
 * extras: mirrors.aliyun.com
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:19.03.2-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:19.03.1-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:19.03.0-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.8-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.7-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.6-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.5-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.4-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.3-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.2-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.1-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.0-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.06.3.ce-3.el7                    docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.06.2.ce-3.el7                    docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.06.1.ce-3.el7                    docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.06.0.ce-3.el7                    docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.03.1.ce-1.el7.centos             docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.03.0.ce-1.el7.centos             docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;17&lt;/span&gt;.12.1.ce-1.el7.centos             docker-ce-stable
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Docker，命令：&lt;code&gt;yum install docker-ce-版本号&lt;/code&gt;，我选的是&lt;code&gt;docker-ce-18.03.1.ce&lt;/code&gt;，如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum install docker-ce-18.03.1.ce&lt;/span&gt;
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: centos.ustc.edu.cn
 * extras: mirrors.aliyun.com
 * updates: mirrors.cn99.com
正在解决依赖关系
--&amp;gt; 正在检查事务
---&amp;gt; 软件包 docker-ce.x86_64.0.18.03.1.ce-1.el7.centos 将被 安装
&lt;span class="c1"&gt;##（期间要选择确认，输入 y 即可）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[可选]配置阿里云镜像加速&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 104.68920392584515" data-width="1920" data-height="917"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/0a7b0d2480e8e35788102af644e7a97e.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;span class="s"&gt;&amp;lt;&amp;lt;-&amp;#39;EOF&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;{&lt;/span&gt;
&lt;span class="s"&gt;  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://*****.mirror.aliyuncs.com&amp;quot;]&lt;/span&gt;
&lt;span class="s"&gt;}&lt;/span&gt;
&lt;span class="s"&gt;EOF&lt;/span&gt;
sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动Docker，命令：systemctl start docker，然后加入开机启动，如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# systemctl start docker&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# systemctl enable  docker&lt;/span&gt;
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker version&lt;/span&gt;
Client:
 Version:      &lt;span class="m"&gt;18&lt;/span&gt;.03.1-ce
 API version:  &lt;span class="m"&gt;1&lt;/span&gt;.37
 Go version:   go1.9.5
 Git commit:   9ee9f40
 Built:        Thu Apr &lt;span class="m"&gt;26&lt;/span&gt; &lt;span class="m"&gt;07&lt;/span&gt;:20:16 &lt;span class="m"&gt;2018&lt;/span&gt;
 OS/Arch:      linux/amd64
 Experimental: &lt;span class="nb"&gt;false&lt;/span&gt;
 Orchestrator: swarm

Server:
 Engine:
  Version:      &lt;span class="m"&gt;18&lt;/span&gt;.03.1-ce
  API version:  &lt;span class="m"&gt;1&lt;/span&gt;.37 &lt;span class="o"&gt;(&lt;/span&gt;minimum version &lt;span class="m"&gt;1&lt;/span&gt;.12&lt;span class="o"&gt;)&lt;/span&gt;
  Go version:   go1.9.5
  Git commit:   9ee9f40
  Built:        Thu Apr &lt;span class="m"&gt;26&lt;/span&gt; &lt;span class="m"&gt;07&lt;/span&gt;:23:58 &lt;span class="m"&gt;2018&lt;/span&gt;
  OS/Arch:      linux/amd64
  Experimental: &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;docker&lt;/code&gt; 命令会使用 &lt;a href="https://en.wikipedia.org/wiki/Unix_domain_socket"&gt;Unix socket&lt;/a&gt; 与 Docker 引擎通讯。而只有 &lt;code&gt;root&lt;/code&gt; 用户和 &lt;code&gt;docker&lt;/code&gt; 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 &lt;code&gt;root&lt;/code&gt; 用户。因此，更好地做法是将需要使用 &lt;code&gt;docker&lt;/code&gt; 的用户加入 &lt;code&gt;docker&lt;/code&gt; 用户组。&lt;/p&gt;
&lt;p&gt;建立 &lt;code&gt;docker&lt;/code&gt; 组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# sudo groupadd docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将当前用户加入 &lt;code&gt;docker&lt;/code&gt; 组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# sudo usermod -aG docker $USER&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;退出当前终端并重新登录，进行如下测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试 Docker 是否安装正确&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker run hello-world&lt;/span&gt;
   Unable to find image &lt;span class="s1"&gt;&amp;#39;hello-world:latest&amp;#39;&lt;/span&gt; locally
   latest: Pulling from library/hello-world
   0e03bdcc26d7: Pull &lt;span class="nb"&gt;complete&lt;/span&gt; 
   Digest: sha256:4cf9c47f86df71d48364001ede3a4fcd85ae80ce02ebad74156906caff5378bc
   Status: Downloaded newer image &lt;span class="k"&gt;for&lt;/span&gt; hello-world:latest

   Hello from Docker!             --&amp;gt; 出现这句话代表Docker安装没有问题
   This message shows that your installation appears to be working correctly.

   To generate this message, Docker took the following steps:
    &lt;span class="m"&gt;1&lt;/span&gt;. The Docker client contacted the Docker daemon.
    &lt;span class="m"&gt;2&lt;/span&gt;. The Docker daemon pulled the &lt;span class="s2"&gt;&amp;quot;hello-world&amp;quot;&lt;/span&gt; image from the Docker Hub.
       &lt;span class="o"&gt;(&lt;/span&gt;amd64&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;3&lt;/span&gt;. The Docker daemon created a new container from that image which runs the
       executable that produces the output you are currently reading.
    &lt;span class="m"&gt;4&lt;/span&gt;. The Docker daemon streamed that output to the Docker client, which sent it
       to your terminal.

   To try something more ambitious, you can run an Ubuntu container with:
    $ docker run -it ubuntu bash

   Share images, automate workflows, and more with a free Docker ID:
    https://hub.docker.com/

   For more examples and ideas, visit:
    https://docs.docker.com/get-started/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若能正常输出以上信息，则说明安装成功。&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj30/</guid><pubDate>Wed, 16 Sep 2020 00:30:00 +0806</pubDate></item><item><title>Docker笔记</title><link>/Xuxx_Blogs/archives/bj31/</link><description>&lt;h2&gt;Docker引擎&lt;/h2&gt;
&lt;p&gt;Docker引擎是一个包含以下主要组件的客户端服务器应用程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;—种服务器，它是一种被称为守护进程（deamon）并且长时间运行的程序。&lt;/li&gt;
&lt;li&gt;REST API 用于指定程序可以用来与守护进程通信的接口，并指示它做什么。&lt;/li&gt;
&lt;li&gt;一个有命令行界面( CLI )工具的客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 78.69379014989293" data-width="735" data-height="467"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/f85888768c1310cf36b6193b4c0de484.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;Docker架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Docker 使用客户端-服务器 ( C/S ) 架构模式，使用远程 API 来管理和创建 Docker 容器。&lt;/li&gt;
&lt;li&gt;Docker 容器通过 Docker 镜像来创建。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器与镜像&lt;/strong&gt;的关系类似于面向对象编程中的&lt;strong&gt;对象与类&lt;/strong&gt;。---通过镜像生成容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 99.55035971223022" data-width="1107" data-height="556"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/785186682d24af870e5554ceb4678f80.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;镜像(Images)&lt;/td&gt;
&lt;td&gt;Docker镜像是用于创建Docker容器的模板。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;容器(Container&lt;strong&gt;)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;容器是独立运行的一个或一组应用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;客户端(Client)&lt;/td&gt;
&lt;td&gt;Docker客户端通过命令行或者其他工具使用Docker API与Docker的守护进程通信。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机(Host)&lt;/td&gt;
&lt;td&gt;一个物理或者虚拟的机器用于执行Docker守护进程和容器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;仓库(Registry)&lt;/td&gt;
&lt;td&gt;Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub (&lt;a href="https://hub.docker.com）提供了庞大的镜像集合供使用。"&gt;https://hub.docker.com）提供了庞大的镜像集合供使用。&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker Machine&lt;/td&gt;
&lt;td&gt;Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、Digital Ocean、Microsoft Azure。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Docker 操作镜像&lt;/h2&gt;
&lt;h3&gt;获取镜像&lt;/h3&gt;
&lt;p&gt;从Docker镜像仓库获取镜像的命令是 &lt;code&gt;docker pull&lt;/code&gt; 。其命令格式为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker pull &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;Docker Registry 地址&lt;span class="o"&gt;[&lt;/span&gt;:端口号&lt;span class="o"&gt;]&lt;/span&gt;/仓库名&lt;span class="o"&gt;[&lt;/span&gt;:标签&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的选项可以通过 &lt;code&gt;docker pull --help&lt;/code&gt;命令看到，这里说一下镜像名称的格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;镜像仓库地址&lt;/strong&gt;：地址的格式一般是&amp;lt;域名/IP&amp;gt;[：端口号]。默认地址是Docker Hub。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仓库名&lt;/strong&gt;：如之前所说，这里的仓库名是两段式名称，即&lt;code&gt;&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;&lt;/code&gt;。对于Docker Hub，如果不给出用户名，则默认为 &lt;code&gt;library&lt;/code&gt;，也就是官方镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;列出镜像&lt;/h3&gt;
&lt;p&gt;想要列出已经下载的镜像，可以使用 &lt;code&gt;docker images&lt;/code&gt;或者&lt;code&gt;docker image ls&lt;/code&gt;命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker images&lt;/span&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mydemo1             latest              3b239960848d        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              54300df71941        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              e7e0ba36be39        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
tomcat              latest              2eb5a120304e        &lt;span class="m"&gt;3&lt;/span&gt; months ago        647MB
hello-world         latest              bf756fb1ae65        &lt;span class="m"&gt;8&lt;/span&gt; months ago        &lt;span class="m"&gt;13&lt;/span&gt;.3kB
rabbitmq            &lt;span class="m"&gt;3&lt;/span&gt;.7.3-management    2f415b0e9a6e        &lt;span class="m"&gt;2&lt;/span&gt; years ago         151MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间。&lt;strong&gt;镜像ID则&lt;/strong&gt;是镜像的唯一标识，一个镜像可以对应多个标签。&lt;/p&gt;
&lt;h4&gt;虚悬镜像&lt;/h4&gt;
&lt;p&gt;有时在镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              54300df71941        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个镜像原本是有镜像名和标签的，原来为（例如）&lt;code&gt;mongo: 3.2&lt;/code&gt;，随着官方镜像维护，发布了新版本后，重新&lt;code&gt;docker pull mongo:3.2&lt;/code&gt;时，&lt;code&gt;mongo:3.2&lt;/code&gt;这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;。除了&lt;code&gt;docker pull&lt;/code&gt;可能导致这种情况，&lt;code&gt;docker build&lt;/code&gt;也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;的镜像。这类无标签镜像也被称为&lt;strong&gt;虚悬镜像(dangling image)&lt;/strong&gt;，可以用下面的命令专门显示这类镜像:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker images -f dangling=true&lt;/span&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              54300df71941        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              e7e0ba36be39        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker image prune&lt;/span&gt;
WARNING! This will remove all dangling images.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt;? &lt;span class="o"&gt;[&lt;/span&gt;y/N&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;输入&lt;span class="o"&gt;)&lt;/span&gt;y
Deleted Images:
deleted: sha256:e7e0ba36be3927af3f1d7a0b99263d4aa6e6af1d93b9d3455c0a045d4f4a477a
deleted: sha256:05ff87569ed6bfdc38621112bea7aafffed7895538490748e85fdf00da19d3b6

Total reclaimed space: 12B
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;中间层镜像&lt;/h4&gt;
&lt;p&gt;为了加速镜像构建、重复利用资源,Docker会利用&lt;strong&gt;中间层镜像&lt;/strong&gt;。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的&lt;code&gt;docker image ls&lt;/code&gt;表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加&lt;code&gt;-a&lt;/code&gt;参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker images -a&lt;/span&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              9e5197c9a0e5        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
mydemo1             latest              3b239960848d        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              660dfcd0a262        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              1b63db1e38f7        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              f1343ffd435c        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              54300df71941        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
tomcat              latest              2eb5a120304e        &lt;span class="m"&gt;3&lt;/span&gt; months ago        647MB
hello-world         latest              bf756fb1ae65        &lt;span class="m"&gt;8&lt;/span&gt; months ago        &lt;span class="m"&gt;13&lt;/span&gt;.3kB
rabbitmq            &lt;span class="m"&gt;3&lt;/span&gt;.7.3-management    2f415b0e9a6e        &lt;span class="m"&gt;2&lt;/span&gt; years ago         151MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。&lt;/p&gt;
&lt;h3&gt;镜像体积&lt;/h3&gt;
&lt;p&gt;如果仔细观察，会注意到，这里标识的所占用空间和在Docker Hub上看到的镜像大小不同。比如,&lt;code&gt;ubuntu:16.04&lt;/code&gt;镜像大小，在这里是&lt;strong&gt;127 MB&lt;/strong&gt;，但是在Docker Hub显示的却是&lt;strong&gt;50 MB&lt;/strong&gt;。这是因为 Docker Hub 中显示的体积是&lt;strong&gt;压缩后的体积&lt;/strong&gt;。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 &lt;code&gt;docker images&lt;/code&gt;显示的是镜像下载到本地后，&lt;strong&gt;展开的大小&lt;/strong&gt;，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。&lt;/p&gt;
&lt;p&gt;另外一个需要注意的问题是，&lt;code&gt;docker images&lt;/code&gt;列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此&lt;strong&gt;不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层&lt;/strong&gt;。由于Docker使用&lt;code&gt;Union FS&lt;/code&gt;，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。&lt;/p&gt;
&lt;p&gt;可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker system df&lt;/span&gt;
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              &lt;span class="m"&gt;6&lt;/span&gt;                   &lt;span class="m"&gt;5&lt;/span&gt;                   &lt;span class="m"&gt;798&lt;/span&gt;.4MB             &lt;span class="m"&gt;647&lt;/span&gt;.3MB &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;81&lt;/span&gt;%&lt;span class="o"&gt;)&lt;/span&gt;
Containers          &lt;span class="m"&gt;6&lt;/span&gt;                   &lt;span class="m"&gt;0&lt;/span&gt;                   &lt;span class="m"&gt;4&lt;/span&gt;.806MB             &lt;span class="m"&gt;4&lt;/span&gt;.806MB &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;%&lt;span class="o"&gt;)&lt;/span&gt;
Local Volumes       &lt;span class="m"&gt;7&lt;/span&gt;                   &lt;span class="m"&gt;1&lt;/span&gt;                   &lt;span class="m"&gt;30&lt;/span&gt;.6MB              &lt;span class="m"&gt;26&lt;/span&gt;.49MB &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;86&lt;/span&gt;%&lt;span class="o"&gt;)&lt;/span&gt;
Build Cache         &lt;span class="m"&gt;0&lt;/span&gt;                   &lt;span class="m"&gt;0&lt;/span&gt;                   0B                  0B
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除镜像&lt;/h3&gt;
&lt;p&gt;如果要删除本地的镜像，可以使用&lt;code&gt;docker image rm&lt;/code&gt;或者&lt;code&gt;docker rmi&lt;/code&gt;命令，其格式为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker image rm [选项]  &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker rmi [选项]  &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;&amp;lt;镜像&amp;gt;&lt;/code&gt;可以是&lt;code&gt;镜像短ID&lt;/code&gt; 、&lt;code&gt;镜像长ID&lt;/code&gt;、&lt;code&gt;镜像名&lt;/code&gt;或者&lt;code&gt;镜像摘要&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;Docker操作容器&lt;/h2&gt;
&lt;h3&gt;启动容器&lt;/h3&gt;
&lt;p&gt;所需要的命令主要为&lt;code&gt;docker run&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-i  以交互模式运行容器，通常与 -t 同时使用；&lt;/li&gt;
&lt;li&gt;-t  为容器重新分配一个伪输入终端；&lt;/li&gt;
&lt;li&gt;--name 为容器指定一个名称；&lt;/li&gt;
&lt;li&gt;-d  已守护方式启动容器&lt;/li&gt;
&lt;li&gt;-p 指定端口映射，格式为：&lt;code&gt;主机(宿主机)端口:容器端口&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-P 随机端口映射，容器内部端口&lt;strong&gt;随机&lt;/strong&gt;映射到主机的端口&lt;/li&gt;
&lt;li&gt;--volume , -v 绑定一个数据卷&lt;/li&gt;
&lt;li&gt;--expose=[] 开放一个端口或一组端口；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用docker镜像 nginx:latest 以后台模式启动一个容器,并将容器命名为mynginx。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --name mynginx -d nginx:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用镜像 nginx:latest 以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -P -d nginx:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -p 80:80 -v /data:/data -d nginx:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -p 127.0.0.1:80:8080/tcp ubuntu bash&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用镜像 nginx:latest 以交互模式启动一个容器,在容器内执行 /bin/bash 命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it nginx:latest /bin/bash
root@b8573233d675:/#&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当利用 docker run 来创建容器时，Docker在后台运行的标准操作包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查本地是否存在指定的镜像，不存在就从公有仓库下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用镜像创建并启动一个容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分配一个文件系统，并在只读的镜像层外面挂载一层可读写层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从地址池配置一个ip 地址给容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行用户指定的应用程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行完毕后容器被终止&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;start/stop/restart 命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;docker start&lt;/strong&gt; :启动一个或多个已经被停止的容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker stop&lt;/strong&gt; :停止一个运行中的容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker restart&lt;/strong&gt; :重启容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker start [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker stop [选项] &amp;lt;镜像&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker restart [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动已被停止的容器 myrunoob&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker start myrunoob&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;停止运行中的容器 myrunoob&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker stop myrunoob&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启容器 myrunoob&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker restart myrunoob&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看容器&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;docker ps&lt;/code&gt;命令可以查看正在运行的容器，格式为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker ps [选项]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-a :&lt;/strong&gt;显示所有的容器，包括未运行的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-f :&lt;/strong&gt;根据条件过滤显示的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-l :&lt;/strong&gt;显示最近创建的容器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-n :&lt;/strong&gt;列出最近创建的n个容器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--no-trunc :&lt;/strong&gt;不截断输出(打印完整的容器 ID)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-s :&lt;/strong&gt;显示总的文件大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker run -p 8080:8080 -d tomcat&lt;/span&gt;
ed8b228b1e55845241c26e8ede042bae4132700d7334ae44438ce0e60282ff3c

&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker ps&lt;/span&gt;
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
ed8b228b1e55        tomcat              &lt;span class="s2"&gt;&amp;quot;catalina.sh run&amp;quot;&lt;/span&gt;   &lt;span class="m"&gt;8&lt;/span&gt; seconds ago       Up &lt;span class="m"&gt;3&lt;/span&gt; seconds        &lt;span class="m"&gt;0&lt;/span&gt;.0.0.0:8080-&amp;gt;8080/tcp   elastic_gauss
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出详情介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CONTAINER ID:&lt;/strong&gt; 容器 ID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMAGE:&lt;/strong&gt; 使用的镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COMMAND:&lt;/strong&gt; 启动容器时运行的命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CREATED:&lt;/strong&gt; 容器的创建时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STATUS:&lt;/strong&gt; 容器状态。&lt;/p&gt;
&lt;p&gt;状态有7种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;created（已创建）&lt;/li&gt;
&lt;li&gt;restarting（重启中）&lt;/li&gt;
&lt;li&gt;running（运行中）&lt;/li&gt;
&lt;li&gt;removing（迁移中）&lt;/li&gt;
&lt;li&gt;paused（暂停）&lt;/li&gt;
&lt;li&gt;exited（停止）&lt;/li&gt;
&lt;li&gt;dead（死亡）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PORTS:&lt;/strong&gt; 容器的端口信息和使用的连接类型（tcp\udp）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NAMES:&lt;/strong&gt; 自动分配的容器名称。&lt;/p&gt;
&lt;h3&gt;进入容器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;docker exec ：&lt;/strong&gt;在运行的容器中执行命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker exec [OPTIONS] CONTAINER COMMAND [ARG...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OPTIONS说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-d :&lt;/strong&gt;分离模式(守护态): 在后台运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-i :&lt;/strong&gt;即使没有附加也保持STDIN 打开&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-t :&lt;/strong&gt;分配一个伪终端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在容器 tomcat 中开启一个交互模式的终端:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker exec -it tomcat  /bin/bash&lt;/span&gt;
root@99da97385e5f:/usr/local/tomcat#
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除容器&lt;/h3&gt;
&lt;p&gt;可以使用&lt;code&gt;docker container rm&lt;/code&gt;来删除一个处于终止状态的容器。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker container rm 99da97385e5f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要删除一个运行中的容器，可以添加&lt;code&gt;-f&lt;/code&gt;参数。Docker 会发送 &lt;code&gt;SIGKILL( 终止进程)&lt;/code&gt;信号给容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除所有容器&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker rm $(docker ps -a -q)&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;清理所有处于终止状态的容器&lt;/h3&gt;
&lt;p&gt;用&lt;code&gt;docker container ls -a&lt;/code&gt;命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker container prune&lt;/span&gt;
WARNING! This will remove all stopped containers.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt;? &lt;span class="o"&gt;[&lt;/span&gt;y/N&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;输入&lt;span class="o"&gt;)&lt;/span&gt;y
Deleted Containers:
82ab3ce8fee74e258d90ab6984ec5dc3e5cdf453e8a3c92a1b18ce054b6a5a56
ed8b228b1e55845241c26e8ede042bae4132700d7334ae44438ce0e60282ff3c
...
Total reclaimed space: &lt;span class="m"&gt;4&lt;/span&gt;.818MB
&lt;/pre&gt;&lt;/div&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj31/</guid><pubDate>Thu, 17 Sep 2020 13:30:00 +0806</pubDate></item><item><title>Dockerfile笔记</title><link>/Xuxx_Blogs/archives/bj32/</link><description>&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;从 &lt;a href="https://yeasy.gitbook.io/docker_practice/image/commit"&gt;docker commit&lt;/a&gt; 的学习中，可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。&lt;/p&gt;
&lt;p&gt;Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/p&gt;
&lt;p&gt;以 tomcat 镜像为例，这次使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为&lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir myshop
&lt;span class="nb"&gt;cd&lt;/span&gt; myshop
touch Dockerfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其内容为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;tomcat&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; Hello,Docker! &amp;gt; /usr/local/tomcat/webapps/ROOT/index.jsp
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;FROM-指定基础镜像&lt;/h2&gt;
&lt;p&gt;所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而FROM就是指定基础镜像，因此&lt;strong&gt;一个 Dockerfile 中 FROM是必备的指令，并且必须是第一条指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了选择(在Docker Hub上)现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为&lt;code&gt;scratch&lt;/code&gt;。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。&lt;/p&gt;
&lt;p&gt;如果你以 &lt;code&gt;scratch&lt;/code&gt; 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。&lt;/p&gt;
&lt;h2&gt;RUN 执行命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RUN&lt;/code&gt; 指令是用来执行命令行命令的。由于命令行的强大能力，&lt;code&gt;RUN&lt;/code&gt; 指令在定制镜像时是最常用的指令之一。其格式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;shell&lt;/em&gt; 格式：&lt;code&gt;RUN &amp;lt;命令&amp;gt;&lt;/code&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 &lt;code&gt;RUN&lt;/code&gt; 指令就是这种格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; Hello,Docker! &amp;gt; /usr/local/tomcat/webapps/ROOT/index.jsp
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;exec&lt;/em&gt; 格式：&lt;code&gt;RUN ["可执行文件", "参数1", "参数2"]&lt;/code&gt;，这更像是函数调用中的格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然 &lt;code&gt;RUN&lt;/code&gt; 就像 Shell 脚本一样可以执行命令，那么是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;debian:stretch&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get install -y gcc libc6-dev make wget
&lt;span class="k"&gt;RUN&lt;/span&gt; wget -O redis.tar.gz &lt;span class="s2"&gt;&amp;quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; mkdir -p /usr/src/redis
&lt;span class="k"&gt;RUN&lt;/span&gt; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; make -C /usr/src/redis
&lt;span class="k"&gt;RUN&lt;/span&gt; make -C /usr/src/redis install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前说过，&lt;strong&gt;Dockerfile 中每一个指令都会建立一层&lt;/strong&gt;，&lt;code&gt;RUN&lt;/code&gt; 也不例外。每一个 &lt;code&gt;RUN&lt;/code&gt; 的行为，就和手动建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，&lt;code&gt;commit&lt;/code&gt; 这一层的修改，构成新的镜像。&lt;/p&gt;
&lt;p&gt;而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面的 &lt;code&gt;Dockerfile&lt;/code&gt; 正确的写法应该是这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;debian:stretch&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt; -x&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;buildDeps&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gcc libc6-dev make wget&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get update &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install -y &lt;span class="nv"&gt;$buildDeps&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; wget -O redis.tar.gz &lt;span class="s2"&gt;&amp;quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkdir -p /usr/src/redis &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -C /usr/src/redis &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -C /usr/src/redis install &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/* &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm redis.tar.gz &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -r /usr/src/redis &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get purge -y --auto-remove &lt;span class="nv"&gt;$buildDeps&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 &lt;code&gt;RUN&lt;/code&gt; 一一对应不同的命令，而是仅仅使用一个 &lt;code&gt;RUN&lt;/code&gt; 指令，并使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建&lt;/p&gt;
&lt;p&gt;并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 &lt;code&gt;\&lt;/code&gt; 的命令换行方式，以及行首 &lt;code&gt;#&lt;/code&gt; 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。&lt;/p&gt;
&lt;p&gt;此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 &lt;code&gt;apt&lt;/code&gt; 缓存文件。这是很重要的一步，之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。&lt;/p&gt;
&lt;h2&gt;构建镜像&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt; 命令进行镜像构建。其语法为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker build &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt; &amp;lt;上下文路径/URL/-&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;code&gt;Dockerfile&lt;/code&gt; 文件所在目录执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost myshop&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker build -t myshop .&lt;/span&gt;
Sending build context to Docker daemon  &lt;span class="m"&gt;3&lt;/span&gt;.072kB
Step &lt;span class="m"&gt;1&lt;/span&gt;/2 : FROM tomcat:latest
 ---&amp;gt; 2eb5a120304e
Step &lt;span class="m"&gt;2&lt;/span&gt;/2 : COPY index.jsp /usr/local/tomcat/webapps/ROOT
 ---&amp;gt; f44b1d0d1366
Successfully built f44b1d0d1366
Successfully tagged myshop:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;镜像构建上下文（Context）&lt;/h2&gt;
&lt;p&gt;如果注意，会看到 &lt;code&gt;docker build&lt;/code&gt; 命令最后有一个 &lt;code&gt;.&lt;/code&gt;。&lt;code&gt;.&lt;/code&gt; 表示当前目录，而 &lt;code&gt;Dockerfile&lt;/code&gt; 就在当前目录，因此不少初学者以为这个路径是在指定 &lt;code&gt;Dockerfile&lt;/code&gt; 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 &lt;strong&gt;上下文路径&lt;/strong&gt;。那么什么是上下文呢？&lt;/p&gt;
&lt;p&gt;当进行镜像构建的时候，并非所有定制都会通过 &lt;code&gt;RUN&lt;/code&gt; 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 &lt;code&gt;COPY&lt;/code&gt; 指令、&lt;code&gt;ADD&lt;/code&gt; 指令等。而 &lt;code&gt;docker build&lt;/code&gt; 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？&lt;/p&gt;
&lt;p&gt;这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，&lt;code&gt;docker build&lt;/code&gt; 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。&lt;/p&gt;
&lt;p&gt;如果在 Dockerfile 中这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY ./package.json /app/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这并不是要复制执行 &lt;code&gt;docker build&lt;/code&gt; 命令所在的目录下的 &lt;code&gt;package.json&lt;/code&gt;，也不是复制 &lt;code&gt;Dockerfile&lt;/code&gt; 所在目录下的 &lt;code&gt;package.json&lt;/code&gt;，而是复制 &lt;strong&gt;上下文（context）&lt;/strong&gt; 目录下的 &lt;code&gt;package.json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其它&lt;/strong&gt; &lt;code&gt;docker build&lt;/code&gt; &lt;strong&gt;的用法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接用 Git repo 进行构建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这行命令指定了构建所需的 Git repo，并且指定分支为 &lt;code&gt;master&lt;/code&gt;，构建目录为 &lt;code&gt;/amd64/hello-world/&lt;/code&gt;，然后 Docker 就会自己去 &lt;code&gt;git clone&lt;/code&gt; 这个项目、切换到指定分支、并进入到指定目录后开始构建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用给定的 tar 压缩包构建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build http://server/context.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果所给出的 URL 不是个 Git repo，而是个 &lt;code&gt;tar&lt;/code&gt; 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从标准输入中读取 Dockerfile 进行构建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build - &amp;lt; Dockerfile&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat Dockerfile | docker build -&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果标准输入传入的是文本文件，则将其视为 &lt;code&gt;Dockerfile&lt;/code&gt;，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 &lt;code&gt;COPY&lt;/code&gt; 进镜像之类的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从标准输入中读取上下文压缩包进行构建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build - &amp;lt; context.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果发现标准输入的文件格式是 &lt;code&gt;gzip&lt;/code&gt;、&lt;code&gt;bzip2&lt;/code&gt; 以及 &lt;code&gt;xz&lt;/code&gt; 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Dockerfile 指令详解&lt;/h2&gt;
&lt;h3&gt;COPY 复制文件&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;源路径&amp;gt;... &amp;lt;目标路径&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] ["&amp;lt;源路径1&amp;gt;",... "&amp;lt;目标路径&amp;gt;"]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和 &lt;code&gt;RUN&lt;/code&gt; 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;COPY&lt;/code&gt; 指令将从构建上下文目录中 &lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 的文件/目录复制到新的一层的镜像内的 &lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 位置。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY package.json /usr/src/app/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 &lt;a href="https://golang.org/pkg/path/filepath/#Match"&gt;&lt;code&gt;filepath.Match&lt;/code&gt;&lt;/a&gt; 规则，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY hom* /mydir/COPY hom?.txt /mydir/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 &lt;code&gt;WORKDIR&lt;/code&gt; 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。&lt;/p&gt;
&lt;p&gt;此外，还需要注意一点，使用 &lt;code&gt;COPY&lt;/code&gt; 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。&lt;/p&gt;
&lt;p&gt;在使用该指令的时候还可以加上 &lt;code&gt;--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;&lt;/code&gt; 选项来改变文件的所属用户及所属组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。&lt;/p&gt;
&lt;h3&gt;ADD 更高级的复制文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ADD&lt;/code&gt; 指令和 &lt;code&gt;COPY&lt;/code&gt; 的格式和性质基本一致。但是在 &lt;code&gt;COPY&lt;/code&gt; 基础上增加了一些功能。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 可以是一个 &lt;code&gt;URL&lt;/code&gt;，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 去。下载后的文件权限自动设置为 &lt;code&gt;600&lt;/code&gt;，如果这并不是想要的权限，那么还需要增加额外的一层 &lt;code&gt;RUN&lt;/code&gt; 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 &lt;code&gt;RUN&lt;/code&gt; 指令进行解压缩。所以不如直接使用 &lt;code&gt;RUN&lt;/code&gt; 指令，然后使用 &lt;code&gt;wget&lt;/code&gt; 或者 &lt;code&gt;curl&lt;/code&gt; 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 为一个 &lt;code&gt;tar&lt;/code&gt; 压缩文件的话，压缩格式为 &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; 以及 &lt;code&gt;xz&lt;/code&gt; 的情况下，&lt;code&gt;ADD&lt;/code&gt; 指令将会自动解压缩这个压缩文件到 &lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 去。&lt;/p&gt;
&lt;p&gt;在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 &lt;code&gt;ubuntu&lt;/code&gt; 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但在某些情况下，如果真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 &lt;code&gt;ADD&lt;/code&gt; 命令了。&lt;/p&gt;
&lt;p&gt;在 Docker 官方的 &lt;a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices"&gt;Dockerfile 最佳实践文档&lt;/a&gt; 中要求，尽可能的使用 &lt;code&gt;COPY&lt;/code&gt;，因为 &lt;code&gt;COPY&lt;/code&gt; 的语义很明确，就是复制文件而已，而 &lt;code&gt;ADD&lt;/code&gt; 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 &lt;code&gt;ADD&lt;/code&gt; 的场合，就是所提及的需要自动解压缩的场合。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，&lt;code&gt;ADD&lt;/code&gt; 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。&lt;/p&gt;
&lt;p&gt;因此在 &lt;code&gt;COPY&lt;/code&gt; 和 &lt;code&gt;ADD&lt;/code&gt; 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 &lt;code&gt;COPY&lt;/code&gt; 指令，仅在需要自动解压缩的场合使用 &lt;code&gt;ADD&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在使用该指令的时候还可以加上 &lt;code&gt;--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;&lt;/code&gt; 选项来改变文件的所属用户及所属组。&lt;/p&gt;
&lt;h3&gt;CMD 容器启动命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CMD&lt;/code&gt; 指令的格式和 &lt;code&gt;RUN&lt;/code&gt; 相似，也是两种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shell&lt;/code&gt; 格式：&lt;code&gt;CMD &amp;lt;命令&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec&lt;/code&gt; 格式：&lt;code&gt;CMD ["可执行文件", "参数1", "参数2"...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参数列表格式：&lt;code&gt;CMD ["参数1", "参数2"...]&lt;/code&gt;。在指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 指令后，用 &lt;code&gt;CMD&lt;/code&gt; 指定具体的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。&lt;code&gt;CMD&lt;/code&gt; 指令就是用于指定默认的容器主进程的启动命令的。&lt;/p&gt;
&lt;p&gt;在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，&lt;code&gt;ubuntu&lt;/code&gt; 镜像默认的 &lt;code&gt;CMD&lt;/code&gt; 是 &lt;code&gt;/bin/bash&lt;/code&gt;，如果直接 &lt;code&gt;docker run -it ubuntu&lt;/code&gt; 的话，会直接进入 &lt;code&gt;bash&lt;/code&gt;。也可以在运行时指定运行别的命令，如 &lt;code&gt;docker run -it ubuntu cat /etc/os-release&lt;/code&gt;。这就是用 &lt;code&gt;cat /etc/os-release&lt;/code&gt; 命令替换了默认的 &lt;code&gt;/bin/bash&lt;/code&gt; 命令了，输出了系统版本信息。&lt;/p&gt;
&lt;p&gt;在指令格式上，一般推荐使用 &lt;code&gt;exec&lt;/code&gt; 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &lt;code&gt;"&lt;/code&gt;，而不要使用单引号。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;shell&lt;/code&gt; 格式的话，实际的命令会被包装为 &lt;code&gt;sh -c&lt;/code&gt; 的参数的形式进行执行。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CMD echo $HOME&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际执行中，会将其变更为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CMD [ "sh", "-c", "echo $HOME" ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是为什么可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。&lt;/p&gt;
&lt;p&gt;提到 &lt;code&gt;CMD&lt;/code&gt; 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。&lt;/p&gt;
&lt;p&gt;Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 &lt;code&gt;systemd&lt;/code&gt; 去启动后台服务，容器内没有后台服务的概念。&lt;/p&gt;
&lt;p&gt;一些初学者将 &lt;code&gt;CMD&lt;/code&gt; 写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CMD service nginx start&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后发现容器执行后就立即退出了。甚至在容器内去使用 &lt;code&gt;systemctl&lt;/code&gt; 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。&lt;/p&gt;
&lt;p&gt;对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。&lt;/p&gt;
&lt;p&gt;而使用 &lt;code&gt;service nginx start&lt;/code&gt; 命令，则是希望 upstart 来以后台守护进程形式启动 &lt;code&gt;nginx&lt;/code&gt; 服务。而刚才说了 &lt;code&gt;CMD service nginx start&lt;/code&gt; 会被理解为 &lt;code&gt;CMD [ "sh", "-c", "service nginx start"]&lt;/code&gt;，因此主进程实际上是 &lt;code&gt;sh&lt;/code&gt;。那么当 &lt;code&gt;service nginx start&lt;/code&gt; 命令结束后，&lt;code&gt;sh&lt;/code&gt; 也就结束了，&lt;code&gt;sh&lt;/code&gt; 作为主进程退出了，自然就会令容器退出。&lt;/p&gt;
&lt;p&gt;正确的做法是直接执行 &lt;code&gt;nginx&lt;/code&gt; 可执行文件，并且要求以前台形式运行。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CMD ["nginx", "-g", "daemon off;"]&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ENTRYPOINT 入口点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ENTRYPOINT&lt;/code&gt; 的格式和 &lt;code&gt;RUN&lt;/code&gt; 指令格式一样，分为 &lt;code&gt;exec&lt;/code&gt; 格式和 &lt;code&gt;shell&lt;/code&gt; 格式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ENTRYPOINT&lt;/code&gt; 的目的和 &lt;code&gt;CMD&lt;/code&gt; 一样，都是在指定容器启动程序及参数。&lt;code&gt;ENTRYPOINT&lt;/code&gt; 在运行时也可以替代，不过比 &lt;code&gt;CMD&lt;/code&gt; 要略显繁琐，需要通过 &lt;code&gt;docker run&lt;/code&gt; 的参数 &lt;code&gt;--entrypoint&lt;/code&gt; 来指定。&lt;/p&gt;
&lt;p&gt;当指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 后，&lt;code&gt;CMD&lt;/code&gt; 的含义就发生了改变，不再是直接的运行其命令，而是将 &lt;code&gt;CMD&lt;/code&gt; 的内容作为参数传给 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 指令，换句话说实际执行时，将变为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ENTRYPOINT&amp;gt; "&amp;lt;CMD&amp;gt;"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么有了 &lt;code&gt;CMD&lt;/code&gt; 后，为什么还要有 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 呢？这种 &lt;code&gt;&amp;lt;ENTRYPOINT&amp;gt; "&amp;lt;CMD&amp;gt;"&lt;/code&gt; 有什么好处么？让来看几个场景。&lt;/p&gt;
&lt;h4&gt;场景一：让镜像变成像命令一样使用&lt;/h4&gt;
&lt;p&gt;假设需要一个得知自己当前公网 IP 的镜像，那么可以先用 &lt;code&gt;CMD&lt;/code&gt; 来实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;ubuntu:18.04&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install -y curl &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/*
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;curl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;-s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;http://myip.ipip.net&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如使用 &lt;code&gt;docker build -t myip .&lt;/code&gt; 来构建镜像的话，如果需要查询当前公网 IP，只需要执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run myip
当前 IP：61.148.226.66 来自：北京市 联通
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果希望加参数呢？比如从上面的 &lt;code&gt;CMD&lt;/code&gt; 中可以看到实质的命令是 &lt;code&gt;curl&lt;/code&gt;，那么如果希望显示 HTTP 头信息，就需要加上 &lt;code&gt;-i&lt;/code&gt; 参数。那么可以直接加 &lt;code&gt;-i&lt;/code&gt; 参数给 &lt;code&gt;docker run myip&lt;/code&gt; 么？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run myip -i
docker: Error response from daemon: invalid header field value &lt;span class="s2"&gt;&amp;quot;oci runtime error: container_linux.go:247: starting container process caused \&amp;quot;exec: \\\&amp;quot;-i\\\&amp;quot;: executable file not found in &lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;\n&amp;quot;&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到可执行文件找不到的报错，&lt;code&gt;executable file not found&lt;/code&gt;。之前说过，跟在镜像名后面的是 &lt;code&gt;command&lt;/code&gt;，运行时会替换 &lt;code&gt;CMD&lt;/code&gt; 的默认值。因此这里的 &lt;code&gt;-i&lt;/code&gt; 替换了原来的 &lt;code&gt;CMD&lt;/code&gt;，而不是添加在原来的 &lt;code&gt;curl -s http://myip.ipip.net&lt;/code&gt; 后面。而 &lt;code&gt;-i&lt;/code&gt; 根本不是命令，所以自然找不到。&lt;/p&gt;
&lt;p&gt;那么如果希望加入 &lt;code&gt;-i&lt;/code&gt; 这参数，就必须重新完整的输入这个命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run myip curl -s http://myip.ipip.net -i
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这显然不是很好的解决方案，而使用 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 就可以解决这个问题。现在重新用 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 来实现这个镜像：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;ubuntu:18.04&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install -y curl &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/*
&lt;span class="k"&gt;ENTRYPOINT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;curl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;-s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;http://myip.ipip.net&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次再来尝试直接使用 &lt;code&gt;docker run myip -i&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run myip
当前 IP：61.148.226.66 来自：北京市 联通

$ docker run myip -i
HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; OK
Server: nginx/1.8.0
Date: Tue, &lt;span class="m"&gt;22&lt;/span&gt; Nov &lt;span class="m"&gt;2016&lt;/span&gt; &lt;span class="m"&gt;05&lt;/span&gt;:12:40 GMT
Content-Type: text/html&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;charset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;UTF-8
Vary: Accept-Encoding
X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
X-Cache: MISS from cache-2
X-Cache-Lookup: MISS from cache-2:80
X-Cache: MISS from proxy-2_6
Transfer-Encoding: chunked
Via: &lt;span class="m"&gt;1&lt;/span&gt;.1 cache-2:80, &lt;span class="m"&gt;1&lt;/span&gt;.1 proxy-2_6:8006
Connection: keep-alive
​
当前 IP：61.148.226.66 来自：北京市 联通
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，这次成功了。这是因为当存在 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 后，&lt;code&gt;CMD&lt;/code&gt; 的内容将会作为参数传给 &lt;code&gt;ENTRYPOINT&lt;/code&gt;，而这里 &lt;code&gt;-i&lt;/code&gt; 就是新的 &lt;code&gt;CMD&lt;/code&gt;，因此会作为参数传给 &lt;code&gt;curl&lt;/code&gt;，从而达到了预期的效果。&lt;/p&gt;
&lt;h4&gt;场景二：应用运行前的准备工作&lt;/h4&gt;
&lt;p&gt;启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;mysql&lt;/code&gt; 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。&lt;/p&gt;
&lt;p&gt;此外，可能希望避免使用 &lt;code&gt;root&lt;/code&gt; 用户去启动服务，从而提高安全性，而在启动服务前还需要以 &lt;code&gt;root&lt;/code&gt; 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 &lt;code&gt;root&lt;/code&gt; 身份执行，方便调试等。&lt;/p&gt;
&lt;p&gt;这些准备工作是和容器 &lt;code&gt;CMD&lt;/code&gt; 无关的，无论 &lt;code&gt;CMD&lt;/code&gt; 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 中去执行，而这个脚本会将接到的参数（也就是 &lt;code&gt;&amp;lt;CMD&amp;gt;&lt;/code&gt;）作为命令，在脚本最后执行。比如官方镜像 &lt;code&gt;redis&lt;/code&gt; 中就是这么做的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;alpine:3.4&lt;/span&gt;
...
&lt;span class="k"&gt;RUN&lt;/span&gt; addgroup -S redis &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; adduser -S -G redis redis
...
&lt;span class="k"&gt;ENTRYPOINT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;docker-entrypoint.sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 6379&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;redis-server&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 为 &lt;code&gt;docker-entrypoint.sh&lt;/code&gt; 脚本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
...
&lt;span class="c1"&gt;# allow the container to be started with `--user`&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;redis-server&amp;#39;&lt;/span&gt; -a &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;id -u&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
    find . &lt;span class="se"&gt;\!&lt;/span&gt; -user redis -exec chown redis &lt;span class="s1"&gt;&amp;#39;{}&amp;#39;&lt;/span&gt; +
    &lt;span class="nb"&gt;exec&lt;/span&gt; gosu redis &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nb"&gt;exec&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该脚本的内容就是根据 &lt;code&gt;CMD&lt;/code&gt; 的内容来判断，如果是 &lt;code&gt;redis-server&lt;/code&gt; 的话，则切换到 &lt;code&gt;redis&lt;/code&gt; 用户身份启动服务器，否则依旧使用 &lt;code&gt;root&lt;/code&gt; 身份执行。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it redis id
&lt;span class="nv"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;groups&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ENV 设置环境变量&lt;/h3&gt;
&lt;p&gt;格式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENV &amp;lt;key1&amp;gt;=&amp;lt;value1&amp;gt; &amp;lt;key2&amp;gt;=&amp;lt;value2&amp;gt;...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 &lt;code&gt;RUN&lt;/code&gt;，还是运行时的应用，都可以直接使用这里定义的环境变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ENV&lt;/span&gt; &lt;span class="nv"&gt;VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.0 &lt;span class="nv"&gt;DEBUG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;on &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="nv"&gt;NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Happy Feet&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。&lt;/p&gt;
&lt;p&gt;定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 &lt;code&gt;node&lt;/code&gt; 镜像 &lt;code&gt;Dockerfile&lt;/code&gt; 中，就有类似这样的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ENV&lt;/span&gt; NODE_VERSION &lt;span class="m"&gt;7&lt;/span&gt;.2.0

&lt;span class="k"&gt;RUN&lt;/span&gt; curl -SLO &lt;span class="s2"&gt;&amp;quot;https://nodejs.org/dist/v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;/node-v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;-linux-x64.tar.xz&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; curl -SLO &lt;span class="s2"&gt;&amp;quot;https://nodejs.org/dist/v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;/SHASUMS256.txt.asc&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot; node-v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;-linux-x64.tar.xz\$&amp;quot;&lt;/span&gt; SHASUMS256.txt &lt;span class="p"&gt;|&lt;/span&gt; sha256sum -c - &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; tar -xJf &lt;span class="s2"&gt;&amp;quot;node-v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;-linux-x64.tar.xz&amp;quot;&lt;/span&gt; -C /usr/local --strip-components&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm &lt;span class="s2"&gt;&amp;quot;node-v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;-linux-x64.tar.xz&amp;quot;&lt;/span&gt; SHASUMS256.txt.asc SHASUMS256.txt &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ln -s /usr/local/bin/node /usr/local/bin/nodejs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里先定义了环境变量 &lt;code&gt;NODE_VERSION&lt;/code&gt;，其后的 &lt;code&gt;RUN&lt;/code&gt; 这层里，多次使用 &lt;code&gt;$NODE_VERSION&lt;/code&gt; 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 &lt;code&gt;7.2.0&lt;/code&gt; 即可，&lt;code&gt;Dockerfile&lt;/code&gt; 构建维护变得更轻松了。&lt;/p&gt;
&lt;p&gt;下列指令可以支持环境变量展开： &lt;code&gt;ADD&lt;/code&gt;、&lt;code&gt;COPY&lt;/code&gt;、&lt;code&gt;ENV&lt;/code&gt;、&lt;code&gt;EXPOSE&lt;/code&gt;、&lt;code&gt;FROM&lt;/code&gt;、&lt;code&gt;LABEL&lt;/code&gt;、&lt;code&gt;USER&lt;/code&gt;、&lt;code&gt;WORKDIR&lt;/code&gt;、&lt;code&gt;VOLUME&lt;/code&gt;、&lt;code&gt;STOPSIGNAL&lt;/code&gt;、&lt;code&gt;ONBUILD&lt;/code&gt;、&lt;code&gt;RUN&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，可以让一份 &lt;code&gt;Dockerfile&lt;/code&gt; 制作更多的镜像，只需使用不同的环境变量即可。&lt;/p&gt;
&lt;h3&gt;VOLUME 定义匿名卷&lt;/h3&gt;
&lt;p&gt;格式为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VOLUME ["&amp;lt;路径1&amp;gt;", "&amp;lt;路径2&amp;gt;"...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VOLUME &amp;lt;路径&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 &lt;code&gt;Dockerfile&lt;/code&gt; 中，可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;VOLUME&lt;/span&gt;&lt;span class="s"&gt; /data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的 &lt;code&gt;/data&lt;/code&gt; 目录就会在运行时自动挂载为匿名卷，任何向 &lt;code&gt;/data&lt;/code&gt; 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -d -v mydata:/data xxxx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这行命令中，就使用了 &lt;code&gt;mydata&lt;/code&gt; 这个命名卷挂载到了 &lt;code&gt;/data&lt;/code&gt; 这个位置，替代了 &lt;code&gt;Dockerfile&lt;/code&gt; 中定义的匿名卷的挂载配置。&lt;/p&gt;
&lt;h3&gt;EXPOSE 暴露端口&lt;/h3&gt;
&lt;p&gt;格式为 &lt;code&gt;EXPOSE &amp;lt;端口1&amp;gt; [&amp;lt;端口2&amp;gt;...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EXPOSE&lt;/code&gt; 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 &lt;code&gt;docker run -P&lt;/code&gt; 时，会自动随机映射 &lt;code&gt;EXPOSE&lt;/code&gt; 的端口。&lt;/p&gt;
&lt;p&gt;要将 &lt;code&gt;EXPOSE&lt;/code&gt; 和在运行时使用 &lt;code&gt;-p &amp;lt;宿主端口&amp;gt;:&amp;lt;容器端口&amp;gt;&lt;/code&gt; 区分开来。&lt;code&gt;-p&lt;/code&gt;，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 &lt;code&gt;EXPOSE&lt;/code&gt; 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。&lt;/p&gt;
&lt;h3&gt;WORKDIR 指定工作目录&lt;/h3&gt;
&lt;p&gt;格式为 &lt;code&gt;WORKDIR &amp;lt;工作目录路径&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;WORKDIR&lt;/code&gt; 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，&lt;code&gt;WORKDIR&lt;/code&gt; 会帮你建立目录。&lt;/p&gt;
&lt;p&gt;之前提到一些初学者常犯的错误是把 &lt;code&gt;Dockerfile&lt;/code&gt; 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; /app
&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &amp;gt; world.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将这个 &lt;code&gt;Dockerfile&lt;/code&gt; 进行构建镜像运行后，会发现找不到 &lt;code&gt;/app/world.txt&lt;/code&gt; 文件，或者其内容不是 &lt;code&gt;hello&lt;/code&gt;。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 &lt;code&gt;Dockerfile&lt;/code&gt; 中，这两行 &lt;code&gt;RUN&lt;/code&gt; 命令的执行环境根本不同，是两个完全不同的容器。这就是对 &lt;code&gt;Dockerfile&lt;/code&gt; 构建分层存储的概念不了解所导致的错误。&lt;/p&gt;
&lt;p&gt;之前说过每一个 &lt;code&gt;RUN&lt;/code&gt; 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 &lt;code&gt;RUN cd /app&lt;/code&gt; 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。&lt;/p&gt;
&lt;p&gt;因此如果需要改变以后各层的工作目录的位置，那么应该使用 &lt;code&gt;WORKDIR&lt;/code&gt; 指令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /app&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &amp;gt; world.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你的 &lt;code&gt;WORKDIR&lt;/code&gt; 指令使用的相对路径，那么所切换的路径与之前的 &lt;code&gt;WORKDIR&lt;/code&gt; 有关：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /a&lt;/span&gt;
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; b&lt;/span&gt;
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; c&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; pwd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;pwd&lt;/code&gt; 输出的结果为 &lt;code&gt;/a/b/c&lt;/code&gt;。&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj32/</guid><pubDate>Sun, 20 Sep 2020 13:30:00 +0806</pubDate></item><item><title>Docker Compose笔记</title><link>/Xuxx_Blogs/archives/bj33/</link><description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 &lt;code&gt;OpenStack&lt;/code&gt; 中的 &lt;code&gt;Heat&lt;/code&gt; 十分类似。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。&lt;/p&gt;
&lt;p&gt;通过第一部分中的介绍，知道使用一个 &lt;code&gt;Dockerfile&lt;/code&gt; 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 恰好满足了这样的需求。它允许用户通过一个单独的 &lt;code&gt;docker-compose.yml&lt;/code&gt; 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 中有两个重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。&lt;/li&gt;
&lt;li&gt;项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件中定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 &lt;code&gt;Compose&lt;/code&gt; 来进行编排管理。&lt;/p&gt;
&lt;h2&gt;安装与卸载&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 支持 Linux、macOS、Windows 10 三大平台。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 可以通过 Python 的包管理工具 &lt;code&gt;pip&lt;/code&gt; 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Docker Desktop for Mac/Windows&lt;/code&gt; 自带 &lt;code&gt;docker-compose&lt;/code&gt; 二进制文件，安装 Docker 之后可以直接使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-compose --versiondocker-compose version 1.25.5, build 4667896b&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Linux 系统请使用以下介绍的方法安装。&lt;/p&gt;
&lt;h3&gt;二进制包安装&lt;/h3&gt;
&lt;p&gt;在 Linux 上的也安装十分简单，从 &lt;a href="https://github.com/docker/compose/releases"&gt;官方 GitHub Release&lt;/a&gt; 处直接下载编译好的二进制文件即可。&lt;/p&gt;
&lt;p&gt;例如，在 Linux 64 位系统上直接下载对应的二进制包。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-&lt;span class="sb"&gt;`&lt;/span&gt;uname -s&lt;span class="sb"&gt;`&lt;/span&gt;-&lt;span class="sb"&gt;`&lt;/span&gt;uname -m&lt;span class="sb"&gt;`&lt;/span&gt; &amp;gt; /usr/local/bin/docker-compose

$ sudo chmod +x /usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;PIP 安装&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;注：&lt;/em&gt; &lt;code&gt;x86_64&lt;/code&gt; 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 &lt;code&gt;ARM&lt;/code&gt; (例如，树莓派)，再使用 &lt;code&gt;pip&lt;/code&gt; 安装。&lt;/p&gt;
&lt;p&gt;这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。&lt;/p&gt;
&lt;p&gt;执行安装命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo pip install -U docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到类似如下输出，说明安装成功。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Collecting docker-compose
  Downloading docker-compose-1.25.5.tar.gz &lt;span class="o"&gt;(&lt;/span&gt;149kB&lt;span class="o"&gt;)&lt;/span&gt;: 149kB downloaded
...
Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;bash 补全命令&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &amp;gt; /etc/bash_completion.d/docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;卸载&lt;/h3&gt;
&lt;p&gt;如果是二进制包方式安装的，删除二进制文件即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo rm /usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是通过 &lt;code&gt;pip&lt;/code&gt; 安装的，则执行如下命令即可删除。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo pip uninstall docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;h3&gt;术语&lt;/h3&gt;
&lt;p&gt;首先介绍几个术语。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务 (&lt;code&gt;service&lt;/code&gt;)：一个应用容器，实际上可以运行多个相同镜像的实例。&lt;/li&gt;
&lt;li&gt;项目 (&lt;code&gt;project&lt;/code&gt;)：由一组关联的应用容器组成的一个完整业务单元。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，一个项目可以由多个服务（容器）关联而成，&lt;code&gt;Compose&lt;/code&gt; 面向项目进行管理。&lt;/p&gt;
&lt;h3&gt;场景&lt;/h3&gt;
&lt;p&gt;最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。&lt;/p&gt;
&lt;p&gt;下面用 &lt;code&gt;Python&lt;/code&gt; 来建立一个能够记录页面访问次数的 web 网站。&lt;/p&gt;
&lt;h4&gt;web 应用&lt;/h4&gt;
&lt;p&gt;新建文件夹，在该目录中编写 &lt;code&gt;app.py&lt;/code&gt; 文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;flask&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;redis&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Redis&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;redis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Redis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;redis&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;6379&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;incr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hits&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello World! 该页面已被访问 &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s1"&gt; 次。&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0.0.0.0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Dockerfile&lt;/h4&gt;
&lt;p&gt;编写 &lt;code&gt;Dockerfile&lt;/code&gt; 文件，内容为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;python:3.6-alpine&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt; . /code
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /code&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; pip install redis flask
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;app.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;docker-compose.yml&lt;/h4&gt;
&lt;p&gt;编写 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件，这个是 Compose 使用的主模板文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;web&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;build&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;.&lt;/span&gt;
    &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
     &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;5000:5000&amp;quot;&lt;/span&gt;
  &lt;span class="nt"&gt;redis&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;redis:alpine&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;运行 compose 项目&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose up
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时访问本地 &lt;code&gt;5000&lt;/code&gt; 端口，每次刷新页面，计数就会加 1。&lt;/p&gt;
&lt;h2&gt;命令说明&lt;/h2&gt;
&lt;h3&gt;命令对象与格式&lt;/h3&gt;
&lt;p&gt;对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;docker-compose [COMMAND] --help&lt;/code&gt; 或者 &lt;code&gt;docker-compose help [COMMAND]&lt;/code&gt; 可以查看具体某个命令的使用格式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-compose&lt;/code&gt; 命令的基本的使用格式是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker-compose &lt;span class="o"&gt;[&lt;/span&gt;-f&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;arg&amp;gt;...&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;COMMAND&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;ARGS...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;命令选项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f, --file FILE&lt;/code&gt; 指定使用的 Compose 模板文件，默认为 &lt;code&gt;docker-compose.yml&lt;/code&gt;，可以多次指定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p, --project-name NAME&lt;/code&gt; 指定项目名称，默认将使用所在目录名称作为项目名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--x-networking&lt;/code&gt; 使用 Docker 的可拔插网络后端特性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--x-network-driver DRIVER&lt;/code&gt; 指定网络后端的驱动，默认为 &lt;code&gt;bridge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--verbose&lt;/code&gt; 输出更多调试信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v, --version&lt;/code&gt; 打印版本并退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;命令使用说明&lt;/h3&gt;
&lt;h4&gt;build&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose build [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;构建（重新构建）项目中的服务容器。&lt;/p&gt;
&lt;p&gt;服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。&lt;/p&gt;
&lt;p&gt;可以随时在项目目录下运行 &lt;code&gt;docker-compose build&lt;/code&gt; 来重新构建服务。&lt;/p&gt;
&lt;p&gt;选项包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--force-rm&lt;/code&gt; 删除构建过程中的临时容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-cache&lt;/code&gt; 构建镜像过程中不使用 cache（这将加长构建过程）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--pull&lt;/code&gt; 始终尝试通过 pull 来获取更新版本的镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;config&lt;/h4&gt;
&lt;p&gt;验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。&lt;/p&gt;
&lt;h4&gt;down&lt;/h4&gt;
&lt;p&gt;此命令将会停止 &lt;code&gt;up&lt;/code&gt; 命令所启动的容器，并移除网络&lt;/p&gt;
&lt;h4&gt;exec&lt;/h4&gt;
&lt;p&gt;进入指定的容器。&lt;/p&gt;
&lt;h4&gt;help&lt;/h4&gt;
&lt;p&gt;获得一个命令的帮助。&lt;/p&gt;
&lt;h4&gt;images&lt;/h4&gt;
&lt;p&gt;列出 Compose 文件中包含的镜像。&lt;/p&gt;
&lt;h4&gt;kill&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose kill [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过发送 &lt;code&gt;SIGKILL(终止进程)&lt;/code&gt; 信号来强制停止服务容器。&lt;/p&gt;
&lt;p&gt;支持通过 &lt;code&gt;-s&lt;/code&gt; 参数来指定发送的信号，例如通过如下指令发送 &lt;code&gt;SIGINT&lt;/code&gt; 信号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-compose kill -s SIGINT&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;logs&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose logs [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 &lt;code&gt;--no-color&lt;/code&gt; 来关闭颜色。&lt;/p&gt;
&lt;p&gt;该命令在调试问题的时候十分有用。&lt;/p&gt;
&lt;h4&gt;pause&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose pause [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;暂停一个服务容器。&lt;/p&gt;
&lt;h4&gt;port&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose port [options] SERVICE PRIVATE_PORT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;打印某个容器端口所映射的公共端口。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--protocol=proto&lt;/code&gt; 指定端口协议，tcp（默认值）或者 udp。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--index=index&lt;/code&gt; 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ps&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose ps [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;列出项目中目前的所有容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-q&lt;/code&gt; 只打印容器的 ID 信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;pull&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose pull [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;拉取服务依赖的镜像。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--ignore-pull-failures&lt;/code&gt; 忽略拉取镜像过程中的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;push&lt;/h4&gt;
&lt;p&gt;推送服务依赖的镜像到 Docker 镜像仓库。&lt;/p&gt;
&lt;h4&gt;restart&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose restart [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;重启项目中的服务。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 指定重启前停止容器的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;rm&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose rm [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;删除所有（停止状态的）服务容器。推荐先执行 &lt;code&gt;docker-compose stop&lt;/code&gt; 命令来停止容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f, --force&lt;/code&gt; 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 删除容器所挂载的数据卷。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;run&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在指定服务上执行一个命令。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose run ubuntu ping docker.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将会启动一个 ubuntu 服务容器，并执行 &lt;code&gt;ping docker.com&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。&lt;/p&gt;
&lt;p&gt;该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。&lt;/p&gt;
&lt;p&gt;两个不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定命令将会覆盖原有的自动运行命令；&lt;/li&gt;
&lt;li&gt;不会自动创建端口，以避免冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不希望自动启动关联的容器，可以使用 &lt;code&gt;--no-deps&lt;/code&gt; 选项，例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose run --no-deps web python manage.py shell
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将不会启动 web 容器所关联的其它容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 后台运行容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name NAME&lt;/code&gt; 为容器指定一个名字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--entrypoint CMD&lt;/code&gt; 覆盖默认的容器启动指令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e KEY=VAL&lt;/code&gt; 设置环境变量值，可多次使用选项来设置多个环境变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u, --user=""&lt;/code&gt; 指定运行容器的用户名或者 uid。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-deps&lt;/code&gt; 不自动启动关联的服务容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--rm&lt;/code&gt; 运行命令后自动删除容器，&lt;code&gt;d&lt;/code&gt; 模式下将忽略。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p, --publish=[]&lt;/code&gt; 映射容器端口到本地主机。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--service-ports&lt;/code&gt; 配置服务端口并映射到本地主机。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-T&lt;/code&gt; 不分配伪 tty，意味着依赖 tty 的指令将无法运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;scale&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose scale [options] [SERVICE=NUM...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;设置指定服务运行的容器个数。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;service=num&lt;/code&gt; 的参数来设置数量。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose scale &lt;span class="nv"&gt;web&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;db&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。&lt;/p&gt;
&lt;p&gt;一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;start&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose start [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;启动已经存在的服务容器。&lt;/p&gt;
&lt;h4&gt;stop&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose stop [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;停止已经处于运行状态的容器，但不删除它。通过 &lt;code&gt;docker-compose start&lt;/code&gt; 可以再次启动这些容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;top&lt;/h4&gt;
&lt;p&gt;查看各个服务容器内运行的进程。&lt;/p&gt;
&lt;h4&gt;unpause&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose unpause [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;恢复处于暂停状态中的服务。&lt;/p&gt;
&lt;h4&gt;up&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose up [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。&lt;/p&gt;
&lt;p&gt;链接的服务都将会被自动启动，除非已经处于运行状态。&lt;/p&gt;
&lt;p&gt;可以说，大部分时候都可以直接通过该命令来启动一个项目。&lt;/p&gt;
&lt;p&gt;默认情况，&lt;code&gt;docker-compose up&lt;/code&gt; 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。&lt;/p&gt;
&lt;p&gt;当通过 &lt;code&gt;Ctrl-C&lt;/code&gt; 停止命令时，所有容器将会停止。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;docker-compose up -d&lt;/code&gt;，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。&lt;/p&gt;
&lt;p&gt;默认情况，如果服务容器已经存在，&lt;code&gt;docker-compose up&lt;/code&gt; 将会尝试停止容器，然后重新创建（保持使用 &lt;code&gt;volumes-from&lt;/code&gt; 挂载的卷），以保证新启动的服务匹配 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 &lt;code&gt;docker-compose up --no-recreate&lt;/code&gt;。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 &lt;code&gt;docker-compose up --no-deps -d &amp;lt;SERVICE_NAME&amp;gt;&lt;/code&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 在后台运行服务容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-color&lt;/code&gt; 不使用颜色来区分不同的服务的控制台输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-deps&lt;/code&gt; 不启动服务所链接的容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--force-recreate&lt;/code&gt; 强制重新创建容器，不能与 &lt;code&gt;--no-recreate&lt;/code&gt; 同时使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-recreate&lt;/code&gt; 如果容器已经存在了，则不重新创建，不能与 &lt;code&gt;--force-recreate&lt;/code&gt; 同时使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-build&lt;/code&gt; 不自动构建缺失的服务镜像。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;version&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose version&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;打印版本信息。&lt;/p&gt;
&lt;h2&gt;Compose 模板文件&lt;/h2&gt;
&lt;p&gt;模板文件是使用 &lt;code&gt;Compose&lt;/code&gt; 的核心，涉及到的指令关键字也比较多。但这里面大部分指令跟 &lt;code&gt;docker run&lt;/code&gt; 相关参数的含义都是类似的。&lt;/p&gt;
&lt;p&gt;默认的模板文件名称为 &lt;code&gt;docker-compose.yml&lt;/code&gt;，格式为 YAML 格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3"

services:
  webapp:
    image: examples/web
    ports:
      - "80:80"
    volumes:
      - "/data"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意每个服务都必须通过 &lt;code&gt;image&lt;/code&gt; 指令指定镜像或 &lt;code&gt;build&lt;/code&gt; 指令（需要 Dockerfile）等来自动构建生成镜像。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;build&lt;/code&gt; 指令，在 &lt;code&gt;Dockerfile&lt;/code&gt; 中设置的选项(例如：&lt;code&gt;CMD&lt;/code&gt;, &lt;code&gt;EXPOSE&lt;/code&gt;, &lt;code&gt;VOLUME&lt;/code&gt;, &lt;code&gt;ENV&lt;/code&gt; 等) 将会自动被获取，无需在 &lt;code&gt;docker-compose.yml&lt;/code&gt; 中重复设置。&lt;/p&gt;
&lt;p&gt;下面分别介绍各个指令的用法。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;build&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定 &lt;code&gt;Dockerfile&lt;/code&gt; 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 &lt;code&gt;Compose&lt;/code&gt; 将会利用它自动构建这个镜像，然后使用这个镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: '3'
services:
  webapp:
    build: ./dir&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以使用 &lt;code&gt;context&lt;/code&gt; 指令指定 &lt;code&gt;Dockerfile&lt;/code&gt; 所在文件夹的路径。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;dockerfile&lt;/code&gt; 指令指定 &lt;code&gt;Dockerfile&lt;/code&gt; 文件名。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;arg&lt;/code&gt; 指令指定构建镜像时的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: '3'
services:
  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;cache_from&lt;/code&gt; 指定构建镜像的缓存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build:
  context: .
  cache_from:
    - alpine:latest
    - corp/web_app:3.14&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;cap_add, cap_drop&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定容器的内核能力（capacity）分配。&lt;/p&gt;
&lt;p&gt;例如，让容器拥有所有能力可以指定为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cap_add:
  - ALL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去掉 NET_ADMIN 能力可以指定为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cap_drop:
  - NET_ADMIN&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;command&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;覆盖容器启动后默认执行的命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command: echo "hello world"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;cgroup_parent&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定父 &lt;code&gt;cgroup&lt;/code&gt; 组，意味着将继承该组的资源限制。&lt;/p&gt;
&lt;p&gt;例如，创建了一个 cgroup 组名称为 &lt;code&gt;cgroups_1&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cgroup_parent: cgroups_1&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;container_name&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定容器名称。默认将会使用 &lt;code&gt;项目名称_服务名称_序号&lt;/code&gt; 这样的格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;container_name: docker-web-container&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;code&gt;devices&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定设备映射关系。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;devices:
  - "/dev/ttyUSB1:/dev/ttyUSB0"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;depends_on&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;解决容器的依赖、启动先后的问题。以下例子中会先启动 &lt;code&gt;redis&lt;/code&gt; &lt;code&gt;db&lt;/code&gt; 再启动 &lt;code&gt;web&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: '3'

services:
  web:
    build: .
    depends_on:
      - db
      - redis

  redis:
    image: redis

  db:
    image: postgres&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;注意：&lt;code&gt;web&lt;/code&gt; 服务不会等待 &lt;code&gt;redis&lt;/code&gt; &lt;code&gt;db&lt;/code&gt; 「完全启动」之后才启动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;code&gt;dns&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;自定义 &lt;code&gt;DNS&lt;/code&gt; 服务器。可以是一个值，也可以是一个列表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dns: 8.8.8.8

dns:
  - 8.8.8.8
  - 114.114.114.114&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;dns_search&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;配置 &lt;code&gt;DNS&lt;/code&gt; 搜索域。可以是一个值，也可以是一个列表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dns_search: example.com

dns_search:
  - domain1.example.com
  - domain2.example.com&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;tmpfs&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;挂载一个 tmpfs 文件系统到容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmpfs: /run
tmpfs:
  - /run
  - /tmp&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;env_file&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;从文件中获取环境变量，可以为单独的文件路径或列表。&lt;/p&gt;
&lt;p&gt;如果通过 &lt;code&gt;docker-compose -f FILE&lt;/code&gt; 方式来指定 Compose 模板文件，则 &lt;code&gt;env_file&lt;/code&gt; 中变量的路径会基于模板文件路径。&lt;/p&gt;
&lt;p&gt;如果有变量名称与 &lt;code&gt;environment&lt;/code&gt; 指令冲突，则按照惯例，以后者为准。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;环境变量文件中每一行必须符合格式，支持 &lt;code&gt;#&lt;/code&gt; 开头的注释行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# common.env: Set development environment
PROG_ENV=development&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;environment&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;设置环境变量。你可以使用数组或字典两种格式。&lt;/p&gt;
&lt;p&gt;只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;environment:
  RACK_ENV: development
  SESSION_SECRET:

environment:
  - RACK_ENV=development
  - SESSION_SECRET&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果变量名称或者值中用到 &lt;code&gt;true|false，yes|no&lt;/code&gt; 等表达 &lt;a href="https://yaml.org/type/bool.html"&gt;布尔&lt;/a&gt; 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;expose&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;暴露端口，但不映射到宿主机，只被连接的服务访问。&lt;/p&gt;
&lt;p&gt;仅可以指定内部端口为参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expose:
 - "3000"
 - "8000"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;external_links&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;&lt;p&gt;注意：不建议使用该指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链接到 &lt;code&gt;docker-compose.yml&lt;/code&gt; 外部的容器，甚至并非 &lt;code&gt;Compose&lt;/code&gt; 管理的外部容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;external_links:
 - redis_1
 - project_db_1:mysql
 - project_db_1:postgresql&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;extra_hosts&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;类似 Docker 中的 &lt;code&gt;--add-host&lt;/code&gt; 参数，指定额外的 host 名称映射信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extra_hosts:
 - "googledns:8.8.8.8"
 - "dockerhub:52.1.157.61"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会在启动后的服务容器中 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件中添加如下两条条目。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8.8.8.8 googledns
52.1.157.61 dockerhub&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;healthcheck&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;通过命令检查容器是否健康运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost"]
  interval: 1m30s
  timeout: 10s
  retries: 3&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;image&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定为镜像名称或镜像 ID。如果镜像在本地不存在，&lt;code&gt;Compose&lt;/code&gt; 将会尝试拉取这个镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;image: ubuntu
image: orchardup/postgresql
image: a4bc65fd&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;labels:
  com.startupteam.description: "webapp for a startup team"
  com.startupteam.department: "devops department"
  com.startupteam.release: "rc3 for v1.0"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;links&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;&lt;p&gt;注意：不推荐使用该指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;配置日志选项。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logging:
  driver: syslog
  options:
    syslog-address: "tcp://192.168.0.42:123"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前支持三种日志驱动类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;driver: "json-file"
driver: "syslog"
driver: "none"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;options&lt;/code&gt; 配置日志驱动的相关参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;options:
  max-size: "200k"
  max-file: "10"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;network_mode&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;设置网络模式。使用和 &lt;code&gt;docker run&lt;/code&gt; 的 &lt;code&gt;--network&lt;/code&gt; 参数一样的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;network_mode: "bridge"
network_mode: "host"
network_mode: "none"
network_mode: "service:[service name]"
network_mode: "container:[container name/id]"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;networks&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;配置容器连接的网络。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3"
services:

  some-service:
    networks:
     - some-network
     - other-network

networks:
  some-network:
  other-network:&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;pid&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pid: "host"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;ports&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;暴露端口信息。&lt;/p&gt;
&lt;p&gt;使用宿主端口：容器端口 &lt;code&gt;(HOST:CONTAINER)&lt;/code&gt; 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ports:
 - "3000"
 - "8000:8000"
 - "49100:22"
 - "127.0.0.1:8001:8001"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意：当使用&lt;/em&gt; &lt;em&gt;HOST:CONTAINER&lt;/em&gt; &lt;em&gt;格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为&lt;/em&gt; &lt;em&gt;YAML&lt;/em&gt; &lt;em&gt;会自动解析&lt;/em&gt; &lt;em&gt;xx:yy&lt;/em&gt; &lt;em&gt;这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;存储敏感数据，例如 &lt;code&gt;mysql&lt;/code&gt; 服务密码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3.1"
services:

mysql:
  image: mysql
  environment:
    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
  secrets:
    - db_root_password
    - my_other_secret

secrets:
  my_secret:
    file: ./my_secret.txt
  my_other_secret:
    external: true&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;security_opt&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;security_opt:
    - label:user:USER
    - label:role:ROLE&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;stop_signal&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stop_signal: SIGUSR1&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;sysctls&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;配置容器内核参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sysctls:
  net.core.somaxconn: 1024
  net.ipv4.tcp_syncookies: 0

sysctls:
  - net.core.somaxconn=1024
  - net.ipv4.tcp_syncookies=0&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;ulimits&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定容器的 ulimits 限制值。&lt;/p&gt;
&lt;p&gt;例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ulimits:
    nproc: 65535
    nofile:
      soft: 20000
      hard: 40000&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;volumes&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;数据卷所挂载路径设置。可以设置为宿主机路径(&lt;code&gt;HOST:CONTAINER&lt;/code&gt;)或者数据卷名称(&lt;code&gt;VOLUME:CONTAINER&lt;/code&gt;)，并且可以设置访问模式 （&lt;code&gt;HOST:CONTAINER:ro&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;该指令中路径支持相对路径。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;volumes:
 - /var/lib/mysql
 - cache/:/tmp/cache
 - ~/configs:/etc/configs/:ro&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果路径为数据卷名称，必须在文件中配置数据卷。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3"

services:
  my_src:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;其它指令&lt;/h4&gt;
&lt;p&gt;此外，还有包括 &lt;code&gt;domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir&lt;/code&gt; 等指令，基本跟 &lt;code&gt;docker run&lt;/code&gt; 中对应参数的功能一致。&lt;/p&gt;
&lt;p&gt;指定服务容器启动后执行的入口文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;entrypoint: /code/entrypoint.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定容器中运行应用的用户名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user: nginx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定容器中工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;working_dir: /code&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定容器中搜索域名、主机名、mac 地址等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;domainname: your_website.comhostname: testmac_address: 08-00-27-00-0C-0A&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;允许容器中运行一些特权命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;privileged: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 &lt;code&gt;always&lt;/code&gt; 或者 &lt;code&gt;unless-stopped&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;restart: always&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;read_only: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开标准输入，可以接受外部输入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stdin_open: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模拟一个伪终端。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tty: true&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;读取变量&lt;/h4&gt;
&lt;p&gt;Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 &lt;code&gt;.env&lt;/code&gt; 文件中的变量。&lt;/p&gt;
&lt;p&gt;例如，下面的 Compose 文件将从运行它的环境中读取变量 &lt;code&gt;${MONGO_VERSION}&lt;/code&gt; 的值，并写入执行的指令中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3"
services:

db:
  image: "mongo:${MONGO_VERSION}"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果执行 &lt;code&gt;MONGO_VERSION=3.2 docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:3.2&lt;/code&gt; 镜像的容器；如果执行 &lt;code&gt;MONGO_VERSION=2.8 docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:2.8&lt;/code&gt; 镜像的容器。&lt;/p&gt;
&lt;p&gt;若当前目录存在 &lt;code&gt;.env&lt;/code&gt; 文件，执行 &lt;code&gt;docker-compose&lt;/code&gt; 命令时将从该文件中读取变量。&lt;/p&gt;
&lt;p&gt;在当前目录新建 &lt;code&gt;.env&lt;/code&gt; 文件并写入以下内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 支持 # 号注释MONGO_VERSION=3.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行 &lt;code&gt;docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:3.6&lt;/code&gt; 镜像的容器。&lt;/p&gt;
&lt;h2&gt;Docker Compose部署应用程序&lt;/h2&gt;
&lt;h3&gt;部署Tomcat&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3.1&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="nt"&gt;tomcat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
        &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tomcat&lt;/span&gt;
        &lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tomcat&lt;/span&gt;
        &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;8080:8080&lt;/span&gt;
        &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./webapps:/usr/local/tomcat/webapps&lt;/span&gt;
        &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="c1"&gt;#时区&lt;/span&gt;
          &lt;span class="nt"&gt;TZ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Asia/Shanghai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;部署MySQL_1&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3.1&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="nt"&gt;db&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mysql&lt;/span&gt;
        &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
        &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nt"&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;123456&lt;/span&gt;
        &lt;span class="nt"&gt;command&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;#默认的身份验证插件&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--default-authentication-plugin=mysql_native_password&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;#字符集&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--character-set-server=utf8mb4&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;#字符集编码规则&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--collation-server=utf8mb4_general_ci&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;#数据行更新时，timestamp类型字段不更新为当前时间&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--explicit_defaults_for_timestamp=true&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;#表名小写,不区分大小写&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--lower_case_table_names=1&lt;/span&gt;
        &lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tomcat&lt;/span&gt;
        &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;3306:3306&lt;/span&gt;
        &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./data:/var/lib/mysql/data&lt;/span&gt;
    &lt;span class="c1"&gt;#MySQL 的Web客户端&lt;/span&gt;
    &lt;span class="nt"&gt;adminer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;adminer&lt;/span&gt;
        &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
        &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;8080:8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;部署MySQL_2&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;3.1&amp;quot;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
 &lt;span class="nt"&gt;db&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
  &lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mysql&lt;/span&gt;
  &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mysql&lt;/span&gt;
  &lt;span class="nt"&gt;command&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
   &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--lower_case_table_names=1&lt;/span&gt;
   &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--character-set-server=utf8mb4&lt;/span&gt;
   &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--collation-server=utf8mb4_unicode_ci&lt;/span&gt;
   &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--explicit_defaults_for_timestamp=true&lt;/span&gt;
  &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="nt"&gt;TZ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Asia/Shanghai&lt;/span&gt;
   &lt;span class="nt"&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root@123456&lt;/span&gt;
  &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;3306:3306&lt;/span&gt;
  &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./mysql/data:/var/lib/mysql&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./mysql/config:/etc/mysql/conf.d&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./mysql/log:/var/log/mysql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;部署RabbitMQ&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;rabbitmq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;rabbitmq:3.8.3-management&lt;/span&gt;
    &lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;rabbitmq&lt;/span&gt;
    &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
    &lt;span class="nt"&gt;hostname&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;myRabbitmq&lt;/span&gt;
    &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;15672:15672&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;5672:5672&lt;/span&gt;
    &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./data:/var/lib/rabbitmq&lt;/span&gt;
    &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;RABBITMQ_DEFAULT_USER=root&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;RABBITMQ_DEFAULT_PASS=root&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;RABBITMQ_DEFAULT_USER&lt;/code&gt;  和  &lt;code&gt;RABBITMQ_DEFAULT_PASS&lt;/code&gt; 用来设置超级管理员的账号和密码，如果不设置，默认都是 &lt;code&gt;guest&lt;/code&gt; 。&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj33/</guid><pubDate>Mon, 21 Sep 2020 01:10:00 +0806</pubDate></item><item><title>Docker Compose部署GitLab</title><link>/Xuxx_Blogs/archives/bj34/</link><description>&lt;h2&gt;什么是GitLab&lt;/h2&gt;
&lt;p&gt;GitLab是利用 Ruby on Rails 的一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。它拥有与 Github 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。&lt;/p&gt;
&lt;h2&gt;部署GitLab&lt;/h2&gt;
&lt;p&gt;使用Docker来安装和运行GitLab中文版，&lt;code&gt;docker-compose.yml&lt;/code&gt;配置如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;web&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;twang2218/gitlab-ce-zh&amp;#39;&lt;/span&gt;
        &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
        &lt;span class="nt"&gt;hostname&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;192.168.123.128&amp;#39;&lt;/span&gt;
        &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nt"&gt;TZ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Asia/Shanghai&amp;#39;&lt;/span&gt;
            &lt;span class="nt"&gt;GITLAB_OMNIBUS_CONFIG&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p p-Indicator"&gt;|&lt;/span&gt;
                &lt;span class="no"&gt;external_url = &amp;#39;http://192.168.123.128&amp;#39;&lt;/span&gt;
                &lt;span class="no"&gt;gitlab_rails[&amp;#39;gitlab_shell_ssh_port&amp;#39;] = 2222&lt;/span&gt;
                &lt;span class="no"&gt;unicorn[&amp;#39;port&amp;#39;] = 8888&lt;/span&gt;
                &lt;span class="no"&gt;nginx[&amp;#39;listen_port&amp;#39;] = 80&lt;/span&gt;
        &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;80:80&amp;#39;&lt;/span&gt;
            &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;443:443&amp;#39;&lt;/span&gt;
            &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2222:22&amp;#39;&lt;/span&gt;
        &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./config:/etc/gitlab&lt;/span&gt;
        &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./data:/var/opt/gitlab&lt;/span&gt;
        &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./logs:/var/log/gitlab&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj34/</guid><pubDate>Tue, 22 Sep 2020 00:05:00 +0806</pubDate></item><item><title>动态规划算法</title><link>/Xuxx_Blogs/archives/bj35/</link><description>&lt;h2&gt;动态规划题目特点&lt;/h2&gt;
&lt;h3&gt;1.计数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有多少种方式走到右下角&lt;/li&gt;
&lt;li&gt;有多少种方法选出k个数使得和是Sum&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.求最大最小值&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从左上角走到右下角路径的最大数字和&lt;/li&gt;
&lt;li&gt;最长上升子序列长度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.求存在性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;取石子游戏，先手是否必胜&lt;/li&gt;
&lt;li&gt;能不能选出k个数使得和是Sum&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;例题1：&lt;/h4&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 114.90066225165563" data-width="1735" data-height="755"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/9247a23d97f2fece3a14fba5ceba4fdb.png" alt="例题" /&gt;&lt;figcaption&gt;例题&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;动态规划四大步骤&lt;/h2&gt;
&lt;h3&gt;1.确定状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;状态在动态规划中的作用属于定海神针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简单的说，解动态规划的时候需要开一个数组，数组的每个元素 f [i] 或者 f [i] [j] 代表什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似数学题中，X , Y , Z代表什么&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;确定状态需要两个意识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后一步&lt;/li&gt;
&lt;li&gt;子问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;例题1：最后一步的分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 115.37515375153751" data-width="1876" data-height="813"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/09d2f09a9ca3fba481809edea9ba2cfd.png" alt="例题1_最后一步的分析" /&gt;&lt;figcaption&gt;例题1_最后一步的分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 108.472553699284" data-width="1818" data-height="838"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/7a5cebdcdc21e3c784211bb6aa6ec8a1.png" alt="例题1_最后一步的分析" /&gt;&lt;figcaption&gt;例题1_最后一步的分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题：子问题的分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 93.01775147928994" data-width="1572" data-height="845"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/c89b14d980f68a3011c590960f5cd894.png" alt="例题1_子问题的分析" /&gt;&lt;figcaption&gt;例题1_子问题的分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 103.06818181818181" data-width="1814" data-height="880"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/92350c2ad5dbfc26f80018d7aee73f57.png" alt="例题1_子问题的分析" /&gt;&lt;figcaption&gt;例题1_子问题的分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;2.转移方程&lt;/h3&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 136.99248120300751" data-width="1822" data-height="665"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/fecb94428d307e8c46fcd2649f66f94d.png" alt="例题1_转移方程" /&gt;&lt;figcaption&gt;例题1_转移方程&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;3.初始条件和边界情况&lt;/h3&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 111.36680613668061" data-width="1597" data-height="717"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/cb6e8d4107e9b234e90d65b5b87e20a8.png" alt="例题1_初始条件和边界情况" /&gt;&lt;figcaption&gt;例题1_初始条件和边界情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;4.计算顺序&lt;/h3&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 159.8330241187384" data-width="1723" data-height="539"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/412f373811cb0c9adcb28d5736669e8e.png" alt="例题1_计算顺序" /&gt;&lt;figcaption&gt;例题1_计算顺序&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题1_小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 85.68840579710145" data-width="1419" data-height="828"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e5c27ea6caf5f396d76203ebddf34546.png" alt="例题1_小结" /&gt;&lt;figcaption&gt;例题1_小结&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;例题2：Unique Paths&lt;/h4&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 101.06263982102908" data-width="1807" data-height="894"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/55b4038aea8ab79caff5ff4cc9076838.png" alt="例题2" /&gt;&lt;figcaption&gt;例题2&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确定状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 101.34529147982063" data-width="1808" data-height="892"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/3297241f4ef73d1d69385a0d5ac1bcbd.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 123.85752688172043" data-width="1843" data-height="744"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/208b4691f33eef8274bf7d00fcd97cc1.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转移方程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 101.83129855715872" data-width="1835" data-height="901"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/8911f4e263f277a09774e4b517d9c343.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始条件和边界情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 97.75533108866442" data-width="1742" data-height="891"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e4149e997153756e993b24992e972f5d.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 108.70083432657925" data-width="1824" data-height="839"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/5b42931b6b5fd32d1518816ee1d6b8af.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj35/</guid><pubDate>Tue, 22 Sep 2020 03:10:00 +0806</pubDate></item><item><title>VMware 16安装CentOS 7 配置静态IP</title><link>/Xuxx_Blogs/archives/bj36/</link><description>&lt;h2&gt;一.安装VMware 16&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/zouhuu/article/details/86530787"&gt;安装VMware 16&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;二.创建虚拟机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建新的虚拟机 -&amp;gt; 自定义配置，下一步&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 93.97522522522523" data-width="1669" data-height="888"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/31609bb4fcc8c800490b576b117044b1.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择虚拟机硬件兼容性 -&amp;gt; 默认，下一步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装客户机操作系统 -&amp;gt; 稍后安装操作系统，下一步&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 57.621247113163975" data-width="499" data-height="433"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/f6e42c7054d8b36ab5791931fead5536.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择客户机操作系统 -&amp;gt; Linux+CentOS7 64 位，下一步&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 57.621247113163975" data-width="499" data-height="433"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/3919acacad647fe6aa949de6b408ef5a.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命名虚拟机 -&amp;gt; 按需配置，下一步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;处理器、内存配置 -&amp;gt; 按需分配，下一步&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;网络类型 -&amp;gt; 选择NAT类型，下一步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择I/O控制器类型、选择磁盘类型 -&amp;gt; 默认，下一步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;选择磁盘、指定磁盘容量 -&amp;gt; 创建新虚拟磁盘，按需分配磁盘大小，下一步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击完成&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;三.安装虚拟机操作系统&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;点击编辑虚拟机设置，选择ISO映像文件&lt;/li&gt;
&lt;li&gt;点击开启此虚拟机，进入安装步骤&lt;/li&gt;
&lt;li&gt;选择安装语言&lt;/li&gt;
&lt;li&gt;点击安装位置，点击选择刚才创建的20g的虚拟硬盘存储，最后点击完成。&lt;/li&gt;
&lt;li&gt;点击开始安装，Centos7正在安装中。&lt;/li&gt;
&lt;li&gt;设置ROOT账户密码，点击完成（提示：密码简单时需要多点），最后点击完成配置。&lt;/li&gt;
&lt;li&gt;重启，由于是安装Minimal版（最小安装），是命令行形式的，不是安装的桌面版的，只能在黑窗口输入命令操作。&lt;/li&gt;
&lt;li&gt;输入用户名/密码连接CentOS 7，输入密码不显示，所以要细心输入，以访出错。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;四.配置网络&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;确认虚拟机与主机的连接方式，编辑 -&amp;gt; 虚拟网络编辑器
 虚拟网络编辑器：去除了DHCP的勾选，然后配置子网和子网掩码。因为使用的子网掩码是 255.255.255.0 ，所以子网IP前两位要与本机的IP一致（win查看ip -&amp;gt; ipconfig ）,第三位随意（别和本机一样），第四位无脑填 0 就行。
 NAT设置：网关IP 前三位要和子网IP 一样，第四位随意就行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置Centos 7 静态IP 相关配置文件
 配置网卡配置文件：&lt;code&gt;vi /etc/sysconfig/network-scripts/ifcfg-ens33&lt;/code&gt;
 注意这儿的 IPASSR 不是虚拟网络编辑器的子网 IP！！！（吃过大亏(；´д｀)ゞ....）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#修改和添加的内容如下：&lt;/span&gt;
...
&lt;span class="nv"&gt;BOOTPROTO&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;static&amp;quot;&lt;/span&gt;
...
&lt;span class="nv"&gt;ONBOOT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;yes&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;#注意这儿的 IP 不是虚拟网络编辑器的子网 IP！！！&lt;/span&gt;
&lt;span class="c1"&gt;#就是虚拟网络编辑器中的 子网ip网段（前三位）+ 主机号 &lt;/span&gt;
&lt;span class="nv"&gt;IPADDR&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;192.168.123.128&amp;quot;&lt;/span&gt;
&lt;span class="c1"&gt;#子网掩码，也可换成：NETMASK=&amp;quot;255.255.255.0&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;PREFIX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;24&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;GATEWAY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;192.168.123.2&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;IPV6_PRIVACY&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;no&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;DNS1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt;.8.8.8
&lt;span class="nv"&gt;DNS2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt;.8.4.4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置域名解析配置文件：&lt;code&gt;vi /etc/resolv.conf&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#Generated by NetworkManager&lt;/span&gt;
nameserver &lt;span class="m"&gt;8&lt;/span&gt;.8.8.8
nameserver &lt;span class="m"&gt;8&lt;/span&gt;.8.4.4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以重启网络了, 命令：&lt;code&gt;systemctl restart network&lt;/code&gt;
补充 防火墙命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#关闭防火墙并设置开机不启动&lt;/span&gt;
&lt;span class="c1"&gt;#查看防火墙状态：&lt;/span&gt;
systemctl status firewalld.service
&lt;span class="c1"&gt;#关闭：&lt;/span&gt;
systemctl stop firewalld
&lt;span class="c1"&gt;#开启：&lt;/span&gt;
systemctl start firewalld
&lt;span class="c1"&gt;#开机自动关闭：&lt;/span&gt;
systemctl disable firewalld
&lt;span class="c1"&gt;#开机自动启动：&lt;/span&gt;
systemctl &lt;span class="nb"&gt;enable&lt;/span&gt; firewalld
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;同步修改主机的网络适配器ip
编辑vmnet8如下：
完整的配置已经结束。下载 ssh 客户端连接就好了。
FinalShell：&lt;a href="https://www.hostbuf.com/"&gt;https://www.hostbuf.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj36/</guid><pubDate>Mon, 23 Nov 2020 11:35:00 +0806</pubDate></item><item><title>MySql获取最近日期</title><link>/Xuxx_Blogs/archives/bj37/</link><description>&lt;h2&gt;一、 DATE_ADD()函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DATE_ADD()&lt;/strong&gt; 函数向日期添加指定的时间间隔。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;DATE_ADD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;date&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="k"&gt;INTERVAL&lt;/span&gt; &lt;span class="n"&gt;expr&lt;/span&gt; &lt;span class="k"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;date&lt;/em&gt; 参数是合法的日期表达式。&lt;em&gt;expr&lt;/em&gt; 参数是您希望添加的时间间隔。&lt;/p&gt;
&lt;p&gt;type 参数可以是下列值：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th style="text-align:left"&gt;Type 值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;MICROSECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;SECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;MINUTE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;HOUR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;DAY&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;WEEK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;MONTH&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;QUARTER&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;YEAR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;SECOND_MICROSECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;MINUTE_MICROSECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;MINUTE_SECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;HOUR_MICROSECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;HOUR_SECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;HOUR_MINUTE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;DAY_MICROSECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;DAY_SECOND&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;DAY_MINUTE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;DAY_HOUR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="text-align:left"&gt;YEAR_MONTH&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;实例&lt;/h3&gt;
&lt;p&gt;当天的日期&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;DATE_SUB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;curdate&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="k"&gt;INTERVAL&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;DAY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二、查询输出当天的日期&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="nf"&gt;DATE_SUB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;curdate&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="k"&gt;INTERVAL&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="k"&gt;DAY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="k"&gt;dual&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;我所用到的场景：&lt;/h2&gt;
&lt;p&gt;查询近10天某字段的新增情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; 
&lt;span class="n"&gt;字段名1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nf"&gt;COUNT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;AS&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; 
&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="n"&gt;表名&lt;/span&gt; 
&lt;span class="k"&gt;WHERE&lt;/span&gt; &lt;span class="n"&gt;（日期）字段名2&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;SELECT&lt;/span&gt; &lt;span class="nf"&gt;DATE_SUB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;curdate&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="k"&gt;INTERVAL&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="k"&gt;DAY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="k"&gt;dual&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="k"&gt;GROUP&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="n"&gt;字段名1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj37/</guid><pubDate>Tue, 01 Dec 2020 12:50:00 +0806</pubDate></item></channel></rss>