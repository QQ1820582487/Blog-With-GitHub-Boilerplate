<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Xuxx的个人博客。</title><link>/Xuxx_Blogs/</link><description>坚持有效行动，改变自然发生——致自己。</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>${static_prefix}logo.png</url><title>Xuxx的个人博客。</title><link>/Xuxx_Blogs/</link></image><language>zh-CN</language><lastBuildDate>Fri, 13 Nov 2020 02:57:26 +0806</lastBuildDate><pubDate>Fri, 13 Nov 2020 02:57:26 +0806</pubDate><item><title>Spring Boot发送邮件</title><link>/Xuxx_Blogs/archives/bj25/</link><description>&lt;h2&gt;1.基础知识&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;什么是SMTP？
 SMTP全称为Simple Mail Transfer Protocol（简单邮件传输协议），它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP认证要求必须提供账号和密码才能登陆服务器，其设计目的在于避免用户受到垃圾邮件的侵扰。&lt;/li&gt;
&lt;li&gt;什么是IMAP？
 IMAP全称为Internet Message Access Protocol（互联网邮件访问协议），IMAP允许从邮件服务器上获取邮件的信息、下载邮件等。IMAP与POP类似，都是一种邮件获取协议。&lt;/li&gt;
&lt;li&gt;什么是POP3？
 POP3全称为Post Office Protocol 3（邮局协议），POP3支持客户端远程管理服务器端的邮件。POP3常用于“离线”邮件处理，即允许客户端下载服务器邮件，然后服务器上的邮件将会被删除。目前很多POP3的邮件服务器只提供下载邮件功能，服务器本身并不删除邮件，这种属于改进版的POP3协议。&lt;/li&gt;
&lt;li&gt;IMAP和POP3协议有什么不同呢？
 两者最大的区别在于，IMAP允许双向通信，即在客户端的操作会反馈到服务器上，例如在客户端收取邮件、标记已读等操作，服务器会跟着同步这些操作。而对于POP协议虽然也允许客户端下载服务器邮件，但是在客户端的操作并不会同步到服务器上面的，例如在客户端收取或标记已读邮件，服务器不会同步这些操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;2.进阶知识&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是&lt;code&gt;JavaMailSender&lt;/code&gt;和&lt;code&gt;JavaMailSenderImpl&lt;/code&gt;？
&lt;code&gt;JavaMailSender&lt;/code&gt;和&lt;code&gt;JavaMailSenderImpl&lt;/code&gt; 是Spring官方提供的集成邮件服务的接口和实现类，以简单高效的设计著称，目前是Java后端发送邮件和集成邮件服务的主流工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如何通过&lt;code&gt;JavaMailSenderImpl&lt;/code&gt;发送邮件？
非常简单，直接在业务类注入&lt;code&gt;JavaMailSenderImpl&lt;/code&gt;并调用&lt;code&gt;send&lt;/code&gt;方法发送邮件。其中简单邮件可以通过&lt;code&gt;SimpleMailMessage&lt;/code&gt;来发送邮件，而复杂的邮件（例如添加附件）可以借助&lt;code&gt;MimeMessageHelper&lt;/code&gt;来构建&lt;code&gt;MimeMessage&lt;/code&gt;发送邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3.使用教程&lt;/h2&gt;
&lt;h3&gt;1.开启邮件服务&lt;/h3&gt;
&lt;p&gt;登陆使用的邮箱，在设置中打开并勾选POP3/SMTP/IMAP服务，然后会得到一个授权码，这个邮箱和授权码将用作登陆认证。&lt;/p&gt;
&lt;h3&gt;2.创建Spring Boot项目，引入依赖&lt;/h3&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-mail&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;spring.mail.host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;smtp.qq.com&lt;/span&gt;
&lt;span class="na"&gt;spring.mail.port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;465&lt;/span&gt;
&lt;span class="na"&gt;spring.mail.username&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;1820502...@qq.com&lt;/span&gt;
&lt;span class="c"&gt;#授权码&lt;/span&gt;
&lt;span class="na"&gt;spring.mail.password&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;***...&lt;/span&gt;
&lt;span class="na"&gt;spring.mail.default-encoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;UTF-8&lt;/span&gt;
&lt;span class="c"&gt;#加密连接&lt;/span&gt;
&lt;span class="na"&gt;spring.mail.properties.mail.smtp.socketFactory.class&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;javax.net.ssl.SSLSocketFactory&lt;/span&gt;
&lt;span class="c"&gt;#日志&lt;/span&gt;
&lt;span class="na"&gt;spring.mail.properties.mail.debug&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.发送邮件&lt;/h3&gt;
&lt;h4&gt;3.1 发送简单邮件&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@SpringBootTest&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MailApplicationTests&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Autowired&lt;/span&gt;
    &lt;span class="n"&gt;JavaMailSender&lt;/span&gt; &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;contextLoads&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//写邮件&lt;/span&gt;
        &lt;span class="n"&gt;SimpleMailMessage&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;SimpleMailMessage&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setSubject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试邮件-主题&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试邮件-内容：Hello Word&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setFrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1820502...@qq.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setSentDate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1913312...@qq.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;//message.setCc();//抄送&lt;/span&gt;
        &lt;span class="c1"&gt;//message.setBcc();//密抄&lt;/span&gt;

        &lt;span class="c1"&gt;//发送邮件&lt;/span&gt;
        &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 发送带附件的邮件&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@SpringBootTest&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MailApplicationTests&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Autowired&lt;/span&gt;
    &lt;span class="n"&gt;JavaMailSender&lt;/span&gt; &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test1&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;MessagingException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MimeMessage&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createMimeMessage&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;MimeMessageHelper&lt;/span&gt; &lt;span class="n"&gt;messageHelper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MimeMessageHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//写邮件&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setSubject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试邮件-主题&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试邮件-内容：Hello Word (带附件)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;//添加附件&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addAttachment&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1.jpg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;D:\\UserData\\Pictures\\QQ\\1.jpg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setFrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1820502...@qq.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setSentDate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1913312...@qq.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//发送邮件&lt;/span&gt;
        &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.3发送带图片的邮件&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@SpringBootTest&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MailApplicationTests&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Autowired&lt;/span&gt;
    &lt;span class="n"&gt;JavaMailSender&lt;/span&gt; &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test2&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;MessagingException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MimeMessage&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createMimeMessage&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;MimeMessageHelper&lt;/span&gt; &lt;span class="n"&gt;messageHelper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MimeMessageHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//写邮件&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setSubject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试邮件-主题&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试邮件-内容：Hello Word(带图片)，这是图1：&amp;lt;img src=&amp;#39;cid:p01&amp;#39;/&amp;gt;，这是图2：&amp;lt;img src=&amp;#39;cid:p02&amp;#39;/&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addInline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;p01&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FileSystemResource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;D:\\UserData\\Pictures\\QQ\\1.jpg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addInline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;p02&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FileSystemResource&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;File&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;D:\\UserData\\Pictures\\QQ\\1.jpg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setFrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1820502...@qq.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setSentDate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1913312...@qq.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//发送邮件&lt;/span&gt;
        &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.使用模板&lt;/h3&gt;
&lt;h4&gt;4.1使用Thymeleaf&lt;/h4&gt;
&lt;p&gt;加入依赖&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-thymeleaf&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mail.html（放在templates目录下）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt; &lt;span class="na"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cn&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;xmlns:th&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.thymeleaf.org/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;meta&lt;/span&gt; &lt;span class="na"&gt;charset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;UTF-8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;邮件&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    Hello,&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;span&lt;/span&gt; &lt;span class="na"&gt;th:text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${name}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;,欢迎加入XXX大家庭
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    您的入职信息如下:
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;table&lt;/span&gt; &lt;span class="na"&gt;border&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;职位&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;span&lt;/span&gt; &lt;span class="na"&gt;th:text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${position}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;职称&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;span&lt;/span&gt; &lt;span class="na"&gt;th:text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${jobtitle}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;薪资&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;span&lt;/span&gt; &lt;span class="na"&gt;th:text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${salary}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;部门&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;span&lt;/span&gt; &lt;span class="na"&gt;th:text&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${department}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;table&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt; &lt;span class="na"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;font-size: 24px&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;希望在未来的日子里，携手并进！&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@SpringBootTest&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MailApplicationTests&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Autowired&lt;/span&gt;
    &lt;span class="n"&gt;JavaMailSender&lt;/span&gt; &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@Autowired&lt;/span&gt;
    &lt;span class="n"&gt;TemplateEngine&lt;/span&gt; &lt;span class="n"&gt;templateEngine&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//thymeleaf模板引擎&lt;/span&gt;

    &lt;span class="cm"&gt;/*发送邮件模板 thymeleaf*/&lt;/span&gt;
    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;test3&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;MessagingException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MimeMessage&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createMimeMessage&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;MimeMessageHelper&lt;/span&gt; &lt;span class="n"&gt;messageHelper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MimeMessageHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="c1"&gt;//写邮件&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setSubject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;测试邮件-主题&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Context&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setVariable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xuxx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setVariable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;position&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Java开发&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setVariable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;jobtitle&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Java开发初级工程师&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setVariable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;salary&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;13*6k&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setVariable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;department&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;产品开发部&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;templateEngine&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;mail.html&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setFrom&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1820502...@qq.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setSentDate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="n"&gt;messageHelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setTo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1913312...@qq.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;//发送邮件&lt;/span&gt;
        &lt;span class="n"&gt;javaMailSender&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.2使用Freemarker&lt;/h4&gt;
&lt;p&gt;加入依赖&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-freemarker&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mail.ftl（放在templates目录下）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt; &lt;span class="na"&gt;lang&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;cn&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;meta&lt;/span&gt; &lt;span class="na"&gt;charset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;UTF-8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;邮件&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    Hello,${name},欢迎加入XXX大家庭
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    您的入职信息如下:
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;table&lt;/span&gt; &lt;span class="na"&gt;border&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;职位&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;${position}&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;职称&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;${jobtitle}&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;薪资&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;${salary}&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;部门&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;${department}&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;td&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;table&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt; &lt;span class="na"&gt;style&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;font-size: 24px&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;希望在未来的日子里，携手并进！&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;div&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;@SpringBootTest
class MailApplicationTests {

    @Autowired
    JavaMailSender javaMailSender;

    /*发送邮件模板 freemarker*/
    @Test
    void test4() throws MessagingException, IOException, TemplateException {
        MimeMessage message = javaMailSender.createMimeMessage();
        MimeMessageHelper messageHelper = new MimeMessageHelper(message, true);

        //写邮件
        messageHelper.setSubject("测试邮件-主题");
        Configuration configuration = new Configuration(Configuration.VERSION_2_3_29);
        configuration.setClassLoaderForTemplateLoading(this.getClass().getClassLoader(), "templates");
        Template template = configuration.getTemplate("mail.ftl");
        Map&amp;lt;String, Object&amp;gt; map = new HashMap();
        map.put("name", "xuxx");
        map.put("position", "Java开发");
        map.put("jobtitle", "Java开发初级工程师");
        map.put("salary", "13*6k");
        map.put("department", "产品开发部");
        StringWriter out = new StringWriter();
        template.process(map, out);
        messageHelper.setText(out.toString(), true);
        messageHelper.setFrom("1820502...@qq.com");
        messageHelper.setSentDate(new Date());
        messageHelper.setTo("1913312...@qq.com");
        //发送邮件
        javaMailSender.send(message);
    }
}&lt;/code&gt;&lt;/pre&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj25/</guid><pubDate>Wed, 03 Jun 2020 23:50:00 +0806</pubDate></item><item><title>MySQL优化相关</title><link>/Xuxx_Blogs/archives/bj27/</link><description>&lt;h1&gt;MySQL分层逻辑架构&lt;/h1&gt;
&lt;h3&gt;一. MySQL逻辑分层&lt;/h3&gt;
&lt;p&gt;首先可以把服务端想象成一个大的容器，里面有四层结构，当一个请求过来后，将会执行这四层，执行一遍后才会返回给想要的结果。&lt;/p&gt;
&lt;h4&gt;1.连接层&lt;/h4&gt;
&lt;p&gt;客户端发送一个Select是直接交给连接层来处理，而它的作用就是提供与客户端连接的服务.连接层只是与客户端建立起连接.完成一些类似连接处理,授权认证 及相关的安全方案. 在该层上引入了连接池的概念.&lt;/p&gt;
&lt;h4&gt;2.服务层&lt;/h4&gt;
&lt;p&gt;提供核心的服务功能,如sql接口,完成缓存的查询,&lt;/p&gt;
&lt;p&gt;sql的分析和优化部分及内置函数的执行.&lt;/p&gt;
&lt;p&gt;服务包括以下内容:&lt;/p&gt;
&lt;h5&gt;2.1Mangement Service&lt;/h5&gt;
&lt;p&gt;备份  安全  复制  集群&lt;/p&gt;
&lt;h5&gt;&lt;strong&gt;2.2-&lt;/strong&gt;SQL interface&lt;/h5&gt;
&lt;p&gt;存储过程    视图  触发器&lt;/p&gt;
&lt;h5&gt;2.3-Parser解析&lt;/h5&gt;
&lt;p&gt;查询事务    对象权限&lt;/p&gt;
&lt;h5&gt;2.4-Optimizer优化器&lt;/h5&gt;
&lt;p&gt;当编写Sql语句执行时，优化器会觉得我写的sql语句性能不够好，这个时候，优化器会自己写一个等价于跟我写的执行后结果一致的sql语句进行代替.&lt;/p&gt;
&lt;h5&gt;2.5-Cache Buffers&lt;/h5&gt;
&lt;p&gt;缓存&lt;/p&gt;
&lt;p&gt;服务器会查询内部的缓存,如果缓存空间足够大,这样可以解决大量读操作的环境中,能够很好的提升系统性能&lt;/p&gt;
&lt;h4&gt;3.引擎层&lt;/h4&gt;
&lt;p&gt;存储引擎是真正负责MYSQL中数据的存储和提取,服务器通过API与存储引擎进行通信, 不同的存储引擎提供的功能不同,可以根据自己的实际需求来进行选取。&lt;/p&gt;
&lt;p&gt;常见的有：lnnoDB、MylSAM、Memory&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;lnnoDB：它在设计的时候，它是事务优先。&lt;/p&gt;
&lt;p&gt;原理：因为它是行锁，每一条数据都要锁，锁的太多，性能就降低了，虽然性能降低了，但是适合高并发了，就不容易出错了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MylSAM：性能优先&lt;/p&gt;
&lt;p&gt;原理：因为它是表锁，对于表里面的十条数据来说是不受影响的，对十条锁一次就完了，所以性能快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Memroy：memory存储引擎是MySQL中的一类特殊的存储引擎。&lt;/p&gt;
&lt;p&gt;其使用存储在内存中的内容来创建表，而且所有数据也放在内存中,因此，其基于内存中的特性，这类表的处理速度会非常快，但是，其数据易丢失，生命周期短。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.存储层&lt;/h4&gt;
&lt;p&gt;主要是将数据存储在运行的计算机文件系统之上,并完成与存储引擎的交互。&lt;/p&gt;
&lt;h3&gt;二. 整体执行流程&lt;/h3&gt;
&lt;p&gt;1.首先客户端发出一个Select操作&lt;/p&gt;
&lt;p&gt;2.连接层接收后给服务层&lt;/p&gt;
&lt;p&gt;3.服务层对你的查询进行一个优化，并把优化结果给引擎层&lt;/p&gt;
&lt;p&gt;4.选择当前数据库的引擎，选完引擎后，引擎将最终的数据交给了存储层&lt;/p&gt;
&lt;p&gt;5.存储层，用存储层来存储数据&lt;/p&gt;
&lt;h1&gt;MySQL索引&lt;/h1&gt;
&lt;h3&gt;什么是索引？&lt;/h3&gt;
&lt;p&gt;首先，索引是一种数据结构。排好序的快速查找的数据结构。&lt;/p&gt;
&lt;p&gt;在数据之外，数据库系统还维持着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构的基础上实现高级查找算法。这种数据结构，就是索引。&lt;/p&gt;
&lt;h3&gt;索引的优势&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;提高检索效率，降低数据库的IO成本&lt;/p&gt;
&lt;p&gt;类似图书馆里的图书管理，提高数据的检索效率，降低了io成本。例如：图书管理有100万条藏书，ok，兄弟此时进去找书，如果没有索引，从第一条到到100万条，祖坟冒青烟你牛恰巧第一条就是要找到图书，那么点子背的找到100万条全表扫描。那么这个时候如果频繁进行100万次的IO。不仅浪费时间，而且还消耗内存。如果像上面树的方式大大减少查找时间和IO的频繁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过索引列队数据进行排序，降低数据排序的成本，降低了CPU的消耗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;索引的劣势&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表中的记录，所以索引列也是要占空间的。&lt;/li&gt;
&lt;li&gt;虽然索引大大提高了查询速度，同时会降低更新表的速度。比如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL不仅要保存树，还要保存一下索引文件每次更新添加了索引列的字段。都会调整因为每次更新带来的键值变化后的索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间来研究建立最优秀的索引，或者优化查询SQL语句。&lt;/p&gt;
&lt;h3&gt;磁盘IO与预读&lt;/h3&gt;
&lt;p&gt;考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，&lt;strong&gt;当一次IO时，不仅把当前磁盘地址的数据，而且把相邻的数据也都读取到内存缓冲区内&lt;/strong&gt;，因为局部预读性原理告诉，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。&lt;/p&gt;
&lt;h3&gt;适合建索引和不适合建索引&lt;/h3&gt;
&lt;p&gt;哪些情况适合建索引：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主键自动建立唯一索引&lt;/li&gt;
&lt;li&gt;频繁作为查询条件的字段应该创建索引&lt;/li&gt;
&lt;li&gt;查询中与其他标关联的字段，外检关联建立索引&lt;/li&gt;
&lt;li&gt;频繁更新的字段不适合创建索引（更新字段不仅要更新数据本身，而且还要更新索引树）&lt;/li&gt;
&lt;li&gt;where条件里用不到的字段不创建索引&lt;/li&gt;
&lt;li&gt;单键/组合索引的选择问题，who？（在高并发下倾向创建组合索引）&lt;/li&gt;
&lt;li&gt;查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度（索引主要干两件事：检索、排序。）&lt;/li&gt;
&lt;li&gt;查询中要统计或者分组的字段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;哪些情况不适合建索引：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表记录太少（300万左右性能开始逐渐下降，虽然官方文档说撑得住5-8百万以上，但是根本也不能等到这个时候再去优化，性能肯定会受到影响）&lt;/li&gt;
&lt;li&gt;经常增删改的表（为什么？提高了查询速度，同时却会降低了更新表的速度，入队表进行INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件）。&lt;/li&gt;
&lt;li&gt;数据重复切分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。注意，如果某个数据列包括许多重复的内容，为它建立索引就没有太大的实际效果了。（假设一个表有10万行的记录，有一个字段A只有True和False两个值，且每个值的分布概率大约为50%，那么对这种表的A字段建立索引一般不会提高数据库的查询速度。再比如对银行卡建立索引，毕竟银行卡没有重复的。索引的选择性是指索引列中不同值的数据与表中的记录数的比，如果一个表中有2000条记录，表索引列就有1980个不同的值，那么这个索引的选择性就是1980/2000=0.99。一个索引的选择性越接近于1，那么这个索引的效率就越高。）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;MySQL索引优化1-性能分析Explain&lt;/h1&gt;
&lt;h3&gt;MySQL自带查询优化器(MySQL Query Optimizer)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;MySQL中有专门负责优化SELECT语句的优化器模块，主要功能：通过计算机分析系统中收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（系统认为最优的数据检索方式，不见得是DBA认为是最优的，这部分最耗费时间）&lt;/li&gt;
&lt;li&gt;当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别处是SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer 会先对整条Query进行优化，处理吊一些常量表达式的预算，直接换算成常量值，并对Query中的查询条件进行简化和转换，去掉一些无用或显而易见的条件、结构调整等。然后分析Query中的hint信息（如果有），看现实Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或Hint信息不足以完全确定执行计划，则会读取索设计对象的统计信息，根据Query进行写相应的计算分析，然后在得出最后的执行计划。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;MySQL常见瓶颈&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候&lt;/li&gt;
&lt;li&gt;IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候&lt;/li&gt;
&lt;li&gt;服务器硬盘的性能瓶颈：top，free，iostat和vmstat来查看系统的性能状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果SQL优化器没有更改，并且这些瓶颈也没有出现，那么调出MySQL分析报告来看看到底MySQL哪里惹了事。&lt;/p&gt;
&lt;h3&gt;EXPLAIN&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href="https://dev.MySQL.com/doc/refman/8.0/en/execution-plan-information.html"&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;是什么？（查看执行计划）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的，分析你的查询语句或是表结构的性能瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;能干吗？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;表的读取顺序&lt;/li&gt;
&lt;li&gt;数据读取操作的操作类型&lt;/li&gt;
&lt;li&gt;哪些索引可以使用&lt;/li&gt;
&lt;li&gt;哪些索引被实际使用&lt;/li&gt;
&lt;li&gt;表之间的引用&lt;/li&gt;
&lt;li&gt;每张表有多少行被优化器查询&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;怎么用？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Explain + SQL语句&lt;/li&gt;
&lt;li&gt;执行计划包含的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class="pswp-item"  data-width="-1" data-height="-1" size-undefined&gt;&lt;img src="..\static\笔记图片\2020-08-27-MySQL优化相关_06.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;各字段解释:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;id&lt;/strong&gt;：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包含3种情况：&lt;ul&gt;
&lt;li&gt;id相同，执行顺序由上至下&lt;/li&gt;
&lt;li&gt;id不同，值越大优先级越高越先被执行&lt;/li&gt;
&lt;li&gt;id部分相同，如果id相同，可认为是同一组，执行顺序从上到下。在所有组中，id值越大执行优先级越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：id的值表示select子句或表的执行顺序，id相同，执行顺序从上到下，id不同，值越大的执行优先级越高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;select_type：SELECT的类型&lt;/p&gt;
&lt;p&gt;常见：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SIMPLE : 简单的SELECT查询, 查询中不包含子查询或者UNION&lt;/li&gt;
&lt;li&gt;PRIMARY : 查询中包含任何复杂的子查询, 最外层查询被标记为PRIMARY&lt;/li&gt;
&lt;li&gt;SUBQUERY : 在SELECT或WHERE列表中包含子查询&lt;/li&gt;
&lt;li&gt;DERIVED : 在FROM列表中包含的子查询被标记为DERIVED(衍生), MySQL会递归执行这些子查询, 把结果放在临时表里&lt;/li&gt;
&lt;li&gt;UNION : 若第二个SELECT出现在UNION之后, 则被标记为UNION; 若UNION包含在FROM子句的子查询中, 外层SELECT被标记为 : DERIVED&lt;/li&gt;
&lt;li&gt;UNION RESULT : 从UNION表获取结果的SELECT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;table：显示这一行的数据是关于哪张表的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;：访问类型, 显示查询使用了何种类型，&lt;/p&gt;
&lt;p&gt;从最好到最差依次是：&lt;strong&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&lt;/strong&gt; （常见的）&lt;/p&gt;
&lt;p&gt;一般来说, 要保证查询至少达到 range 级别, 最好能达到 ref 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;system：表只有一行记录(等于系统表), 这是 const 类型的特例, 平时不会出现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;const：表示通过索引一次就找到了, const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据, 索引很快, 如将主键置于where列表中, MySQL就能将该查询转换为一个“常量”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;eq_ref：唯一性索引扫描, 对于每个索引键, 表中只有一条记录与之匹配。常见于主键或唯一索引扫描&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ref：非唯一性索引扫描, 返回匹配某个单独值的所有行。本质上也是一种索引访问, 它返回所有匹配某个单独值的行, 可能会找到多个符合条件的行, 所以这个应该属于查找和扫描的混合体&lt;/p&gt;
&lt;p&gt;eq_ref和ref：就好比一个班级里面，只有一个班主任和一群学生，t2返回的只有一个记录（就就好比班主任），而col1返回的是所有col1等于ac（所有名字是ac的学生）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;range：只检索给定范围的行, 使用一个索引来选择行。key 列显示使用了哪个索引, 一般就是在 where 语句中出现了between, &amp;lt; ,&amp;gt; ,in 等的查询。这种范围索引扫描比全表扫描要好, 因为它只需要开始于索引的某一点, 而结束于另一点, 不用扫描全部索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;index：Full Index Scan(全索引扫描), index与ALL的区别为index类型只遍历索引树。这通常比ALL快, 因为索引文件通常比数据文件小。(也就是说，虽然&lt;strong&gt;ALL和index都是读全表, 但index是从索引中读取的, 而ALL是从硬盘中读取的&lt;/strong&gt;)。&lt;/li&gt;
&lt;li&gt;ALL：Full Table Scan(全表扫描), 将遍历全表以找到匹配的行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;possible_keys：可能用到的索引，一个或多个，&lt;strong&gt;但不一定被查询实际使用&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;key&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际使用的索引, 如果为NULL, 则没有使用索引。（要么没建索引，要么建了索引没用，即索引失效）&lt;/li&gt;
&lt;li&gt;查询中若使用了覆盖索引, 则该索引仅出现在key列表中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;key_len：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示索引中使用的字节数, 可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下, 长度越短越好。（有句话说就是：不给马吃草，又要马儿跑）&lt;/li&gt;
&lt;li&gt;key_len显示的值为索引字段的最大可能长度, &lt;strong&gt;并非实际使用长度&lt;/strong&gt;, 即 key_len 是根据表定义计算而得, 不是通过表内检索获得的（同样的查询结果，key_len用的越少越好）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ref：显示索引的哪一列被使用了, 如果可能的话, 最好是一个常数。哪些列或常量被用于查找索引列上的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;rows&lt;/strong&gt;：根据表统计信息及索引选用情况, 大致估算出找到所需记录所需要读取的行数（表中有多少行被优化器查询）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Extra&lt;/strong&gt;：包含不适合在其他列中显示但十分重要的额外信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Using filesort&lt;/strong&gt; : 说明MySQL会对数据使用一个外部的索引排序, 而不是按照表内索引顺序进行读取。&lt;strong&gt;MySQL中无法利用索引完成的排序操作称为"文件内排序"&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Using temporary&lt;/strong&gt; : 同比前者性能更差，使用了临时表保存中间结果, MySQL在对查询结果排序时使用了临时表。常见于排序order by和分组查询group by。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Using index&lt;/strong&gt; : 表示相应的SELECT操作中使用了&lt;strong&gt;覆盖索引(Covering Index)&lt;/strong&gt;, 避免了访问表的数据行, 效率还可以&lt;/li&gt;
&lt;li&gt;Using where : 使用了where过滤&lt;/li&gt;
&lt;li&gt;Using join buffer : 使用了连接缓存索引优化MIN/MAx操作或者对于MyIsam存储引擎优化COUNT(*)操作, 不必等到执行阶段再进行计算, 查询执行计划生成阶段即完成优化。&lt;/li&gt;
&lt;li&gt;Impossible WHERE : where子句值总是false, 不能用来获取任何数据, 如name=‘张三’ and name=‘李四’(不可能一个人名字是张三，又是李四吧)&lt;/li&gt;
&lt;li&gt;Select tables optimized away : 在没有group by子句的情况下, 基于distinct : 优化distinct操作, 在找到第一匹配的元组后即停止找同样值的动作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;补充&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;覆盖索引(Covering Index)，一说为索引覆盖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解方式一：就是select的数据列只用从索引中就能够获取，不比读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说&lt;strong&gt;查询列要被所建的索引覆盖。&lt;/strong&gt;（也就是说建的索引是col1,col2,col3的复合索引，刚好查询的也是这几列或者部分满足）&lt;/p&gt;
&lt;p&gt;理解方式二：索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的行，因此它不必读取整个行，毕竟索引叶子节点存储了他们所引用的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了，一个索引包含了（或覆盖了）满足查询结果的数据就叫做覆盖索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果使用覆盖索引，一定要注意select列表中只要所需的列，不可 select * ；因为如果将所有的字段一起做索引会导致索引文件过大，查询性能下降。&lt;/p&gt;
&lt;h1&gt;MySQL索引优化2-优化法则&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;全值匹配我最爱(怎么建就怎么用)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;最佳左前缀法则&lt;/strong&gt;：如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描厨&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;存储引擎不能使用索引中范围条件右边的列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select *&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MySQL在使用不等于(!=或者&amp;lt;&amp;gt;)的时候无法使用索引会导致全表扫描&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;is null ,is not null也无法使用索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;like以通配符开头('%abc...')MySQL索引失效会变成全表扫描的操作(like % 加右边)&lt;/p&gt;
&lt;p&gt;问题:解决like '%字符串%'时索引不被使用的方法? —— 覆盖索引（索引的个数和顺序与查询的字段完全相同或者部分相同）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;字符串不加单引号索引失效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;少用or,用它来连接时会索引失效&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;口诀：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​   全值匹配我最爱，最左前缀要遵守;
​   带头大哥不能死，中间兄弟不能断;
​   索引列上少计算，范围之后全失效;
​   LIKE百分写最右，覆盖索引不写星;
​   不等空值还有or，索引失效要少用;
​   VAR引号不可丢，SQL高级也不难!&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 127.46478873239437" data-width="724" data-height="284"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/6a22c90a5f9e338160ca39b7255acbef.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;Sql 语句中 IN 和 EXISTS 的区别及应用&lt;/h2&gt;
&lt;p&gt;student表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="k"&gt;IF&lt;/span&gt; &lt;span class="k"&gt;EXISTS&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;`stuid`&lt;/span&gt; &lt;span class="kt"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt; &lt;span class="k"&gt;COMMENT&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;学号&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;`stunm`&lt;/span&gt; &lt;span class="kt"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt; &lt;span class="k"&gt;COMMENT&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;学生姓名&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;`stuid`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt; &lt;span class="k"&gt;DEFAULT&lt;/span&gt; &lt;span class="k"&gt;CHARSET&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;-- ----------------------------&lt;/span&gt;
&lt;span class="c1"&gt;-- Records of student&lt;/span&gt;
&lt;span class="c1"&gt;-- ----------------------------&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;张三&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;李四&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;赵二&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;王五&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;刘青&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;周明&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`student`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1007&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;吴七&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;score表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="k"&gt;IF&lt;/span&gt; &lt;span class="k"&gt;EXISTS&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;`stuid`&lt;/span&gt; &lt;span class="kt"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;`courseno`&lt;/span&gt; &lt;span class="kt"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;`scores`&lt;/span&gt; &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="k"&gt;DEFAULT&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;`stuid`&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;`courseno`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt; &lt;span class="k"&gt;DEFAULT&lt;/span&gt; &lt;span class="k"&gt;CHARSET&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;-- ----------------------------&lt;/span&gt;
&lt;span class="c1"&gt;-- Records of score&lt;/span&gt;
&lt;span class="c1"&gt;-- ----------------------------&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;67&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;87&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;83&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;88&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;77&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;77&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;68&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;88&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;84&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;89&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;78&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;78&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;69&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;89&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;85&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;90&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;79&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;79&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;70&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;90&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;86&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;91&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;80&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;80&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;71&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;91&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;87&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;92&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;81&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;81&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;72&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;92&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;88&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;93&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;82&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`score`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;1006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;82&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;course表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;DROP&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="k"&gt;IF&lt;/span&gt; &lt;span class="k"&gt;EXISTS&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;`courseno`&lt;/span&gt; &lt;span class="kt"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="n"&gt;`coursenm`&lt;/span&gt; &lt;span class="kt"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;NOT&lt;/span&gt; &lt;span class="no"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
  &lt;span class="k"&gt;PRIMARY&lt;/span&gt; &lt;span class="k"&gt;KEY&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;`courseno`&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt; &lt;span class="k"&gt;DEFAULT&lt;/span&gt; &lt;span class="k"&gt;CHARSET&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt; &lt;span class="k"&gt;COMMENT&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;课程表&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;-- ----------------------------&lt;/span&gt;
&lt;span class="c1"&gt;-- Records of courses&lt;/span&gt;
&lt;span class="c1"&gt;-- ----------------------------&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C001&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;大学语文&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C002&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;新视野英语&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C003&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;离散数学&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C004&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;概率论与数理统计&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C005&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;线性代数&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C006&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;高等数学(一)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;INSERT&lt;/span&gt; &lt;span class="k"&gt;INTO&lt;/span&gt; &lt;span class="n"&gt;`courses`&lt;/span&gt; &lt;span class="k"&gt;VALUES&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C007&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;高等数学(二)&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补充：SQL语句执行顺序详见：&lt;a href="https://blog.csdn.net/wqc19920906/article/details/79411854"&gt;SQL语句执行顺序&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;IN 语句：只执行一次&lt;/h3&gt;
&lt;p&gt;确定给定的值是否与子查询或列表中的值相匹配。in在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。&lt;/p&gt;
&lt;p&gt;具体sql示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;student&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stuid&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;stuid&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stuid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stuid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 55.88235294117647" data-width="247" data-height="221"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/4f4916684820eb253733a0241388ad90.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;student&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stuid&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;stuid&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stuid&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;1005&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 52.87356321839081" data-width="184" data-height="174"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/13307a1b359144618aeae7c2e57c9a31.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;以上两个语句的执行流程：&lt;/p&gt;
&lt;p&gt;首先会执行from语句找出student表，然后执行 in 里面的子查询，再然后将查询到的结果和原有的user表做一个笛卡尔积，再根据的student.stuid IN score.stuid的条件，将结果进行筛选（既比较stuid列的值是否相等，将不相等的删除）。最后得到符合条件的数据。&lt;/p&gt;
&lt;h3&gt;EXISTS语句：执行student.length次&lt;/h3&gt;
&lt;p&gt;指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。匹配上就将结果放入结果集中。&lt;/p&gt;
&lt;p&gt;语法：EXISTS&lt;/p&gt;
&lt;p&gt;SELECT ... FROM table WHERE EXISTS(subquery)&lt;/p&gt;
&lt;p&gt;理解：将主查询的数据放到子查询中做条件验证，根据验证结果（TRUE或者FALSE）来决定朱查询的数据结果是否得意保留。相当于从表A和B中取出交集，然后再从A表中取出所在交集的部分数据，当然后面加WHERE条件还可以进一步筛选。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;student&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="k"&gt;EXISTS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;stuid&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;score&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stuid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stuid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这条sql语句的执行结果和上面的in的第一条执行结果是一样的。&lt;/p&gt;
&lt;p&gt;但是，不一样的是它们的执行流程完全不一样：&lt;/p&gt;
&lt;p&gt;　　使用exists关键字进行查询的时候，首先，先查询的不是子查询的内容，而是查的主查询的表，也就是说，先执行的sql语句是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;student&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 55.6" data-width="278" data-height="250"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/605a25566c74143dfd27c97534313339.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果成立则返回true不成立则返回false。如果返回的是true的话，则该行结果保留，如果返回的是false的话，则删除该行，最后将得到的结果返回。&lt;/p&gt;
&lt;h3&gt;IN和EXISTS的区别及应用场景&lt;/h3&gt;
&lt;p&gt;​   如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用 in , 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用 exists 。其实区分 in 和 exists 主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是 exists ，那么以外层表为驱动表，先被访问，如果是 in ，那么先执行子查询，所以会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外 in 时不对NULL进行处理。&lt;/p&gt;
&lt;p&gt;​   in 是把外表和内表作 hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。一直以来认为exists比in效率高的说法是不准确的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;not in 和not exists&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​   如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。&lt;/p&gt;
&lt;h2&gt;查询优化&lt;/h2&gt;
&lt;h3&gt;1.原则&lt;/h3&gt;
&lt;h4&gt;1.小表驱动大表，即小的数据集驱动大的数据集。&lt;/h4&gt;
&lt;p&gt;​   数据库最伤神的就是跟程序链接释放，第一个建立了10000次链接，第二个建立了50次。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。
这时候就诞生了in 和exists的对比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里假设A表代表员工表，B表代表部门表。
假设部门只有三个，销售、技术部、行政部，言下之意是在这三个部门里的所有员工都查出。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;p&gt;先循环&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如一个公司有5个部门，但是华为的员工少说有15W-20W，员工总不能比部门多吧，1个员工不能有10-20几个部门吧，这时候就相当于得到了小表(部门表)；&lt;/p&gt;
&lt;p&gt;后循环：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;相当于A.id等B表里面的，相当于从部门表获得对应的id。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当B表的数据集必须小于A表的数据集时，用in优于exists。&lt;/strong&gt;
反之&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;exists&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;where&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="cp"&gt;# 这里的select 1并不绝对，可以写为select &amp;#39;X&amp;#39;或者&amp;#39;A&amp;#39;,&amp;#39;B&amp;#39;,&amp;#39;C&amp;#39;都可以，只要是常量就可以。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;等价于：&lt;/p&gt;
&lt;p&gt;先循环&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后循环&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样exists就会变成看看A表是否存在于(select 1 from B where B.id = A.id)里面，这个查询返回的是TRUE或者FALSE的BOOL值，简单来说就是要当A表的数据集小于B表的数据集时，用exists优于in。&lt;/p&gt;
&lt;p&gt;要注意的是：A表与B表的ID字段应该建立索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EXISTS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法：EXISTS&lt;/p&gt;
&lt;p&gt;SELECT ... FROM table WHERE EXISTS(subquery)。&lt;/p&gt;
&lt;p&gt;理解：将主查询的数据放到子查询中做条件验证，根据验证结果（TRUE或者FALSE）来决定朱查询的数据结果是否得意保留。&lt;/p&gt;
&lt;p&gt;相当于从表A和B中取出交集，然后再从A表中取出所在交集的部分数据，当然后面加WHERE条件还可以进一步筛选。&lt;/p&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;SQL语句执行顺序详见：&lt;a href="https://blog.csdn.net/wqc19920906/article/details/79411854"&gt;SQL语句执行顺序&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EXISTS(subquery)只返回TRUE或者FALSE，因此子查询中的SELECT * 也可以是SELECT 1 或者SELECT 'X'，官方说法是实际执行时会忽略SELECT清单，因此没有区别。&lt;/li&gt;
&lt;li&gt;EXISTS子查询的实际执行过程可能经过了优化而不是理解上的逐条对比，如果担忧效率问题，可进行实际校验。&lt;/li&gt;
&lt;li&gt;EXISTS子查询旺旺可以用条件表达式，其他子查询或者JOIN来替代，何种最优需要具体问题具体分析。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;如果查询的两个表大小相当，那么用in和exists差别不大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;延伸举例巩固：&lt;/p&gt;
&lt;p&gt;如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：
例如：表A（小表），表B（大表）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 效率低，用到了A表上cc列的索引；&lt;/span&gt;
&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="k"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="n"&gt;cc&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="k"&gt;where&lt;/span&gt; &lt;span class="n"&gt;cc&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 效率高，用到了B表上cc列的索引。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相反的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;select * from B where cc in (select cc from A) ;  # 效率高，用到了B表上cc列的索引；
select * from B where exists(select cc from A where cc=B.cc) ;  # 效率低，用到了A表上cc列的索引。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item"  data-width="-1" data-height="-1" size-undefined&gt;&lt;img src="..\static\笔记图片\2020-08-27-MySQL优化相关_01.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;2.Order By关键字优化&lt;/h4&gt;
&lt;p&gt;Order By子句，尽量使用Index方式排序,避免使用FileSort方式排序 。&lt;/p&gt;
&lt;p&gt;尽可能在索引列上完成排序操作，遵照索引的最佳左前缀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提高Order By的速度:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Order by时, select * 是一个大忌,应该只 select 需要的字段，这点非常重要。在这里的影响是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当Query的字段大小总和小于max_length_for_sort_data而且排序字段不是TEXT 或者 BLOB类型时，会用改进后的算法——单路排序，否则用老算法——多路排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;两种排序算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次IO，但是用单路排序算法的风险会更大一些,所以需要提高sort_buffer_size。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试提高 sort_buffer_size (排序缓冲区大小)&lt;/p&gt;
&lt;p&gt;不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尝试提高 max_length_for_sort_data (排序数据的最大长度)&lt;/p&gt;
&lt;p&gt;提高这个参数，会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高磁盘I/O活动和低CPU使用率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure class="pswp-item"  data-width="-1" data-height="-1" size-undefined&gt;&lt;img src="..\static\笔记图片\2020-08-27-MySQL优化相关_02.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;3.Group By关键字优化&lt;/h4&gt;
&lt;p&gt;与Order By相似。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;group by实质是先排序后进行分组，遵照索引建的最佳左前缀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;where高于having，能写在where限定的条件就不要去having限定了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;慢查询的开启并捕获&lt;/li&gt;
&lt;li&gt;explain + 慢SQL分析&lt;/li&gt;
&lt;li&gt;show profile 查询SQL在MySQL服务器里面的执行细节和生命周期情况&lt;/li&gt;
&lt;li&gt;SQL数据库服务器的参数调优。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;慢查询日志&lt;/h2&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;a href="https://dev.MySQL.com/doc/refman/8.0/en/slow-query-log.html"&gt;https://dev.MySQL.com/doc/refman/8.0/en/slow-query-log.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;1.说明&lt;/h3&gt;
&lt;p&gt;MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具
体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。&lt;/p&gt;
&lt;p&gt;具体指运行时间超过Iong_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行时间大于10秒的语句。&lt;/p&gt;
&lt;p&gt;由它来查看哪些SQL超出了的最大忍耐时间值，再结合 explain 进行全面分析。&lt;/p&gt;
&lt;h3&gt;2.使用&lt;/h3&gt;
&lt;p&gt;默认MySQL没有开启慢查询，需要说动设置这个参数。当然，如果不是调优需要的话，一般不建议开启该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志写入文件。&lt;/p&gt;
&lt;p&gt;查看是否开启  &lt;code&gt;SHOW GLOBAL VARIABLES LIKE 'slow_query_log%'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item"  data-width="-1" data-height="-1" size-undefined&gt;&lt;img src="..\static\笔记图片\2020-08-27-MySQL优化相关_03.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面查询结果第一行，这里是开启的，第二行是默认查询路径文件名。&lt;/p&gt;
&lt;p&gt;补充：如果通过终端命令设定的话，再查询是看不到修改结果的，需要新开启一个窗口查看即可。如果要永久生效，必须修改my.cnf配置文件(其他系统变量也是如此)。&lt;/p&gt;
&lt;p&gt;要明确指定初始慢查询日志状态，请使用 &lt;code&gt;SET GLOBAL slow_query_log = 1 | 0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;`SET GLOBAL slow_query_log = 1&lt;/code&gt;开启慢查询日志只对当前数据库生效，MySQL重启后便会失效。&lt;/p&gt;
&lt;p&gt;那么开启了慢日志后，怎么样的SQL才会记录到慢查询当中呢？&lt;/p&gt;
&lt;p&gt;这个是由参数&lt;code&gt;long_query_time&lt;/code&gt;控制，默认情况下&lt;code&gt;long_query_time&lt;/code&gt;的值是10秒。
查看:&lt;code&gt;SHOW GLOBAL VARIABLES LIKE 'long_query_time';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;假如SQL运行时间刚好等于long_query_time的情况，并不会被记录下来，也就是说，在MySQL源码里是判断&lt;strong&gt;大于&lt;code&gt;long_query_time&lt;/code&gt;，而非大于等于&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;设置:&lt;code&gt;SET GLOBAL long_query_time = 3&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;记录慢SQL并后续分析：select sleep(4);&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item"  data-width="-1" data-height="-1" size-undefined&gt;&lt;img src="..\static\笔记图片\2020-08-27-MySQL优化相关_04.png" alt="1598601396920" /&gt;&lt;figcaption&gt;1598601396920&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查看当前系统中多少条满记录：&lt;code&gt;show global status like '%Slow_queries%';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item"  data-width="-1" data-height="-1" size-undefined&gt;&lt;img src="..\static\笔记图片\2020-08-27-MySQL优化相关_05.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;配置版&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;show_query_log = 1;
show_query_log_file=/var/lib/MySQL/MySQL_slow.log
log_query_time=3;
log_output=FILE&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;3.日志分析工具MySQLdumpslow&lt;/h3&gt;
&lt;p&gt;在生产环境中，如果要手动分析日志，查找、分析SQL，显然是一个体力活，MySQL提供了日志分析工具MySQLdumpslow。&lt;/p&gt;
&lt;p&gt;上面测试的慢查询SQL只有一条，假如在实际的生产环境中，慢查询SQL远远高于测试的数量，十几条甚至几十条，假如几条慢查询出现的频率很高，能做到根据轻重优先级来分析并排除那是不是更好？那么就用到了MySQLdumpslow。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@lig MySQL]# MySQLdumpslow --help   ----------------------------------------------//执行命令
Usage: MySQLdumpslow [ OPTS... ] [ LOGS... ]

Parse and summarize the MySQL slow query log. Options are

  --verbose    verbose
  --debug      debug
  --help       write this text to standard output

  -v           verbose
  -d           debug
  -s ORDER     what to sort by (al, at, ar, c, l, r, t), 'at' is default
                al: average lock time
                ar: average rows sent
                at: average query time
                 c: count
                 l: lock time
                 r: rows sent
                 t: query time  
  -r           reverse the sort order (largest last instead of first)
  -t NUM       just show the top n queries
  -a           don't abstract all numbers to N and strings to 'S'
  -n NUM       abstract numbers with at least n digits within names
  -g PATTERN   grep: only consider stmts that include this string
  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),
               default is '*', i.e. match all
  -i NAME      name of server instance (if using MySQL.server startup script)
  -l           don't subtract lock time from total time&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;s：表示按照何种方式排序&lt;/p&gt;
&lt;p&gt;c：访问次数&lt;/p&gt;
&lt;p&gt;i：锁定时间&lt;/p&gt;
&lt;p&gt;r：返回记录&lt;/p&gt;
&lt;p&gt;t：查询时间&lt;/p&gt;
&lt;p&gt;al：平均锁定时间&lt;/p&gt;
&lt;p&gt;ar：平均返回记录数&lt;/p&gt;
&lt;p&gt;at：平均查询时间&lt;/p&gt;
&lt;p&gt;t：即为返回前面多少条数据&lt;/p&gt;
&lt;p&gt;g：后边搭配一个正则匹配模式，大小写不敏感&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;MySQLdumpslow -s r -t 10 /data/MySQL/MySQL-slow.log  //得到返回记录集最多的10个SQL
MySQLdumpslow -s c -t 10 /data/MySQL/MySQL-slow.log //得到访问次数最多的10个SQL 
MySQLdumpslow -s t -t 10 -g "left join" /data/MySQL/MySQL-slow.log  //得到按照时间排序的前10条里面含有做了连接的查询SQL
MySQLdumpslow -s r -t 10 /data/MySQL/MySQL-slow.log | more  //另外建议在使用这些命令时结合|和more使用，否则有可能出现爆屏情况&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;MySQL查询优化(3)-show profile&lt;/h1&gt;
&lt;p&gt;如果想要进行SQL查询的数据调优、排查。&lt;/p&gt;
&lt;p&gt;第一步，一定要让出现的问题重现啊(运营工程师或DBA他们从监控系统里面，收到了爆炸，系统变慢了，大家都知道，重要的核心系统都会有另外一套辅助的系统来监控，这种监控系统，比如说现在这个系统慢与每一个模块平均时间，可能5秒钟就能执行完，但是已经长达20秒了，这个时候就要判断为什么慢了。&lt;/p&gt;
&lt;p&gt;有很多种可能的原因：可能是程序的内存泄漏，可能是死锁，可能是网络，可能是SQL写的烂。&lt;/p&gt;
&lt;p&gt;假设是SQL的问题，那么需要把有问题的SQL抓出来&lt;/p&gt;
&lt;p&gt;执行过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收到问题，诊断SQL&lt;/li&gt;
&lt;li&gt;开启慢查询日志，抓出执行的慢的SQL&lt;/li&gt;
&lt;li&gt;使用explain分析（基本上可以找到为题所在，但是如果还是没有摆平，SQL在传输、网络、连接、死锁，需要进一步细粒度的查询和排查的时候就需要使用show profile）&lt;/li&gt;
&lt;li&gt;show profile（还是解决的一般般）&lt;/li&gt;
&lt;li&gt;配合DBA 到my.cnf配置文件中对各种性能的参数调优和修改(基本上是DBA修改)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;show profile&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/show-profile.html"&gt;MySQL 8.0参考手册-show profile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是什么：是mysql 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量。（默认情况下，参数处于关闭状态，并保存最近15次的运行结果）&lt;/p&gt;
&lt;p&gt;分析步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;是否支持，看看当前的MySQL版本是否支持:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;show&lt;/span&gt; &lt;span class="k"&gt;variables&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;profiling&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="c1"&gt;#或&lt;/span&gt;
 &lt;span class="k"&gt;show&lt;/span&gt; &lt;span class="k"&gt;variables&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;profiling%&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开启功能，默认是关闭，使用前需要开启:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;profiling&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运行sql&lt;/p&gt;
&lt;p&gt;随便运行几条SQL，以便于show prifiles的日志分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;查询结果&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;show&lt;/span&gt; &lt;span class="k"&gt;profiles&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.5578231292517" data-width="1112" data-height="588"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/d7b7871622ba995c7ad16bb1f2cbb95e.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;诊断SQL&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;show&lt;/span&gt; &lt;span class="k"&gt;profile&lt;/span&gt; &lt;span class="k"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;block&lt;/span&gt; &lt;span class="k"&gt;io&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="k"&gt;query&lt;/span&gt; &lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="n"&gt;上一步的Query_ID&lt;/span&gt;&lt;span class="err"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 63.71473354231975" data-width="813" data-height="638"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/0f37e83a461cfc5cea96d84f7d3b0432.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到开始，打开表，加载，关闭表，释放资源、记录日志，清理工作，在这儿可以看到一条SQL执行的完整生命周期。&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 116.45021645021644" data-width="1076" data-height="462"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/fd2db3d168cdcca999dc993c99807b29.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开发中需要注意的问题&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;show profile ... for query [Query_ID];&lt;/code&gt;出现了如下四个，则必须优化这条sql。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;converting HEAP to MyISAM&lt;/strong&gt; : 查询结果太大， 内存都不够用了，会往磁盘上搬了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Creating tmp table&lt;/strong&gt; : 创建临时表&lt;ol&gt;
&lt;li&gt;拷贝数据到临时表: 假设要查询两百万数据，刚好匹配的条件有一百万，恰巧要把这一百万的数据拷贝到临时表，然后再把数据推送给用户，最后再把临时表删掉，这种情况就是导致SQL变慢的罪魁祸首&lt;/li&gt;
&lt;li&gt;用完再删除&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Copying to tmp table on disk&lt;/strong&gt; : 把内存中临时表复制到磁盘&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;locked&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;MySQL查询优化(4)-全局查询日志&lt;/h1&gt;
&lt;p&gt;show profile可以帮记录下来了后台执行过得SQL，全局查询日志有时也能帮助来调SQL。但是，切记，这个全局查询日志只能在&lt;strong&gt;测试环境&lt;/strong&gt;使用，绝不可以在生产环境使用（公司中一般都是生产环境、测试环境分离，但是测试环境一般都不如生产环境，或多或少会有些差距，但是大部分的SQL正常来说在部到生产之前会在测试上先跑一遍甚至几遍）。&lt;/p&gt;
&lt;p&gt;切记：&lt;strong&gt;永远不要再生产环境开启全局查询日志这个功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;配置方式启用:&lt;/p&gt;
&lt;p&gt;在MySQL的配置文件中，配置如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#开启&lt;/span&gt;
&lt;span class="n"&gt;general_log&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="c1"&gt;#记录日志文件的路径&lt;/span&gt;
&lt;span class="n"&gt;general_log_file&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="k"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;logfile&lt;/span&gt;
&lt;span class="c1"&gt;#输出格式&lt;/span&gt;
&lt;span class="n"&gt;log_output&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令方式启用:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;general_log&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;#开启后会把所有的SQL进行记录&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="k"&gt;global&lt;/span&gt; &lt;span class="n"&gt;log_output&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;TABLE&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此后所编写的SQL语句，将会记录到MySQL库里的general_log表，可以用下面的命令查看。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;general_log&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要做系统的定案分析(如：今天下午2点-3点出现的故障），如果要观察和复现的话，可以在测试环境下模拟一遍，然后把所有的问题复现一下。&lt;/p&gt;
&lt;p&gt;然后用&lt;code&gt;general_log&lt;/code&gt;这个表来查看什么时间段发生了什么样的SQL，帮助定位问题。&lt;/p&gt;
&lt;h1&gt;MySQL锁机制&lt;/h1&gt;
&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;锁是计算机协调多个进程或线程并发访问某一资源的机制(说白了就是防止争抢)。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;打个比方，在淘宝上买一件商品，商品只有一个库存，这个时候如果还有另一个人购买，那么如何解决是你买到还是另一个人买到的问题？
这里肯定要用到事务，先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量，在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用意外，数据也是一种供 许多用户共享的资源，如何保证数据并发访问的一致性，有效性是所有数据库必须解决的一个问题。锁充足也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言闲的尤其重要，也更加复杂。&lt;/p&gt;
&lt;h3&gt;锁的分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从对数据操作的类型（读/写）分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。&lt;/p&gt;
&lt;p&gt;写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。&lt;/p&gt;
&lt;p&gt;从对数据操作的粒度分(表锁、行锁)&lt;/p&gt;
&lt;p&gt;开销、加锁速度、死锁、粒度、并发性能，只能就具体应用的特点来说哪种锁更合适&lt;/p&gt;
&lt;h4&gt;1.表锁(偏读)&lt;/h4&gt;
&lt;p&gt;偏向MyISAM存储引擎，开销小，加锁块；无死锁；锁定颗粒大，发生锁冲突的概率最高，并发度最低。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;开玩笑的说，早上来上班你第一个来的， 到公司就把大门给锁住了，把门禁电关了，整个公司现在你一个人独享，别人还能跟你冲突吗，并发度也就最低了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;1.案例分析(加读锁)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;建表SQL&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;mylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="n"&gt;nul&lt;/span&gt; &lt;span class="k"&gt;primary&lt;/span&gt; &lt;span class="k"&gt;key&lt;/span&gt; &lt;span class="k"&gt;auto_increment&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;name&lt;/span&gt; &lt;span class="kt"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="k"&gt;engine&lt;/span&gt; &lt;span class="n"&gt;myisam&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;mylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;mylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;mylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;mylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;mylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;values&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;mylock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加锁和解锁命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;lock&lt;/span&gt; &lt;span class="k"&gt;table&lt;/span&gt; &lt;span class="n"&gt;表名1&lt;/span&gt; &lt;span class="k"&gt;read&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="k"&gt;write&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;表名2&lt;/span&gt; &lt;span class="k"&gt;read&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="k"&gt;write&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;#加锁&lt;/span&gt;
&lt;span class="k"&gt;unlock&lt;/span&gt; &lt;span class="k"&gt;tables&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;#解锁&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;加读锁(共享锁)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;lock table mylock read;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看表上的锁：&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/show-open-tables.html"&gt;官方文档-show open tables&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;show&lt;/span&gt; &lt;span class="k"&gt;open&lt;/span&gt; &lt;span class="k"&gt;tables&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 95.87155963302752" data-width="1045" data-height="545"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/d529183b04f1a2dda47c410d3d24078f.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 74.14500683994528" data-width="1084" data-height="731"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/68e216909f4ecd38f85861d7f1ddbe9a.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加读锁后，读取自己可以，写自己以及读取本库中别的表都不可以，言下之意就是只要加了读锁，就必须要把这笔读的账清掉再去做别的事&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(窗口1)获得表mylock的read锁定时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前session(窗口1)可以进行查看该表记录操作；其它session也可查该表记录&lt;/li&gt;
&lt;li&gt;当前session不能查看其它没有锁定的表(账没结)；其它session可以查询或更新其它非锁定的表&lt;/li&gt;
&lt;li&gt;当前session插入或更新锁定表都会提示报错；其它session插入或更新锁定表都会一直阻塞等待获取表&lt;/li&gt;
&lt;li&gt;当前session释放读锁时，其它session获得锁，执行插入或更新完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;2.案例分析2(加写锁)&lt;/h5&gt;
&lt;p&gt;当session1(窗口1)获得表mylock的write锁定时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前session1对锁定都得表进行查询、更新操作都可以执行，其它session对锁定表的查询(更新操作也一样)被阻塞，需要等待锁被释放。（如果可以，请换成不同的id来进行测试，因为mysq有缓存，查询的多了，第二次的条件会从缓存获得，会影响锁效果演示）&lt;/li&gt;
&lt;li&gt;当前sesison1释放锁，其它session获得锁，查询返回。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;案例结论&lt;/h5&gt;
&lt;p&gt;MyISAM在执行查询(SELECT)前，会自动给涉及查询(SELECT)的所有表加读锁，在执行增删改操作前，会自动给涉及增删改操作的表加写锁。&lt;/p&gt;
&lt;p&gt;MySQL的表级结构有两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;表共享读锁（Table Read Lock）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;表独占写锁（Table Write Lock）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 395.29411764705884" data-width="672" data-height="85"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e15df19d0008aa6cbdad8fd469b58df0.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;对MyISAM引擎的表进行操作，会有以下情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对MyISAM表的读操作（加读锁），不会影响其他进行对同一表的读操作，但会阻塞同一表的写操作，只有当读锁释放后，才会执行其它进程的写操作。&lt;/li&gt;
&lt;li&gt;对MyISAM表的写操作（加写锁），会阻塞其它进行对统一读和写操作，只有当锁释放后，才会执行其它进程的读写操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简而简之，就是：&lt;strong&gt;读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;如何分析表锁定&lt;/p&gt;
&lt;p&gt;可以通过查看&lt;code&gt;table_locks_waited&lt;/code&gt;和&lt;code&gt;table_locks_immediate&lt;/code&gt;状态变量来分析系统上的表锁定。&lt;/p&gt;
&lt;p&gt;SQL：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;show&lt;/span&gt; &lt;span class="k"&gt;status&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;table%&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里会有几个变量来记录MySQL内部表级锁定的情况，其中最重要的两个变量说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Table_locks_immediate&lt;/code&gt;：产生表级锁定的次数，表示可以立即获取所的查询次数，每立即获取锁值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Table_locks_waited&lt;/code&gt;：出现表级锁定征用而发生等待的次数（不能立即获取所的次数，每等待一次锁值加1），此值高则说明存在着较严重的表级锁征用情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，MyISAM的读写锁调度是写优先，所以MyISAM不适合做写为主的表的引擎，因为加写锁后，其它线程不能做任何操作，大量的更新会使查询难得到锁，从而造成永远阻塞。&lt;/p&gt;
&lt;h4&gt;2.行锁(偏写)&lt;/h4&gt;
&lt;p&gt;行锁(偏向InnoDB存储引擎，开销大， 加锁慢，会出现死锁；锁定粒度最小，发生锁冲突的概率最低（假设100行，你用45行我用78行，两者无交集），并发度也最高。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;InnoDB与MyISAM的最大不同的两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持事务(TRANSACTION)；&lt;/li&gt;
&lt;li&gt;采用了行级锁；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;回顾：&lt;/p&gt;
&lt;p&gt;事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;原子性（Atomicity)：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一致性(Consistent)：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;隔离性（lsolation)：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。&lt;/li&gt;
&lt;li&gt;持久性(Durable)：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并发事务处理带来的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;更新丢失(Lost Update)：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新&lt;strong&gt;覆盖了由其他事务所做的更新&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;脏读(Dirty Reads)：事务A读取到了事务B&lt;strong&gt;已修改但尚未提交&lt;/strong&gt;的的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不可重复读(Non-Repeatable Reads)：事务A读取到了&lt;strong&gt;事务B已经提交的修改数据&lt;/strong&gt;，不符合隔离性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;幻读(Phantom Reads)：事务A读取到了&lt;strong&gt;事务B提交的新增数据&lt;/strong&gt;，不符合隔离性。&lt;/p&gt;
&lt;p&gt;脏读是事务B里面修改了数据，幻读是事务B里面新增了数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;事务隔离级别：&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 125.10917030567686" data-width="1719" data-height="687"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/8078334147c880fb78f8beb8b2f69c5c.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;案例分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建表SQL&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;TABLE&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
  &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;varchar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;ENGINE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;InnoDB&lt;/span&gt; &lt;span class="k"&gt;DEFAULT&lt;/span&gt; &lt;span class="k"&gt;CHARSET&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;utf8&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;4000&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;5000&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;6000&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;7000&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;8000&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;9000&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;insert&lt;/span&gt; &lt;span class="k"&gt;into&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt; &lt;span class="n"&gt;valeus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;b1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;index&lt;/span&gt; &lt;span class="n"&gt;test_innodb_a_ind&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;create&lt;/span&gt; &lt;span class="k"&gt;index&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock_b_ind&lt;/span&gt; &lt;span class="k"&gt;on&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;select&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;from&lt;/span&gt; &lt;span class="n"&gt;test_innodb_lock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;行锁演示&lt;/p&gt;
&lt;p&gt;MySQL5.5以后默认存储引擎为InnoDB，MySQL默认的数据提交操作模式是自动提交模式（autocommit），这就表示除非显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;show&lt;/span&gt; &lt;span class="k"&gt;variables&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;autocommit&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;#查看自动提交状态&lt;/span&gt;
&lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="n"&gt;autocommit&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;#关闭自动提交&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建两个会话，先关闭 autocommit；（&lt;code&gt;set autocommit=0&lt;/code&gt;）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;session1执行更新操作，没有手写commit；session2执行同一行数据的更新操作，会被阻塞。&lt;/li&gt;
&lt;li&gt;session1提交commit更新；session2解除阻塞，更新正常进行。&lt;/li&gt;
&lt;li&gt;session1与session2执行不同行的更新操作时，互不影响，不会发生等待阻塞情况&lt;/li&gt;
&lt;li&gt;两者提交，数据显示正常。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;索引失效行锁变表锁&lt;/h5&gt;
&lt;p&gt;首先知道如果索引失效的情况下，那么肯定会导致索引失效，但是如果使用不当，会导致行锁变成表锁。&lt;/p&gt;
&lt;p&gt;上文中数据库的存储引擎为InnoDB，并且关闭了自动提交，在创建表的时候创建了两个索引，分别在表中的a和b字段上建立了两个单值索引。如下&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 343.2835820895522" data-width="920" data-height="134"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/4d0a25eceaffc5149116205f4108a8f4.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;看一下表信息&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 91.7624521072797" data-width="479" data-height="261"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/178aabaa1b71d9332ad765e341777baa.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其中，a为int型，b为varchar型&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上文中说过，两个会话去执行不同的记录各不相干不会导致阻塞状态。&lt;/p&gt;
&lt;p&gt;在讲索引优化的时候说过“var引号不能丢”，如果丢失，会导致索引失效。现在来模拟一下这种情况，上面说过b字段是varchar型，故意把它写错不加单引号。&lt;/p&gt;
&lt;p&gt;MySQL底层是做了类型转换的，但是由于“b”列是做了索引的的一列，自动做了类型转换之后导致类型失效，此时在会话1中修改之后，自己自娱自乐了一番，完全不管会话2受得了受不了发生了阻塞。此时执行commit。&lt;/p&gt;
&lt;p&gt;这种情况就是一个不小心就是，&lt;strong&gt;var没有加引号，导致索引失效，行锁边表锁。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有索引或者索引失效时，InnoDB 的行锁变表锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：Mysql 的行锁是通过索引实现的！&lt;/strong&gt;&lt;/p&gt;
&lt;h5&gt;间隙锁危害&lt;/h5&gt;
&lt;p&gt;当用&lt;strong&gt;范围条件&lt;/strong&gt;而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但不存在的记录，叫做&lt;strong&gt;“间隙(GAP)”&lt;/strong&gt;(宁可错杀不可放过，就算中间出现间隙，找不到指定的记录也会锁住)，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(NEXT-KEY)锁。&lt;/p&gt;
&lt;p&gt;间隙锁有一个比较致命的弱点，就是当锁定一个范围键值之后，即使某些不存在的键值也会被无辜的锁定，而造成在锁定的时候无法插入锁定值范围内的任何数据，在某些场景下这可能会针对性造成很大的危害。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;一般而言，为了云计算和大数据分析，数据最最好是连续的。每一个互联网公司的每一条数据都时很珍贵的，业务逻辑层所写的delete方法调用mapper层delete方法并没有从物理上把这条数据给切切实实的干掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在会话1中执行范围操作并未提交事务；会话2产生阻塞，暂时不能插入；&lt;/li&gt;
&lt;li&gt;会话1执行commit；会话2阻塞解除。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;行锁总结&lt;/h5&gt;
&lt;p&gt;InnoDB存储引擎由于事先了行级锁定，虽然在锁定机制的的实现方面，所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。&lt;/p&gt;
&lt;p&gt;但是，InnoDB的行级锁定同样也有其脆弱的一面，当使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能更差（就像前面说过的行锁可能变表锁）。&lt;/p&gt;
&lt;p&gt;行锁分析：&lt;/p&gt;
&lt;p&gt;通过检查 &lt;code&gt;InnoDB_row_lock&lt;/code&gt; 状态变量来分析系统上的行锁的争夺情况&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;show&lt;/span&gt; &lt;span class="k"&gt;status&lt;/span&gt; &lt;span class="k"&gt;like&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;innodb_row_lock%&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 109.5" data-width="438" data-height="200"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/943e40b7b9531d21af768ac39cd40b7c.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对各个状态量的说明如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Innodb_row_lock_current_waits：当前正在等待锁定的数量；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Innodb_row_lock_time：从系统启动到现在锁定总时间长度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Innodb_row_lock_time_avg：每次等待锁花费平均时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Innodb_row_lock_time_max：从系统启动到现在等待最长的一次说话的时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Innodb_row_lock_waits&lt;/strong&gt; ：&lt;strong&gt;启动系统后到现在总共等待的次数；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于5个状态变量，比较重要的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Innodb_row_lock_time_avg（等待锁的平均时长）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Innodb_row_lock_waits （等待总次数）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Innodb_row_lock_time（等待总时长）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尤其是当等待次数越高，而且每次等待时长也不小的时候，就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化建议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽可能在所有数据检索都通过索引来完成，避免无索引行锁升级为表锁&lt;/li&gt;
&lt;li&gt;合理设计索引，尽量缩小锁的范围&lt;/li&gt;
&lt;li&gt;尽可能较少检索条件，避免间隙锁&lt;/li&gt;
&lt;li&gt;尽量控制事务大小，减少锁定资源量和时间长度&lt;/li&gt;
&lt;li&gt;尽可能低级别事务隔离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;如何锁定一行？&lt;/p&gt;
&lt;p&gt;在SQL语句后面加上&lt;code&gt;for update&lt;/code&gt;，直到锁定行的会话提交commit。&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item"  data-width="-1" data-height="-1" size-undefined&gt;&lt;img src="C:\Users\Xuxx3309\AppData\Roaming\Typora\typora-user-images\1599154742368.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;3.页锁&lt;/h4&gt;
&lt;p&gt;开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。&lt;/p&gt;
&lt;h1&gt;MySQL主从复制&lt;/h1&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。&lt;/p&gt;
&lt;h3&gt;主要用途&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;读写分离
在开发工作中，有时候会遇见某个sql 语句需要锁表，导致暂时不能使用读的服务，这样就会影响现有业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。&lt;/li&gt;
&lt;li&gt;数据实时备份，当系统中某个节点发生故障时，可以方便的故障切换&lt;/li&gt;
&lt;li&gt;高可用HA&lt;/li&gt;
&lt;li&gt;架构扩展
随着系统中业务访问量的增大，如果是单机部署数据库，就会导致I/O访问频率过高。有了主从复制，增加多个数据存储节点，将负载分布在多个从节点上，降低单机磁盘I/O访问的频率，提高单个机器的I/O性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基本原理&lt;/h3&gt;
&lt;p&gt;slave会从master读取binlog来进行数据同步。&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 92.0343137254902" data-width="751" data-height="408"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/6c1dd0f7705093ffea629d7b36b16ecb.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;三步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;master将改变记录到二进制日志(binary log）。这些记录过程叫做二进制日志事件，binary log events;&lt;/li&gt;
&lt;li&gt;slave将master的binary log events拷贝到它的中继日志（relay log） ;&lt;/li&gt;
&lt;li&gt;slave重做中继日志中的事件，将改变应用到自己的数据库中。MySQL复制是异步的且串行化的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;基本原则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每个slave只有一个master&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个slave只能有一个唯一的服务器ID&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个master可以有多个salve&lt;/p&gt;
&lt;p&gt;复制的最大问题是&lt;strong&gt;延迟&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;一主一从常见配置&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.bilibili.com/video/BV12b411K7Zu?p=241"&gt;参考&lt;/a&gt;&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj27/</guid><pubDate>Thu, 27 Aug 2020 16:50:00 +0806</pubDate></item><item><title>图解 Java 内存模型</title><link>/Xuxx_Blogs/archives/bj28/</link><description>&lt;p&gt;&lt;a href="http://mp.weixin.qq.com/s?__biz=MzUxOTc4NjEyMw==&amp;amp;mid=2247492802&amp;amp;idx=3&amp;amp;sn=20c345eba118d855b950991306af37fe&amp;amp;chksm=f9f6ff26ce817630dbdf18969226aa04db78fc9171b08365ba071074c42afaa5874ec0970cf2&amp;amp;mpshare=1&amp;amp;scene=23&amp;amp;srcid=09054ZHbGeWMRAhwVgNKdEEl&amp;amp;sharer_sharetime=1599315785410&amp;amp;sharer_shareid=0581665d51df24ce3ec1b889fd40265c#rd"&gt;转自&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;1. 内存模型 &amp;amp; 分区&lt;/h2&gt;
&lt;p&gt;Java虚拟机在运行Java程序时，会管理着一块内存区域：运行时数据区&lt;/p&gt;
&lt;p&gt;在运行时数据区里，会根据用途进行划分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java虚拟机栈（栈区）&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;li&gt;Java堆（堆区）&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 86.24454148471615" data-width="790" data-height="458"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/ab0aba19931485908a0e6986f22e7d1f.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;2. Java堆&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.04761904761905" data-width="790" data-height="420"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/487027ef1610070e35b274bfc597037a.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 80.4769001490313" data-width="1080" data-height="671"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/4d0c4e9e3d03dadd2f3df73af439d755.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java堆是垃级收集器管理的主要区域，因此被称为:"GC堆";&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从内存回收的角度可分为:新生代&amp;amp;老年代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新生代可细分:Eden 空间、From Survivor 空间、To Survivor 空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从内存分配的角度:多个线程私有的分配缓冲区&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. Java虚拟机栈&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 100.76530612244898" data-width="790" data-height="392"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/f9d472efe072ac386040d10f37f9ff36.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 67.9245283018868" data-width="1080" data-height="795"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/14e19ff71547c592ddf03ff4e9b7013b.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;4. 本地方法栈&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.04761904761905" data-width="790" data-height="420"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e38a2647ca57500b88226672a2abaf4c.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;备注：&lt;/p&gt;
&lt;p&gt;本地方法栈十分类似Java虚拟机栈&lt;/p&gt;
&lt;p&gt;与Java虚拟机区别在于：服务对象，即：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java虚拟机栈为执行 Java 方法服务；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地方法栈为执行 Native方法服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. 方法区&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.04761904761905" data-width="790" data-height="420"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/64fd88018fefac462c98db246aab8783.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 75.9493670886076" data-width="1080" data-height="711"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/7b628f86eabe274d724f93c151cc5c95.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注：其内部包含一个&lt;strong&gt;运行时常量池&lt;/strong&gt;，具体介绍如下：&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 82.82208588957056" data-width="1080" data-height="652"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/0e18c57c5acb2dd873c57e8554edb0b9.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;6. 程序计数器&lt;/h2&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 94.04761904761905" data-width="790" data-height="420"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/53d8ad5573475c282b00bc5255f099d0.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 65.77344701583435" data-width="1080" data-height="821"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/d4ebaabf8c2de348e19dd956487fc5ec.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;7. 额外知识：直接内存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定义：NIO类（JDK1.4引入）中基于通道和缓冲区的I/O方式 通过使用Native函数库 直接分配 的堆外内存&lt;/li&gt;
&lt;li&gt;特点：不受堆大小限制&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;p&gt;不属于虚拟机运行时数据区的一部分 &amp;amp; 不在堆中分配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;应用场景：适用于频繁调用的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;&lt;p&gt;通过一个 存储在Java堆中的DirectByteBuffer对象 作为这块内存的引用 进行操作，从而避免在 Java 堆和 Native堆之间来回复制数据，提高使用性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;抛出的异常：OutOfMemoryError，即与其他内存区域的总和 大于 物理内存限制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;8. 总结&lt;/h2&gt;
&lt;p&gt;本文全面讲解JVM中的内存模型 &amp;amp; 分区，总结如下&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 144.0" data-width="1080" data-height="375"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/10936d10647a2b939c1bd64c8f774d6b.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj28/</guid><pubDate>Sat, 05 Sep 2020 21:50:00 +0806</pubDate></item><item><title>Liunx基础</title><link>/Xuxx_Blogs/archives/bj29/</link><description>&lt;h1&gt;Liunx目录管理&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/root&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;根目录，万物起源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;strong&gt;boot&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），和启动加载程序 &lt;strong&gt;有趣的文件&lt;/strong&gt;： /boot/grub/grub.conf or menu.lst，被用来配置启动；加载程序 /boot/vmlinuz， Linux 内核&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/bin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;包含系统启动和运行所必须的二进制程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/sbin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/usr&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。usr (unix software resource | unix 软件资源)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/usr/bin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统用户使用的应用程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/usr/sbin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;超级用户使用的比较高级的管理程序和系统守护程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/usr/src&lt;/td&gt;
&lt;td&gt;内核源代码默认的放置目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/proc&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统内存的映射目录，提供内核与进程信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/lost+found&lt;/td&gt;
&lt;td&gt;一般情况下是空的，当系统非法关机后，这里就存放了一些文件，文件系统恢复时的恢复文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/var&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。存放邮件、系统日志等变化文件，存放系统或程序运行过程中的数据文件(variable)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/tmp&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这个目录是用来存放一些临时文件的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/etc&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;存放系统配置文件。它也包含一系列的 shell 脚本，在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。  &lt;code&gt;/etc/crontab&lt;/code&gt;，定义自动运行的任务。 &lt;code&gt;/etc/fstab&lt;/code&gt;，包含存储设备的列表，以及与他们相关的 挂载点。 &lt;code&gt;/etc/passwd&lt;/code&gt;，包含用户帐号列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/home&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;用户主目录，在通常的配置环境下，系统会在 /home 下，给每个用户分配一个目录。普通只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/dev&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这是一个包含设备结点的特殊目录。“一切都是文件”，也使用于设备。在这个目录里，内核维护着它支持的设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/lib&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;动态连接共享库，&lt;code&gt;.so&lt;/code&gt; 文件，类似于 Windows 里的 dll 文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/mnt&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;/media&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;系统会自动识别一些设备，例如 U 盘、光驱等等，把识别的设备挂载到这个目录下。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/sys&lt;/td&gt;
&lt;td&gt;sys 虚拟文件系统挂载点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/srv&lt;/td&gt;
&lt;td&gt;存放服务相关数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/opt&lt;/td&gt;
&lt;td&gt;这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/srv&lt;/td&gt;
&lt;td&gt;该目录存放一些服务启动之后需要提取的数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/selinux&lt;/td&gt;
&lt;td&gt;这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux 相关的文件的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;操作文件目录&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;常用选项说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ls&lt;/td&gt;
&lt;td&gt;显示文件和目录列表&lt;/td&gt;
&lt;td&gt;ls [选项] [dest]&lt;/td&gt;
&lt;td&gt;-a：列出目录下的所有文件，包含.开头的隐藏文件&lt;br/&gt;-l：列出文件的详细信息&lt;br/&gt;-h：以容易读取的方式显示文件大小&lt;br/&gt;-d：仅列出目录本身，而不显示目录中的文件&lt;br/&gt;-t：按照时间顺序排序，时间越早越早下面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mkdir&lt;/td&gt;
&lt;td&gt;创建目录&lt;/td&gt;
&lt;td&gt;mkdir [-选项] dest&lt;/td&gt;
&lt;td&gt;-p 创建多级目录（跨级创建）&lt;br/&gt;-v 查看目录创建的过程（创建目录可视化）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rmdir&lt;/td&gt;
&lt;td&gt;仅删除空白目录&lt;/td&gt;
&lt;td&gt;rmdir dest&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cd&lt;/td&gt;
&lt;td&gt;切换目录&lt;/td&gt;
&lt;td&gt;cd dest&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;touch&lt;/td&gt;
&lt;td&gt;生成一个空文件&lt;/td&gt;
&lt;td&gt;touch dest&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;echo&lt;/td&gt;
&lt;td&gt;生成一个带内容的文件&lt;/td&gt;
&lt;td&gt;echo 内容 &amp;gt; dest&lt;/td&gt;
&lt;td&gt;-e：激活转义字符&lt;br/&gt;&amp;gt;：复写&lt;br/&gt;&amp;gt;&amp;gt;：追加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cat&lt;/td&gt;
&lt;td&gt;显示文本文件内容&lt;/td&gt;
&lt;td&gt;cat [-选项] dest&lt;/td&gt;
&lt;td&gt;-n：有1开始对所有输出的行数编号；&lt;br/&gt;-b：和-n相似，只不过对于空白行不编号；&lt;br/&gt;-s：当遇到有连续两行以上的空白行，就代换为一行的空白行；&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cp&lt;/td&gt;
&lt;td&gt;复制文件或目录&lt;/td&gt;
&lt;td&gt;cp [-选项] source  dest&lt;/td&gt;
&lt;td&gt;-a：此参数的效果和同时指定"-dpR"参数相同； &lt;br/&gt;-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；&lt;br/&gt;-f：强行复制文件或目录，不论目标文件或目录是否已存在； &lt;br/&gt;-i：覆盖既有文件之前先询问用户； &lt;br/&gt;-l：对源文件建立硬连接，而非复制文件； &lt;br/&gt;-p：保留源文件或目录的属性； &lt;br/&gt;-R/r：递归处理，将指定目录下的所有文件与子目录一并处理； &lt;br/&gt;-s：对源文件建立符号连接，而非复制文件； &lt;br/&gt;-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； &lt;br/&gt;-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀； &lt;br/&gt;-b：覆盖已存在的文件目标前将目标文件备份； &lt;br/&gt;-v：详细显示命令执行的操作。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rm&lt;/td&gt;
&lt;td&gt;删除文件或目录&lt;/td&gt;
&lt;td&gt;rm [选项] dest&lt;/td&gt;
&lt;td&gt;-f：强制删除文件或目录； &lt;br/&gt;-i：删除已有文件或目录之前先询问用户； &lt;br/&gt;-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理； &lt;br/&gt;-v：显示指令的详细执行过程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mv&lt;/td&gt;
&lt;td&gt;移动/重命名文件或目录&lt;/td&gt;
&lt;td&gt;mv [选项] dest&lt;/td&gt;
&lt;td&gt;常用：mv 文件名或目录  目标目录&lt;br/&gt;mv a.txt ../    将a文件移动到上级目录（将一个文件移动到另一个目录没有重命名）&lt;br/&gt;mv a.txt  ../b.txt   将a文件移动到上一级并改名为b文件（将一个文件移动到另一个目录并重命名）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;find&lt;/td&gt;
&lt;td&gt;查找文件&lt;/td&gt;
&lt;td&gt;find [选项] [起始目录] dest&lt;/td&gt;
&lt;td&gt;常用选项有：&lt;br/&gt;find  . -name *.log    在当前目录查找以.log结尾的文件&lt;br/&gt;find  / -name  log   在根目录查找log命名的目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;grep&lt;/td&gt;
&lt;td&gt;在指定文件中查找字符（串）并打印该行&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;用法：grep  字符串 文件名&lt;br/&gt;grep 123 fileName  在file文件中寻找字符串123&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tree&lt;/td&gt;
&lt;td&gt;用于以树状图列出目录内容&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;td&gt;显示当前工作目录&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ln&lt;/td&gt;
&lt;td&gt;为文件创件连接&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;more&lt;/td&gt;
&lt;td&gt;分屏/页显示文本文件内容&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;切换至下一屏：空格键 &lt;br/&gt;切换至上一屏：Ctrl+B&lt;br/&gt;查看文档的总行数，使用命令：wc -l&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;head&lt;/td&gt;
&lt;td&gt;显示文件开头的内容&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tail&lt;/td&gt;
&lt;td&gt;显示文件结尾的内容&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;压缩/解压缩&lt;/h2&gt;
&lt;h3&gt;tar&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;tar命令&lt;/strong&gt;可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。&lt;/p&gt;
&lt;p&gt;首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。&lt;/p&gt;
&lt;p&gt;为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（&lt;code&gt;gzip&lt;/code&gt; &lt;code&gt;bzip2&lt;/code&gt;)命令）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：tar  [选项]   打包后文档的名称   欲打包的目录&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-c：打包&lt;/li&gt;
&lt;li&gt;-x：解包&lt;/li&gt;
&lt;li&gt;-z：通过gzip指令处理备份文件&lt;/li&gt;
&lt;li&gt;-j：支持bzip2解压文件&lt;/li&gt;
&lt;li&gt;-v：显示操作过程&lt;/li&gt;
&lt;li&gt;-f：指定备份文件&lt;/li&gt;
&lt;li&gt;-t：列出备份文件的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;将文件全部打包成tar包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tar -cvf log.tar log2012.log    仅打包，不压缩
tar -czvf log.tar.gz log2012.log   打包后，以 gzip 压缩 
tar -cjvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在选项&lt;code&gt;f&lt;/code&gt;之后的文件档名是自己取的，习惯上都用 .tar 来作为辨识。 如果加&lt;code&gt;z&lt;/code&gt;选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加&lt;code&gt;j&lt;/code&gt;选项，则以.tar.bz2来作为tar包名。&lt;/p&gt;
&lt;p&gt;将tar包解压缩：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;tar -xzvf ./log.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;gzip&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;gzip命令&lt;/strong&gt;用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。&lt;/p&gt;
&lt;p&gt;gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和&lt;code&gt;tar&lt;/code&gt;命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：gzip  [选项]     [欲打包的目录]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选项&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-d或--decompress或----uncompress 　解开压缩文件。&lt;/li&gt;
&lt;li&gt;-f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。&lt;/li&gt;
&lt;li&gt;-h或--help 　在线帮助。&lt;/li&gt;
&lt;li&gt;-l或--list 　列出压缩文件的相关信息。&lt;/li&gt;
&lt;li&gt;-q或--quiet 　不显示警告信息。&lt;/li&gt;
&lt;li&gt;-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。&lt;/li&gt;
&lt;li&gt;-t或--test 　测试压缩文件是否正确无误。&lt;/li&gt;
&lt;li&gt;-v或--verbose 　显示指令执行过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;把当前目录下的每个文件压缩成.gz文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把上例中每个压缩的文件解压，并列出详细的信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip -dv *
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细显示例1中每个压缩的文件的信息，并不解压&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzip -l *&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;压缩一个tar备份文件，此时压缩文件的扩展名为 .tar.gz&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip -r log.tar
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归的压缩test目录&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip -rv &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;这样，所有test下面的文件都变成了 .gz，目录依然存在，只是目录里面的文件相应变成了 .gz，这就是压缩，和打包不同。因为是对目录操作，所以需要加上 -r 选项，这样也可以对子目录进行递归了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;递归地解压目录&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gzip -dr &lt;span class="nb"&gt;test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;bzip2&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;bzip2命令&lt;/strong&gt;用于创建和管理（包括解压缩）“.bz2”格式的压缩包。&lt;/p&gt;
&lt;h1&gt;Liunx系统管理&lt;/h1&gt;
&lt;h2&gt;系统管理命令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;stat&lt;/td&gt;
&lt;td&gt;显示指定文件的相关信息,比&lt;code&gt;Is&lt;/code&gt;命令显示内容更多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;who&lt;/td&gt;
&lt;td&gt;显示在线登录用户&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hostname&lt;/td&gt;
&lt;td&gt;显示主机名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;uname&lt;/td&gt;
&lt;td&gt;显示系统信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;top&lt;/td&gt;
&lt;td&gt;显示当前系统中耗费资源最多的进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ps&lt;/td&gt;
&lt;td&gt;显示瞬间的进程状态（-A|e：显示所有程序。）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;du&lt;/td&gt;
&lt;td&gt;显示指定的文件(目录)当前已使用的磁盘空间的总量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;df&lt;/td&gt;
&lt;td&gt;显示文件系统磁盘空间的使用情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;free&lt;/td&gt;
&lt;td&gt;显示当前内存和交换空间的使用情况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ifconfig&lt;/td&gt;
&lt;td&gt;显示网络接口信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ping&lt;/td&gt;
&lt;td&gt;测试网络的连通性(心跳检测)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;netstat&lt;/td&gt;
&lt;td&gt;显示网络状态信息(可以查看端口)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clear&lt;/td&gt;
&lt;td&gt;清屏&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;kill&lt;/td&gt;
&lt;td&gt;杀死一个进程(-9：强制终止)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;开关机命令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;shutdown 命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序&lt;/li&gt;
&lt;li&gt;shutdown 也可以用来重开机。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;语法&lt;/th&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;参数说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;shutdown&lt;/td&gt;
&lt;td&gt;shutdown [-t seconds] [-rkhncfF] time [message]&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-t seconds&lt;/td&gt;
&lt;td&gt;设定在几秒钟之后进行关机程序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;并不会真的关机，只是将警告讯息传送给所有只用者&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;关机后重新开机（重启）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-h&lt;/td&gt;
&lt;td&gt;关机后停机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;取消目前已经进行中的关机动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;关机时，不做 fcsk 动作(检查 Linux 档系统)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;-F&lt;/td&gt;
&lt;td&gt;关机时，强迫进行 fsck 动作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;time&lt;/td&gt;
&lt;td&gt;设定关机的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;传送给所有使用者的警告讯息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;重启&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;reboot&lt;/p&gt;
&lt;p&gt;sudo：提权，以其他身份来执行命令，预设的身份为 root&lt;/p&gt;
&lt;p&gt;reboot提示没有权限时使用：sudo reboot&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;shutdown -r now&lt;/p&gt;
&lt;p&gt;同上，加 sudo&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关机&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shutdown -h now&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Vim编辑器&lt;/h1&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;Vim是从vi发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。&lt;/p&gt;
&lt;p&gt;简单的来说，vi是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。Vim则可以说是程序开发者的一项很好用的工具。&lt;/p&gt;
&lt;h2&gt;运行模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编辑模式：等待编辑命令输入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;插入模式：编辑模式下，输入&lt;code&gt;i&lt;/code&gt;进入插入模式，插入文本信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令模式：在编辑模式下，输入&lt;code&gt;:&lt;/code&gt;进行命令模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;命令模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:q&lt;/code&gt;：退出vim&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq&lt;/code&gt;：保存后退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:q!&lt;/code&gt;：强制退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:wq!&lt;/code&gt;：强制保存后退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:w file&lt;/code&gt;：将当前内容保存成某个文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt;：查找字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set number&lt;/code&gt;：显示行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set nonumber&lt;/code&gt;：不显示行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set paste&lt;/code&gt;：开启原样粘贴&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Liunx文件和目录访问权限设置&lt;/h1&gt;
&lt;p&gt;Linux用 户分为：拥有者(owner)、组群(group)、其他(other)，Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信息， 都是记录在&lt;code&gt;/etc/passwd&lt;/code&gt;文件中。每个用户的密码则是记录在&lt;code&gt;/etc/shadow&lt;/code&gt;文件下。 此外，所有的组群名称记录在&lt;code&gt;/etc/group&lt;/code&gt;內。&lt;/p&gt;
&lt;p&gt;Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 59.642147117296226" data-width="600" data-height="503"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/0f631055251b1aade9ed18c81c4788db.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;权限数字对应权限组说明：&lt;/p&gt;
&lt;p&gt;总共分为4部分&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;文件或文件夹&lt;/th&gt;
&lt;th&gt;owner权限&lt;/th&gt;
&lt;th&gt;group权限&lt;/th&gt;
&lt;th&gt;others权限&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;文件是 - ，文件夹是 d&lt;/td&gt;
&lt;td&gt;r/w/x相加&lt;/td&gt;
&lt;td&gt;r/w/x相加&lt;/td&gt;
&lt;td&gt;r/w/x相加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;r(read)  可读 --  4；w(write) 可写   --   2；x(execute) 可执行   --  1；-  表示相应的权限还没有被授予&lt;/p&gt;
&lt;h2&gt;chown命令&lt;/h2&gt;
&lt;p&gt;chown是 change owner (改变所有者) 的意思，主要作用就是改变某个文件或目录的所有者和所属的组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;chown  [-R]  用户名称   文件或目录&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;chown  [-R]    用户名称   用户组名称   文件或目录&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;chmod命令&lt;/h2&gt;
&lt;p&gt;chmod命令用来变更文件或目录的权限。用户可以使用 chmod 命令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。&lt;/p&gt;
&lt;h3&gt;语法&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;chmod &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;操作对象&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;操作符合&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;mode&lt;span class="o"&gt;]&lt;/span&gt; 文件或目录
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作对象&lt;/p&gt;
&lt;p&gt;可以是以下字母的一个或者组合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;u：拥有者&lt;/li&gt;
&lt;li&gt;g：组&lt;/li&gt;
&lt;li&gt;o：其他&lt;/li&gt;
&lt;li&gt;a：所有用户(默认)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;操作符合&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;+：表示添加某个权限&lt;/li&gt;
&lt;li&gt;-：表示取消某个权限&lt;/li&gt;
&lt;li&gt;=：赋予给定的权限，覆盖文件/目录原有的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;mode&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r 表示可读取&lt;/li&gt;
&lt;li&gt;w 表示可写入&lt;/li&gt;
&lt;li&gt;x 表示可执行&lt;/li&gt;
&lt;li&gt;X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数字设定法&lt;/h3&gt;
&lt;p&gt;数字设定法中数字表示的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 表示没有任何权限&lt;/li&gt;
&lt;li&gt;1 表示有可执行权限 = x&lt;/li&gt;
&lt;li&gt;2 表示有可写权限 = w&lt;/li&gt;
&lt;li&gt;4 表示有可读权限 = r&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也可以用数字来表示权限如：&lt;code&gt;chmod 755 fileName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chmod u+x file                　　　   给file的属主增加执行权限&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod 751 file                　　　   给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod u=rwx,g=rx,o=x file         上例的另一种形式&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod =r file                 　　　　为所有用户分配读权限&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod 444 file              　　　   同上例&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod a-wx,a+r   file   　　 　    同上例&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;chmod -R u+r directory       　    递归地给directory目录下所有文件和子目录的属主分配读的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;附: centos防火墙基本使用&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;启动： systemctl start firewalld  
关闭： systemctl stop firewalld  
查看状态： systemctl status firewalld   
开机禁用： systemctl disable firewalld  
开机启用： systemctl enable firewalld&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://frank-lam.github.io/fullstack-tutorial/#/Linux"&gt;学习指南&lt;/a&gt;&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj29/</guid><pubDate>Tue, 15 Sep 2020 15:30:00 +0806</pubDate></item><item><title>Docker基础</title><link>/Xuxx_Blogs/archives/bj30/</link><description>&lt;h1&gt;Docker概述&lt;/h1&gt;
&lt;h3&gt;Docker是什么？&lt;/h3&gt;
&lt;p&gt;Docker是Docker.Lnc公司开源的一个基于LXC技术之上搭建的 Container 容器引擎，源代码托管在Github上，使用 Google 公司的 Go 语言，基于Go语言并遵从Apache2.0协议开源。Docker将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了Docker，就不用担心环境问题。
总体来说，Docker的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;/p&gt;
&lt;p&gt;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;
&lt;p&gt;简单来说：Docker是一个虚拟环境容器，可以将你的开发环境、代码、配置文件等一并打包到这个容器中，并发布和应用到任意平台中。&lt;/p&gt;
&lt;h3&gt;Docker的设计理念和概念&lt;/h3&gt;
&lt;p&gt;docker设想是交付运行环境如同海运，OS如同一个货轮，每一个在OS基础上的软件都如同一个集装箱，用户可以通过标准化手段自由组装运行环境，同时集装箱的内容可以由用户自定义，也可以由专业人员制造。这样，交付一个软件，就是一系列标准化组件的集合的交付，如同乐高积木，用户只需要选择合适的积木组合，并且在最顶端署上自己的名字(最后一个标准化组件是用户的app)。这也就是基于 docker 的 PaaS 产品的原型。&lt;/p&gt;
&lt;p&gt;所以Docker的主要目标是“&lt;code&gt;Build，Ship and Run Any App,Anywhere&lt;/code&gt;(在任何地方构建、发布和运行任何应用程序)”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个Web应用或数据库应用等等）及其运行环境能够做到&lt;strong&gt;“一次封装，到处运行”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Docker是开发人员和系统管理员使用容器开发、部署和运行应用程序的平台。使用Linux容器来部署应用程序称为集装箱化。使用docker轻松部署应用程序。目前，Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），学习时用社区版就可以了。&lt;/p&gt;
&lt;h3&gt;Docker的组成&lt;/h3&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 97.50996015936255" data-width="979" data-height="502"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e039df4cc61e644108026a13e8852aae.png" alt="Docker组成" /&gt;&lt;figcaption&gt;Docker组成&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;镜像(image)：&lt;/h4&gt;
&lt;p&gt;Docker镜像就相当于是一个文件系统，通俗来说就是为容器用来创建容器的&lt;/p&gt;
&lt;h4&gt;容器(Container)：&lt;/h4&gt;
&lt;p&gt;Docker 利用容器 (Container) 独立运行的一个或一组应用，容器是用镜像创建的运行实例，它可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台，可以把容器看做是一个简易版的Linux系统&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器就相当于Java中的对象，镜像相当于Java中的类&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;仓库(Repository)&lt;/h4&gt;
&lt;p&gt;仓库是集中存放镜像文件的场所
仓库注册服务器 (Registry) 上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签 
仓库分为公开仓库和私有仓库两种形式
最大的公开仓库是&lt;a href="https://hub.docker.com"&gt;DockerHub&lt;/a&gt;存放了数量庞大的镜像供用户下载，国内的公开仓库包括阿里云等&lt;/p&gt;
&lt;h3&gt;Docker对比传统虚拟化方式的优势&lt;/h3&gt;
&lt;h4&gt;更高效的利用系统资源&lt;/h4&gt;
&lt;p&gt;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的&lt;/p&gt;
&lt;p&gt;主机，往往可以运行更多数量的应用。&lt;/p&gt;
&lt;h4&gt;一致的运行环境&lt;/h4&gt;
&lt;p&gt;开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些bug并未在开发过程中被发现。而Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现「&lt;strong&gt;这段代码在我机器上没问题啊&lt;/strong&gt;」这类问题。&lt;/p&gt;
&lt;h4&gt;更快速的启动时间&lt;/h4&gt;
&lt;p&gt;传统的虚拟机技术启动应用服务往往需要数分钟，而Docker容器应用，由于直接运行于宿主内核，无需启动完整&lt;/p&gt;
&lt;p&gt;的操作系统，因此可以做到种级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。&lt;/p&gt;
&lt;h4&gt;持续交付和部署&lt;/h4&gt;
&lt;p&gt;对开发和运维( DevOps ）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。&lt;/p&gt;
&lt;p&gt;使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfi1e来进行镜像构建，并结合 &lt;strong&gt;持续集成(Continuous Integration)&lt;/strong&gt; 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 &lt;strong&gt;持续部署(Continuous Delivery/Deployment)&lt;/strong&gt; 系统进行自动部署。&lt;/p&gt;
&lt;p&gt;而且使用 &lt;code&gt;Dockerfile&lt;/code&gt;使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。&lt;/p&gt;
&lt;h4&gt;更轻松的迁移&lt;/h4&gt;
&lt;p&gt;由于Docker确保了执行环境的一致性，使得应用的迁移更加容易。Docker可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。&lt;/p&gt;
&lt;h4&gt;更轻松的维护和扩展&lt;/h4&gt;
&lt;p&gt;Docker使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。&lt;/p&gt;
&lt;h4&gt;对比传统虚拟机总结&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;Docker&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;传统虚拟机&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;启动&lt;/td&gt;
&lt;td&gt;秒级&lt;/td&gt;
&lt;td&gt;分钟级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;硬盘使用&lt;/td&gt;
&lt;td&gt;一般为MB&lt;/td&gt;
&lt;td&gt;一般为GB&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;接近原生&lt;/td&gt;
&lt;td&gt;弱于原生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;上千个&lt;/td&gt;
&lt;td&gt;一般几十个&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;Docker的进程隔离&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 121.44846796657382" data-width="872" data-height="359"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/d8fb7b9df7e611067e2f927b22554f0a.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1&gt;Docker安装&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/u014069688/article/details/100532774"&gt;转自☞&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境：虚拟机装的Centos7，linux 3.10 内核&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;root账户登录，查看内核版本如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# uname -a&lt;/span&gt;
Linux localhost.localdomain &lt;span class="m"&gt;3&lt;/span&gt;.10.0-1062.12.1.el7.x86_64 &lt;span class="c1"&gt;#1 SMP Tue Feb 4 23:02:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把 yum 包更新到最新(非必须，方便小白)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum update&lt;/span&gt;
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: centos.ustc.edu.cn
 * extras: mirrors.aliyun.com
 * updates: mirrors.cn99.com
base                                                                                                  &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;.6 kB  &lt;span class="m"&gt;00&lt;/span&gt;:00:00     
extras                                                                                                &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;.4 kB  &lt;span class="m"&gt;00&lt;/span&gt;:00:00     
updates                                                                                               &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="m"&gt;3&lt;/span&gt;.4 kB  &lt;span class="m"&gt;00&lt;/span&gt;:00:00     
正在解决依赖关系
--&amp;gt; 正在检查事务
---&amp;gt; 软件包 NetworkManager.x86_64.1.1.12.0-6.el7 将被 升级
---&amp;gt; 软件包 NetworkManager.x86_64.1.1.12.0-10.el7_6 将被 更新
&lt;span class="c1"&gt;##（期间要选择确认，输入 y 即可）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum install -y yum-utils device-mapper-persistent-data lvm2&lt;/span&gt;
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: centos.ustc.edu.cn
 * extras: mirrors.aliyun.com
 * updates: mirrors.cn99.com
软件包 device-mapper-persistent-data-0.7.3-3.el7.x86_64 已安装并且是最新版本
软件包 &lt;span class="m"&gt;7&lt;/span&gt;:lvm2-2.02.180-10.el7_6.8.x86_64 已安装并且是最新版本
正在解决依赖关系
--&amp;gt; 正在检查事务
---&amp;gt; 软件包 yum-utils.noarch.0.1.1.31-50.el7 将被 安装
--&amp;gt; 正在处理依赖关系 python-kitchen，它被软件包 yum-utils-1.1.31-50.el7.noarch 需要
...
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补充：LVM是Logical Volume Manager（逻辑卷管理器）的简写，又译为逻辑卷宗管理器、逻辑扇区管理器、逻辑磁盘管理器。是Linux核心所提供的逻辑卷管理（Logical Volume Management）功能。它在硬盘的硬盘分区之上，又创建了一个逻辑层以方便系统管理硬盘分区系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置 yum 源（选择其中一个）&lt;/p&gt;
&lt;p&gt;yum-config-manager --add-repo &lt;a href="http://download.docker.com/linux/centos/docker-ce.repo（中央仓库）"&gt;http://download.docker.com/linux/centos/docker-ce.repo（中央仓库）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;yum-config-manager --add-repo &lt;a href="http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库）"&gt;http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo（阿里仓库）&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum-config-manager --add-repo &lt;/span&gt;
https://download.docker.com/linux/centos/docker-ce.repo
已加载插件：fastestmirror
adding repo from: https://download.docker.com/linux/centos/docker-ce.repo
grabbing file https://download.docker.com/linux/centos/docker-ce.repo to 
/etc/yum.repos.d/docker-ce.repo
repo saved to /etc/yum.repos.d/docker-ce.repo
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以查看所有仓库中所有docker版本，并选择特定版本安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum list docker-ce --showduplicates | sort -r&lt;/span&gt;
已加载插件：fastestmirror
可安装的软件包
 * updates: mirrors.cn99.com
Loading mirror speeds from cached hostfile
 * extras: mirrors.aliyun.com
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:19.03.2-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:19.03.1-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:19.03.0-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.8-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.7-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.6-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.5-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.4-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.3-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.2-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.1-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;3&lt;/span&gt;:18.09.0-3.el7                     docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.06.3.ce-3.el7                    docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.06.2.ce-3.el7                    docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.06.1.ce-3.el7                    docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.06.0.ce-3.el7                    docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.03.1.ce-1.el7.centos             docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;18&lt;/span&gt;.03.0.ce-1.el7.centos             docker-ce-stable
docker-ce.x86_64            &lt;span class="m"&gt;17&lt;/span&gt;.12.1.ce-1.el7.centos             docker-ce-stable
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装Docker，命令：&lt;code&gt;yum install docker-ce-版本号&lt;/code&gt;，我选的是&lt;code&gt;docker-ce-18.03.1.ce&lt;/code&gt;，如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# yum install docker-ce-18.03.1.ce&lt;/span&gt;
已加载插件：fastestmirror
Loading mirror speeds from cached hostfile
 * base: centos.ustc.edu.cn
 * extras: mirrors.aliyun.com
 * updates: mirrors.cn99.com
正在解决依赖关系
--&amp;gt; 正在检查事务
---&amp;gt; 软件包 docker-ce.x86_64.0.18.03.1.ce-1.el7.centos 将被 安装
&lt;span class="c1"&gt;##（期间要选择确认，输入 y 即可）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[可选]配置阿里云镜像加速&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 104.68920392584515" data-width="1920" data-height="917"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/0a7b0d2480e8e35788102af644e7a97e.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;span class="s"&gt;&amp;lt;&amp;lt;-&amp;#39;EOF&amp;#39;&lt;/span&gt;
&lt;span class="s"&gt;{&lt;/span&gt;
&lt;span class="s"&gt;  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://*****.mirror.aliyuncs.com&amp;quot;]&lt;/span&gt;
&lt;span class="s"&gt;}&lt;/span&gt;
&lt;span class="s"&gt;EOF&lt;/span&gt;
sudo systemctl daemon-reload
sudo systemctl restart docker
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动Docker，命令：systemctl start docker，然后加入开机启动，如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# systemctl start docker&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# systemctl enable  docker&lt;/span&gt;
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker version&lt;/span&gt;
Client:
 Version:      &lt;span class="m"&gt;18&lt;/span&gt;.03.1-ce
 API version:  &lt;span class="m"&gt;1&lt;/span&gt;.37
 Go version:   go1.9.5
 Git commit:   9ee9f40
 Built:        Thu Apr &lt;span class="m"&gt;26&lt;/span&gt; &lt;span class="m"&gt;07&lt;/span&gt;:20:16 &lt;span class="m"&gt;2018&lt;/span&gt;
 OS/Arch:      linux/amd64
 Experimental: &lt;span class="nb"&gt;false&lt;/span&gt;
 Orchestrator: swarm

Server:
 Engine:
  Version:      &lt;span class="m"&gt;18&lt;/span&gt;.03.1-ce
  API version:  &lt;span class="m"&gt;1&lt;/span&gt;.37 &lt;span class="o"&gt;(&lt;/span&gt;minimum version &lt;span class="m"&gt;1&lt;/span&gt;.12&lt;span class="o"&gt;)&lt;/span&gt;
  Go version:   go1.9.5
  Git commit:   9ee9f40
  Built:        Thu Apr &lt;span class="m"&gt;26&lt;/span&gt; &lt;span class="m"&gt;07&lt;/span&gt;:23:58 &lt;span class="m"&gt;2018&lt;/span&gt;
  OS/Arch:      linux/amd64
  Experimental: &lt;span class="nb"&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;docker&lt;/code&gt; 命令会使用 &lt;a href="https://en.wikipedia.org/wiki/Unix_domain_socket"&gt;Unix socket&lt;/a&gt; 与 Docker 引擎通讯。而只有 &lt;code&gt;root&lt;/code&gt; 用户和 &lt;code&gt;docker&lt;/code&gt; 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 &lt;code&gt;root&lt;/code&gt; 用户。因此，更好地做法是将需要使用 &lt;code&gt;docker&lt;/code&gt; 的用户加入 &lt;code&gt;docker&lt;/code&gt; 用户组。&lt;/p&gt;
&lt;p&gt;建立 &lt;code&gt;docker&lt;/code&gt; 组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# sudo groupadd docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将当前用户加入 &lt;code&gt;docker&lt;/code&gt; 组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# sudo usermod -aG docker $USER&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;退出当前终端并重新登录，进行如下测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试 Docker 是否安装正确&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost /&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker run hello-world&lt;/span&gt;
   Unable to find image &lt;span class="s1"&gt;&amp;#39;hello-world:latest&amp;#39;&lt;/span&gt; locally
   latest: Pulling from library/hello-world
   0e03bdcc26d7: Pull &lt;span class="nb"&gt;complete&lt;/span&gt; 
   Digest: sha256:4cf9c47f86df71d48364001ede3a4fcd85ae80ce02ebad74156906caff5378bc
   Status: Downloaded newer image &lt;span class="k"&gt;for&lt;/span&gt; hello-world:latest

   Hello from Docker!             --&amp;gt; 出现这句话代表Docker安装没有问题
   This message shows that your installation appears to be working correctly.

   To generate this message, Docker took the following steps:
    &lt;span class="m"&gt;1&lt;/span&gt;. The Docker client contacted the Docker daemon.
    &lt;span class="m"&gt;2&lt;/span&gt;. The Docker daemon pulled the &lt;span class="s2"&gt;&amp;quot;hello-world&amp;quot;&lt;/span&gt; image from the Docker Hub.
       &lt;span class="o"&gt;(&lt;/span&gt;amd64&lt;span class="o"&gt;)&lt;/span&gt;
    &lt;span class="m"&gt;3&lt;/span&gt;. The Docker daemon created a new container from that image which runs the
       executable that produces the output you are currently reading.
    &lt;span class="m"&gt;4&lt;/span&gt;. The Docker daemon streamed that output to the Docker client, which sent it
       to your terminal.

   To try something more ambitious, you can run an Ubuntu container with:
    $ docker run -it ubuntu bash

   Share images, automate workflows, and more with a free Docker ID:
    https://hub.docker.com/

   For more examples and ideas, visit:
    https://docs.docker.com/get-started/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若能正常输出以上信息，则说明安装成功。&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj30/</guid><pubDate>Wed, 16 Sep 2020 00:30:00 +0806</pubDate></item><item><title>Docker笔记</title><link>/Xuxx_Blogs/archives/bj31/</link><description>&lt;h2&gt;Docker引擎&lt;/h2&gt;
&lt;p&gt;Docker引擎是一个包含以下主要组件的客户端服务器应用程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;—种服务器，它是一种被称为守护进程（deamon）并且长时间运行的程序。&lt;/li&gt;
&lt;li&gt;REST API 用于指定程序可以用来与守护进程通信的接口，并指示它做什么。&lt;/li&gt;
&lt;li&gt;一个有命令行界面( CLI )工具的客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 78.69379014989293" data-width="735" data-height="467"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/f85888768c1310cf36b6193b4c0de484.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;Docker架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Docker 使用客户端-服务器 ( C/S ) 架构模式，使用远程 API 来管理和创建 Docker 容器。&lt;/li&gt;
&lt;li&gt;Docker 容器通过 Docker 镜像来创建。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器与镜像&lt;/strong&gt;的关系类似于面向对象编程中的&lt;strong&gt;对象与类&lt;/strong&gt;。---通过镜像生成容器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 99.55035971223022" data-width="1107" data-height="556"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/785186682d24af870e5554ceb4678f80.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;标题&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;镜像(Images)&lt;/td&gt;
&lt;td&gt;Docker镜像是用于创建Docker容器的模板。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;容器(Container&lt;strong&gt;)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;容器是独立运行的一个或一组应用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;客户端(Client)&lt;/td&gt;
&lt;td&gt;Docker客户端通过命令行或者其他工具使用Docker API与Docker的守护进程通信。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;主机(Host)&lt;/td&gt;
&lt;td&gt;一个物理或者虚拟的机器用于执行Docker守护进程和容器。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;仓库(Registry)&lt;/td&gt;
&lt;td&gt;Docker仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub (&lt;a href="https://hub.docker.com）提供了庞大的镜像集合供使用。"&gt;https://hub.docker.com）提供了庞大的镜像集合供使用。&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker Machine&lt;/td&gt;
&lt;td&gt;Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、Digital Ocean、Microsoft Azure。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Docker 操作镜像&lt;/h2&gt;
&lt;h3&gt;获取镜像&lt;/h3&gt;
&lt;p&gt;从Docker镜像仓库获取镜像的命令是 &lt;code&gt;docker pull&lt;/code&gt; 。其命令格式为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker pull &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;Docker Registry 地址&lt;span class="o"&gt;[&lt;/span&gt;:端口号&lt;span class="o"&gt;]&lt;/span&gt;/仓库名&lt;span class="o"&gt;[&lt;/span&gt;:标签&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的选项可以通过 &lt;code&gt;docker pull --help&lt;/code&gt;命令看到，这里说一下镜像名称的格式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;镜像仓库地址&lt;/strong&gt;：地址的格式一般是&amp;lt;域名/IP&amp;gt;[：端口号]。默认地址是Docker Hub。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仓库名&lt;/strong&gt;：如之前所说，这里的仓库名是两段式名称，即&lt;code&gt;&amp;lt;用户名&amp;gt;/&amp;lt;软件名&amp;gt;&lt;/code&gt;。对于Docker Hub，如果不给出用户名，则默认为 &lt;code&gt;library&lt;/code&gt;，也就是官方镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;列出镜像&lt;/h3&gt;
&lt;p&gt;想要列出已经下载的镜像，可以使用 &lt;code&gt;docker images&lt;/code&gt;或者&lt;code&gt;docker image ls&lt;/code&gt;命令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker images&lt;/span&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
mydemo1             latest              3b239960848d        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              54300df71941        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              e7e0ba36be39        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
tomcat              latest              2eb5a120304e        &lt;span class="m"&gt;3&lt;/span&gt; months ago        647MB
hello-world         latest              bf756fb1ae65        &lt;span class="m"&gt;8&lt;/span&gt; months ago        &lt;span class="m"&gt;13&lt;/span&gt;.3kB
rabbitmq            &lt;span class="m"&gt;3&lt;/span&gt;.7.3-management    2f415b0e9a6e        &lt;span class="m"&gt;2&lt;/span&gt; years ago         151MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;列表包含了仓库名、标签、镜像ID、创建时间以及所占用的空间。&lt;strong&gt;镜像ID则&lt;/strong&gt;是镜像的唯一标识，一个镜像可以对应多个标签。&lt;/p&gt;
&lt;h4&gt;虚悬镜像&lt;/h4&gt;
&lt;p&gt;有时在镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              54300df71941        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个镜像原本是有镜像名和标签的，原来为（例如）&lt;code&gt;mongo: 3.2&lt;/code&gt;，随着官方镜像维护，发布了新版本后，重新&lt;code&gt;docker pull mongo:3.2&lt;/code&gt;时，&lt;code&gt;mongo:3.2&lt;/code&gt;这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;。除了&lt;code&gt;docker pull&lt;/code&gt;可能导致这种情况，&lt;code&gt;docker build&lt;/code&gt;也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为&lt;code&gt;&amp;lt;none&amp;gt;&lt;/code&gt;的镜像。这类无标签镜像也被称为&lt;strong&gt;虚悬镜像(dangling image)&lt;/strong&gt;，可以用下面的命令专门显示这类镜像:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker images -f dangling=true&lt;/span&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              54300df71941        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              e7e0ba36be39        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker image prune&lt;/span&gt;
WARNING! This will remove all dangling images.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt;? &lt;span class="o"&gt;[&lt;/span&gt;y/N&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;输入&lt;span class="o"&gt;)&lt;/span&gt;y
Deleted Images:
deleted: sha256:e7e0ba36be3927af3f1d7a0b99263d4aa6e6af1d93b9d3455c0a045d4f4a477a
deleted: sha256:05ff87569ed6bfdc38621112bea7aafffed7895538490748e85fdf00da19d3b6

Total reclaimed space: 12B
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;中间层镜像&lt;/h4&gt;
&lt;p&gt;为了加速镜像构建、重复利用资源,Docker会利用&lt;strong&gt;中间层镜像&lt;/strong&gt;。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的&lt;code&gt;docker image ls&lt;/code&gt;表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加&lt;code&gt;-a&lt;/code&gt;参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker images -a&lt;/span&gt;
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              9e5197c9a0e5        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
mydemo1             latest              3b239960848d        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              660dfcd0a262        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              1b63db1e38f7        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              f1343ffd435c        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
&amp;lt;none&amp;gt;              &amp;lt;none&amp;gt;              54300df71941        &lt;span class="m"&gt;2&lt;/span&gt; months ago        647MB
tomcat              latest              2eb5a120304e        &lt;span class="m"&gt;3&lt;/span&gt; months ago        647MB
hello-world         latest              bf756fb1ae65        &lt;span class="m"&gt;8&lt;/span&gt; months ago        &lt;span class="m"&gt;13&lt;/span&gt;.3kB
rabbitmq            &lt;span class="m"&gt;3&lt;/span&gt;.7.3-management    2f415b0e9a6e        &lt;span class="m"&gt;2&lt;/span&gt; years ago         151MB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。&lt;/p&gt;
&lt;h3&gt;镜像体积&lt;/h3&gt;
&lt;p&gt;如果仔细观察，会注意到，这里标识的所占用空间和在Docker Hub上看到的镜像大小不同。比如,&lt;code&gt;ubuntu:16.04&lt;/code&gt;镜像大小，在这里是&lt;strong&gt;127 MB&lt;/strong&gt;，但是在Docker Hub显示的却是&lt;strong&gt;50 MB&lt;/strong&gt;。这是因为 Docker Hub 中显示的体积是&lt;strong&gt;压缩后的体积&lt;/strong&gt;。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 &lt;code&gt;docker images&lt;/code&gt;显示的是镜像下载到本地后，&lt;strong&gt;展开的大小&lt;/strong&gt;，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。&lt;/p&gt;
&lt;p&gt;另外一个需要注意的问题是，&lt;code&gt;docker images&lt;/code&gt;列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此&lt;strong&gt;不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层&lt;/strong&gt;。由于Docker使用&lt;code&gt;Union FS&lt;/code&gt;，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。&lt;/p&gt;
&lt;p&gt;可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker system df&lt;/span&gt;
TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE
Images              &lt;span class="m"&gt;6&lt;/span&gt;                   &lt;span class="m"&gt;5&lt;/span&gt;                   &lt;span class="m"&gt;798&lt;/span&gt;.4MB             &lt;span class="m"&gt;647&lt;/span&gt;.3MB &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;81&lt;/span&gt;%&lt;span class="o"&gt;)&lt;/span&gt;
Containers          &lt;span class="m"&gt;6&lt;/span&gt;                   &lt;span class="m"&gt;0&lt;/span&gt;                   &lt;span class="m"&gt;4&lt;/span&gt;.806MB             &lt;span class="m"&gt;4&lt;/span&gt;.806MB &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;%&lt;span class="o"&gt;)&lt;/span&gt;
Local Volumes       &lt;span class="m"&gt;7&lt;/span&gt;                   &lt;span class="m"&gt;1&lt;/span&gt;                   &lt;span class="m"&gt;30&lt;/span&gt;.6MB              &lt;span class="m"&gt;26&lt;/span&gt;.49MB &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="m"&gt;86&lt;/span&gt;%&lt;span class="o"&gt;)&lt;/span&gt;
Build Cache         &lt;span class="m"&gt;0&lt;/span&gt;                   &lt;span class="m"&gt;0&lt;/span&gt;                   0B                  0B
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除镜像&lt;/h3&gt;
&lt;p&gt;如果要删除本地的镜像，可以使用&lt;code&gt;docker image rm&lt;/code&gt;或者&lt;code&gt;docker rmi&lt;/code&gt;命令，其格式为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker image rm [选项]  &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker rmi [选项]  &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;&amp;lt;镜像&amp;gt;&lt;/code&gt;可以是&lt;code&gt;镜像短ID&lt;/code&gt; 、&lt;code&gt;镜像长ID&lt;/code&gt;、&lt;code&gt;镜像名&lt;/code&gt;或者&lt;code&gt;镜像摘要&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;Docker操作容器&lt;/h2&gt;
&lt;h3&gt;启动容器&lt;/h3&gt;
&lt;p&gt;所需要的命令主要为&lt;code&gt;docker run&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-i  以交互模式运行容器，通常与 -t 同时使用；&lt;/li&gt;
&lt;li&gt;-t  为容器重新分配一个伪输入终端；&lt;/li&gt;
&lt;li&gt;--name 为容器指定一个名称；&lt;/li&gt;
&lt;li&gt;-d  已守护方式启动容器&lt;/li&gt;
&lt;li&gt;-p 指定端口映射，格式为：&lt;code&gt;主机(宿主机)端口:容器端口&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;-P 随机端口映射，容器内部端口&lt;strong&gt;随机&lt;/strong&gt;映射到主机的端口&lt;/li&gt;
&lt;li&gt;--volume , -v 绑定一个数据卷&lt;/li&gt;
&lt;li&gt;--expose=[] 开放一个端口或一组端口；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用docker镜像 nginx:latest 以后台模式启动一个容器,并将容器命名为mynginx。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run --name mynginx -d nginx:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用镜像 nginx:latest 以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -P -d nginx:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -p 80:80 -v /data:/data -d nginx:latest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -p 127.0.0.1:80:8080/tcp ubuntu bash&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用镜像 nginx:latest 以交互模式启动一个容器,在容器内执行 /bin/bash 命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker run -it nginx:latest /bin/bash
root@b8573233d675:/#&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当利用 docker run 来创建容器时，Docker在后台运行的标准操作包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查本地是否存在指定的镜像，不存在就从公有仓库下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用镜像创建并启动一个容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分配一个文件系统，并在只读的镜像层外面挂载一层可读写层&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从地址池配置一个ip 地址给容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行用户指定的应用程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行完毕后容器被终止&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;start/stop/restart 命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;docker start&lt;/strong&gt; :启动一个或多个已经被停止的容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker stop&lt;/strong&gt; :停止一个运行中的容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker restart&lt;/strong&gt; :重启容器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker start [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker stop [选项] &amp;lt;镜像&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker restart [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;lt;镜像3&amp;gt;...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动已被停止的容器 myrunoob&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker start myrunoob&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;停止运行中的容器 myrunoob&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker stop myrunoob&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启容器 myrunoob&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker restart myrunoob&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看容器&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;docker ps&lt;/code&gt;命令可以查看正在运行的容器，格式为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker ps [选项]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-a :&lt;/strong&gt;显示所有的容器，包括未运行的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-f :&lt;/strong&gt;根据条件过滤显示的内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-l :&lt;/strong&gt;显示最近创建的容器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-n :&lt;/strong&gt;列出最近创建的n个容器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;--no-trunc :&lt;/strong&gt;不截断输出(打印完整的容器 ID)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-s :&lt;/strong&gt;显示总的文件大小。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker run -p 8080:8080 -d tomcat&lt;/span&gt;
ed8b228b1e55845241c26e8ede042bae4132700d7334ae44438ce0e60282ff3c

&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker ps&lt;/span&gt;
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
ed8b228b1e55        tomcat              &lt;span class="s2"&gt;&amp;quot;catalina.sh run&amp;quot;&lt;/span&gt;   &lt;span class="m"&gt;8&lt;/span&gt; seconds ago       Up &lt;span class="m"&gt;3&lt;/span&gt; seconds        &lt;span class="m"&gt;0&lt;/span&gt;.0.0.0:8080-&amp;gt;8080/tcp   elastic_gauss
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出详情介绍：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CONTAINER ID:&lt;/strong&gt; 容器 ID。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IMAGE:&lt;/strong&gt; 使用的镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COMMAND:&lt;/strong&gt; 启动容器时运行的命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CREATED:&lt;/strong&gt; 容器的创建时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;STATUS:&lt;/strong&gt; 容器状态。&lt;/p&gt;
&lt;p&gt;状态有7种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;created（已创建）&lt;/li&gt;
&lt;li&gt;restarting（重启中）&lt;/li&gt;
&lt;li&gt;running（运行中）&lt;/li&gt;
&lt;li&gt;removing（迁移中）&lt;/li&gt;
&lt;li&gt;paused（暂停）&lt;/li&gt;
&lt;li&gt;exited（停止）&lt;/li&gt;
&lt;li&gt;dead（死亡）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;PORTS:&lt;/strong&gt; 容器的端口信息和使用的连接类型（tcp\udp）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NAMES:&lt;/strong&gt; 自动分配的容器名称。&lt;/p&gt;
&lt;h3&gt;进入容器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;docker exec ：&lt;/strong&gt;在运行的容器中执行命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker exec [OPTIONS] CONTAINER COMMAND [ARG...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OPTIONS说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-d :&lt;/strong&gt;分离模式(守护态): 在后台运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-i :&lt;/strong&gt;即使没有附加也保持STDIN 打开&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-t :&lt;/strong&gt;分配一个伪终端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在容器 tomcat 中开启一个交互模式的终端:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker exec -it tomcat  /bin/bash&lt;/span&gt;
root@99da97385e5f:/usr/local/tomcat#
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;删除容器&lt;/h3&gt;
&lt;p&gt;可以使用&lt;code&gt;docker container rm&lt;/code&gt;来删除一个处于终止状态的容器。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker container rm 99da97385e5f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要删除一个运行中的容器，可以添加&lt;code&gt;-f&lt;/code&gt;参数。Docker 会发送 &lt;code&gt;SIGKILL( 终止进程)&lt;/code&gt;信号给容器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除所有容器&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker rm $(docker ps -a -q)&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;清理所有处于终止状态的容器&lt;/h3&gt;
&lt;p&gt;用&lt;code&gt;docker container ls -a&lt;/code&gt;命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost ~&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker container prune&lt;/span&gt;
WARNING! This will remove all stopped containers.
Are you sure you want to &lt;span class="k"&gt;continue&lt;/span&gt;? &lt;span class="o"&gt;[&lt;/span&gt;y/N&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;输入&lt;span class="o"&gt;)&lt;/span&gt;y
Deleted Containers:
82ab3ce8fee74e258d90ab6984ec5dc3e5cdf453e8a3c92a1b18ce054b6a5a56
ed8b228b1e55845241c26e8ede042bae4132700d7334ae44438ce0e60282ff3c
...
Total reclaimed space: &lt;span class="m"&gt;4&lt;/span&gt;.818MB
&lt;/pre&gt;&lt;/div&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj31/</guid><pubDate>Thu, 17 Sep 2020 13:30:00 +0806</pubDate></item><item><title>Dockerfile笔记</title><link>/Xuxx_Blogs/archives/bj32/</link><description>&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;从 &lt;a href="https://yeasy.gitbook.io/docker_practice/image/commit"&gt;docker commit&lt;/a&gt; 的学习中，可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。&lt;/p&gt;
&lt;p&gt;Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/p&gt;
&lt;p&gt;以 tomcat 镜像为例，这次使用 Dockerfile 来定制。在一个空白目录中，建立一个文本文件，并命名为&lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir myshop
&lt;span class="nb"&gt;cd&lt;/span&gt; myshop
touch Dockerfile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其内容为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;tomcat&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; Hello,Docker! &amp;gt; /usr/local/tomcat/webapps/ROOT/index.jsp
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;FROM-指定基础镜像&lt;/h2&gt;
&lt;p&gt;所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。而FROM就是指定基础镜像，因此&lt;strong&gt;一个 Dockerfile 中 FROM是必备的指令，并且必须是第一条指令&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了选择(在Docker Hub上)现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为&lt;code&gt;scratch&lt;/code&gt;。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。&lt;/p&gt;
&lt;p&gt;如果你以 &lt;code&gt;scratch&lt;/code&gt; 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。&lt;/p&gt;
&lt;h2&gt;RUN 执行命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RUN&lt;/code&gt; 指令是用来执行命令行命令的。由于命令行的强大能力，&lt;code&gt;RUN&lt;/code&gt; 指令在定制镜像时是最常用的指令之一。其格式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;shell&lt;/em&gt; 格式：&lt;code&gt;RUN &amp;lt;命令&amp;gt;&lt;/code&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 &lt;code&gt;RUN&lt;/code&gt; 指令就是这种格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; Hello,Docker! &amp;gt; /usr/local/tomcat/webapps/ROOT/index.jsp
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;exec&lt;/em&gt; 格式：&lt;code&gt;RUN ["可执行文件", "参数1", "参数2"]&lt;/code&gt;，这更像是函数调用中的格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然 &lt;code&gt;RUN&lt;/code&gt; 就像 Shell 脚本一样可以执行命令，那么是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;debian:stretch&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get install -y gcc libc6-dev make wget
&lt;span class="k"&gt;RUN&lt;/span&gt; wget -O redis.tar.gz &lt;span class="s2"&gt;&amp;quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; mkdir -p /usr/src/redis
&lt;span class="k"&gt;RUN&lt;/span&gt; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; make -C /usr/src/redis
&lt;span class="k"&gt;RUN&lt;/span&gt; make -C /usr/src/redis install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前说过，&lt;strong&gt;Dockerfile 中每一个指令都会建立一层&lt;/strong&gt;，&lt;code&gt;RUN&lt;/code&gt; 也不例外。每一个 &lt;code&gt;RUN&lt;/code&gt; 的行为，就和手动建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，&lt;code&gt;commit&lt;/code&gt; 这一层的修改，构成新的镜像。&lt;/p&gt;
&lt;p&gt;而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;上面的 &lt;code&gt;Dockerfile&lt;/code&gt; 正确的写法应该是这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;debian:stretch&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt; -x&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;buildDeps&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;gcc libc6-dev make wget&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get update &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install -y &lt;span class="nv"&gt;$buildDeps&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; wget -O redis.tar.gz &lt;span class="s2"&gt;&amp;quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; mkdir -p /usr/src/redis &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -C /usr/src/redis &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make -C /usr/src/redis install &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/* &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm redis.tar.gz &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -r /usr/src/redis &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get purge -y --auto-remove &lt;span class="nv"&gt;$buildDeps&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 &lt;code&gt;RUN&lt;/code&gt; 一一对应不同的命令，而是仅仅使用一个 &lt;code&gt;RUN&lt;/code&gt; 指令，并使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建&lt;/p&gt;
&lt;p&gt;并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 &lt;code&gt;\&lt;/code&gt; 的命令换行方式，以及行首 &lt;code&gt;#&lt;/code&gt; 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。&lt;/p&gt;
&lt;p&gt;此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 &lt;code&gt;apt&lt;/code&gt; 缓存文件。这是很重要的一步，之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。&lt;/p&gt;
&lt;h2&gt;构建镜像&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker build&lt;/code&gt; 命令进行镜像构建。其语法为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker build &lt;span class="o"&gt;[&lt;/span&gt;选项&lt;span class="o"&gt;]&lt;/span&gt; &amp;lt;上下文路径/URL/-&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;code&gt;Dockerfile&lt;/code&gt; 文件所在目录执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;root@localhost myshop&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="c1"&gt;# docker build -t myshop .&lt;/span&gt;
Sending build context to Docker daemon  &lt;span class="m"&gt;3&lt;/span&gt;.072kB
Step &lt;span class="m"&gt;1&lt;/span&gt;/2 : FROM tomcat:latest
 ---&amp;gt; 2eb5a120304e
Step &lt;span class="m"&gt;2&lt;/span&gt;/2 : COPY index.jsp /usr/local/tomcat/webapps/ROOT
 ---&amp;gt; f44b1d0d1366
Successfully built f44b1d0d1366
Successfully tagged myshop:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;镜像构建上下文（Context）&lt;/h2&gt;
&lt;p&gt;如果注意，会看到 &lt;code&gt;docker build&lt;/code&gt; 命令最后有一个 &lt;code&gt;.&lt;/code&gt;。&lt;code&gt;.&lt;/code&gt; 表示当前目录，而 &lt;code&gt;Dockerfile&lt;/code&gt; 就在当前目录，因此不少初学者以为这个路径是在指定 &lt;code&gt;Dockerfile&lt;/code&gt; 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 &lt;strong&gt;上下文路径&lt;/strong&gt;。那么什么是上下文呢？&lt;/p&gt;
&lt;p&gt;当进行镜像构建的时候，并非所有定制都会通过 &lt;code&gt;RUN&lt;/code&gt; 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 &lt;code&gt;COPY&lt;/code&gt; 指令、&lt;code&gt;ADD&lt;/code&gt; 指令等。而 &lt;code&gt;docker build&lt;/code&gt; 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？&lt;/p&gt;
&lt;p&gt;这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，&lt;code&gt;docker build&lt;/code&gt; 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。&lt;/p&gt;
&lt;p&gt;如果在 Dockerfile 中这么写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY ./package.json /app/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这并不是要复制执行 &lt;code&gt;docker build&lt;/code&gt; 命令所在的目录下的 &lt;code&gt;package.json&lt;/code&gt;，也不是复制 &lt;code&gt;Dockerfile&lt;/code&gt; 所在目录下的 &lt;code&gt;package.json&lt;/code&gt;，而是复制 &lt;strong&gt;上下文（context）&lt;/strong&gt; 目录下的 &lt;code&gt;package.json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其它&lt;/strong&gt; &lt;code&gt;docker build&lt;/code&gt; &lt;strong&gt;的用法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接用 Git repo 进行构建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这行命令指定了构建所需的 Git repo，并且指定分支为 &lt;code&gt;master&lt;/code&gt;，构建目录为 &lt;code&gt;/amd64/hello-world/&lt;/code&gt;，然后 Docker 就会自己去 &lt;code&gt;git clone&lt;/code&gt; 这个项目、切换到指定分支、并进入到指定目录后开始构建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用给定的 tar 压缩包构建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build http://server/context.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果所给出的 URL 不是个 Git repo，而是个 &lt;code&gt;tar&lt;/code&gt; 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从标准输入中读取 Dockerfile 进行构建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;docker build - &amp;lt; Dockerfile&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cat Dockerfile | docker build -&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果标准输入传入的是文本文件，则将其视为 &lt;code&gt;Dockerfile&lt;/code&gt;，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 &lt;code&gt;COPY&lt;/code&gt; 进镜像之类的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从标准输入中读取上下文压缩包进行构建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker build - &amp;lt; context.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果发现标准输入的文件格式是 &lt;code&gt;gzip&lt;/code&gt;、&lt;code&gt;bzip2&lt;/code&gt; 以及 &lt;code&gt;xz&lt;/code&gt; 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Dockerfile 指令详解&lt;/h2&gt;
&lt;h3&gt;COPY 复制文件&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] &amp;lt;源路径&amp;gt;... &amp;lt;目标路径&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COPY [--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;] ["&amp;lt;源路径1&amp;gt;",... "&amp;lt;目标路径&amp;gt;"]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和 &lt;code&gt;RUN&lt;/code&gt; 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;COPY&lt;/code&gt; 指令将从构建上下文目录中 &lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 的文件/目录复制到新的一层的镜像内的 &lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 位置。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY package.json /usr/src/app/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 &lt;a href="https://golang.org/pkg/path/filepath/#Match"&gt;&lt;code&gt;filepath.Match&lt;/code&gt;&lt;/a&gt; 规则，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY hom* /mydir/COPY hom?.txt /mydir/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 &lt;code&gt;WORKDIR&lt;/code&gt; 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。&lt;/p&gt;
&lt;p&gt;此外，还需要注意一点，使用 &lt;code&gt;COPY&lt;/code&gt; 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。&lt;/p&gt;
&lt;p&gt;在使用该指令的时候还可以加上 &lt;code&gt;--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;&lt;/code&gt; 选项来改变文件的所属用户及所属组。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。&lt;/p&gt;
&lt;h3&gt;ADD 更高级的复制文件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ADD&lt;/code&gt; 指令和 &lt;code&gt;COPY&lt;/code&gt; 的格式和性质基本一致。但是在 &lt;code&gt;COPY&lt;/code&gt; 基础上增加了一些功能。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 可以是一个 &lt;code&gt;URL&lt;/code&gt;，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 去。下载后的文件权限自动设置为 &lt;code&gt;600&lt;/code&gt;，如果这并不是想要的权限，那么还需要增加额外的一层 &lt;code&gt;RUN&lt;/code&gt; 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 &lt;code&gt;RUN&lt;/code&gt; 指令进行解压缩。所以不如直接使用 &lt;code&gt;RUN&lt;/code&gt; 指令，然后使用 &lt;code&gt;wget&lt;/code&gt; 或者 &lt;code&gt;curl&lt;/code&gt; 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;&amp;lt;源路径&amp;gt;&lt;/code&gt; 为一个 &lt;code&gt;tar&lt;/code&gt; 压缩文件的话，压缩格式为 &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; 以及 &lt;code&gt;xz&lt;/code&gt; 的情况下，&lt;code&gt;ADD&lt;/code&gt; 指令将会自动解压缩这个压缩文件到 &lt;code&gt;&amp;lt;目标路径&amp;gt;&lt;/code&gt; 去。&lt;/p&gt;
&lt;p&gt;在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 &lt;code&gt;ubuntu&lt;/code&gt; 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但在某些情况下，如果真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 &lt;code&gt;ADD&lt;/code&gt; 命令了。&lt;/p&gt;
&lt;p&gt;在 Docker 官方的 &lt;a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices"&gt;Dockerfile 最佳实践文档&lt;/a&gt; 中要求，尽可能的使用 &lt;code&gt;COPY&lt;/code&gt;，因为 &lt;code&gt;COPY&lt;/code&gt; 的语义很明确，就是复制文件而已，而 &lt;code&gt;ADD&lt;/code&gt; 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 &lt;code&gt;ADD&lt;/code&gt; 的场合，就是所提及的需要自动解压缩的场合。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，&lt;code&gt;ADD&lt;/code&gt; 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。&lt;/p&gt;
&lt;p&gt;因此在 &lt;code&gt;COPY&lt;/code&gt; 和 &lt;code&gt;ADD&lt;/code&gt; 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 &lt;code&gt;COPY&lt;/code&gt; 指令，仅在需要自动解压缩的场合使用 &lt;code&gt;ADD&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在使用该指令的时候还可以加上 &lt;code&gt;--chown=&amp;lt;user&amp;gt;:&amp;lt;group&amp;gt;&lt;/code&gt; 选项来改变文件的所属用户及所属组。&lt;/p&gt;
&lt;h3&gt;CMD 容器启动命令&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CMD&lt;/code&gt; 指令的格式和 &lt;code&gt;RUN&lt;/code&gt; 相似，也是两种格式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shell&lt;/code&gt; 格式：&lt;code&gt;CMD &amp;lt;命令&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec&lt;/code&gt; 格式：&lt;code&gt;CMD ["可执行文件", "参数1", "参数2"...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参数列表格式：&lt;code&gt;CMD ["参数1", "参数2"...]&lt;/code&gt;。在指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 指令后，用 &lt;code&gt;CMD&lt;/code&gt; 指定具体的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。&lt;code&gt;CMD&lt;/code&gt; 指令就是用于指定默认的容器主进程的启动命令的。&lt;/p&gt;
&lt;p&gt;在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，&lt;code&gt;ubuntu&lt;/code&gt; 镜像默认的 &lt;code&gt;CMD&lt;/code&gt; 是 &lt;code&gt;/bin/bash&lt;/code&gt;，如果直接 &lt;code&gt;docker run -it ubuntu&lt;/code&gt; 的话，会直接进入 &lt;code&gt;bash&lt;/code&gt;。也可以在运行时指定运行别的命令，如 &lt;code&gt;docker run -it ubuntu cat /etc/os-release&lt;/code&gt;。这就是用 &lt;code&gt;cat /etc/os-release&lt;/code&gt; 命令替换了默认的 &lt;code&gt;/bin/bash&lt;/code&gt; 命令了，输出了系统版本信息。&lt;/p&gt;
&lt;p&gt;在指令格式上，一般推荐使用 &lt;code&gt;exec&lt;/code&gt; 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 &lt;code&gt;"&lt;/code&gt;，而不要使用单引号。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;shell&lt;/code&gt; 格式的话，实际的命令会被包装为 &lt;code&gt;sh -c&lt;/code&gt; 的参数的形式进行执行。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CMD echo $HOME&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际执行中，会将其变更为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CMD [ "sh", "-c", "echo $HOME" ]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就是为什么可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。&lt;/p&gt;
&lt;p&gt;提到 &lt;code&gt;CMD&lt;/code&gt; 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。&lt;/p&gt;
&lt;p&gt;Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 &lt;code&gt;systemd&lt;/code&gt; 去启动后台服务，容器内没有后台服务的概念。&lt;/p&gt;
&lt;p&gt;一些初学者将 &lt;code&gt;CMD&lt;/code&gt; 写为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CMD service nginx start&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后发现容器执行后就立即退出了。甚至在容器内去使用 &lt;code&gt;systemctl&lt;/code&gt; 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。&lt;/p&gt;
&lt;p&gt;对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。&lt;/p&gt;
&lt;p&gt;而使用 &lt;code&gt;service nginx start&lt;/code&gt; 命令，则是希望 upstart 来以后台守护进程形式启动 &lt;code&gt;nginx&lt;/code&gt; 服务。而刚才说了 &lt;code&gt;CMD service nginx start&lt;/code&gt; 会被理解为 &lt;code&gt;CMD [ "sh", "-c", "service nginx start"]&lt;/code&gt;，因此主进程实际上是 &lt;code&gt;sh&lt;/code&gt;。那么当 &lt;code&gt;service nginx start&lt;/code&gt; 命令结束后，&lt;code&gt;sh&lt;/code&gt; 也就结束了，&lt;code&gt;sh&lt;/code&gt; 作为主进程退出了，自然就会令容器退出。&lt;/p&gt;
&lt;p&gt;正确的做法是直接执行 &lt;code&gt;nginx&lt;/code&gt; 可执行文件，并且要求以前台形式运行。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CMD ["nginx", "-g", "daemon off;"]&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;ENTRYPOINT 入口点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ENTRYPOINT&lt;/code&gt; 的格式和 &lt;code&gt;RUN&lt;/code&gt; 指令格式一样，分为 &lt;code&gt;exec&lt;/code&gt; 格式和 &lt;code&gt;shell&lt;/code&gt; 格式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ENTRYPOINT&lt;/code&gt; 的目的和 &lt;code&gt;CMD&lt;/code&gt; 一样，都是在指定容器启动程序及参数。&lt;code&gt;ENTRYPOINT&lt;/code&gt; 在运行时也可以替代，不过比 &lt;code&gt;CMD&lt;/code&gt; 要略显繁琐，需要通过 &lt;code&gt;docker run&lt;/code&gt; 的参数 &lt;code&gt;--entrypoint&lt;/code&gt; 来指定。&lt;/p&gt;
&lt;p&gt;当指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 后，&lt;code&gt;CMD&lt;/code&gt; 的含义就发生了改变，不再是直接的运行其命令，而是将 &lt;code&gt;CMD&lt;/code&gt; 的内容作为参数传给 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 指令，换句话说实际执行时，将变为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ENTRYPOINT&amp;gt; "&amp;lt;CMD&amp;gt;"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么有了 &lt;code&gt;CMD&lt;/code&gt; 后，为什么还要有 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 呢？这种 &lt;code&gt;&amp;lt;ENTRYPOINT&amp;gt; "&amp;lt;CMD&amp;gt;"&lt;/code&gt; 有什么好处么？让来看几个场景。&lt;/p&gt;
&lt;h4&gt;场景一：让镜像变成像命令一样使用&lt;/h4&gt;
&lt;p&gt;假设需要一个得知自己当前公网 IP 的镜像，那么可以先用 &lt;code&gt;CMD&lt;/code&gt; 来实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;ubuntu:18.04&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install -y curl &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/*
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;curl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;-s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;http://myip.ipip.net&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;假如使用 &lt;code&gt;docker build -t myip .&lt;/code&gt; 来构建镜像的话，如果需要查询当前公网 IP，只需要执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run myip
当前 IP：61.148.226.66 来自：北京市 联通
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果希望加参数呢？比如从上面的 &lt;code&gt;CMD&lt;/code&gt; 中可以看到实质的命令是 &lt;code&gt;curl&lt;/code&gt;，那么如果希望显示 HTTP 头信息，就需要加上 &lt;code&gt;-i&lt;/code&gt; 参数。那么可以直接加 &lt;code&gt;-i&lt;/code&gt; 参数给 &lt;code&gt;docker run myip&lt;/code&gt; 么？&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run myip -i
docker: Error response from daemon: invalid header field value &lt;span class="s2"&gt;&amp;quot;oci runtime error: container_linux.go:247: starting container process caused \&amp;quot;exec: \\\&amp;quot;-i\\\&amp;quot;: executable file not found in &lt;/span&gt;&lt;span class="nv"&gt;$PATH&lt;/span&gt;&lt;span class="s2"&gt;\&amp;quot;\n&amp;quot;&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到可执行文件找不到的报错，&lt;code&gt;executable file not found&lt;/code&gt;。之前说过，跟在镜像名后面的是 &lt;code&gt;command&lt;/code&gt;，运行时会替换 &lt;code&gt;CMD&lt;/code&gt; 的默认值。因此这里的 &lt;code&gt;-i&lt;/code&gt; 替换了原来的 &lt;code&gt;CMD&lt;/code&gt;，而不是添加在原来的 &lt;code&gt;curl -s http://myip.ipip.net&lt;/code&gt; 后面。而 &lt;code&gt;-i&lt;/code&gt; 根本不是命令，所以自然找不到。&lt;/p&gt;
&lt;p&gt;那么如果希望加入 &lt;code&gt;-i&lt;/code&gt; 这参数，就必须重新完整的输入这个命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run myip curl -s http://myip.ipip.net -i
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这显然不是很好的解决方案，而使用 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 就可以解决这个问题。现在重新用 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 来实现这个镜像：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;ubuntu:18.04&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; apt-get update &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get install -y curl &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm -rf /var/lib/apt/lists/*
&lt;span class="k"&gt;ENTRYPOINT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;curl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;-s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;http://myip.ipip.net&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这次再来尝试直接使用 &lt;code&gt;docker run myip -i&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run myip
当前 IP：61.148.226.66 来自：北京市 联通

$ docker run myip -i
HTTP/1.1 &lt;span class="m"&gt;200&lt;/span&gt; OK
Server: nginx/1.8.0
Date: Tue, &lt;span class="m"&gt;22&lt;/span&gt; Nov &lt;span class="m"&gt;2016&lt;/span&gt; &lt;span class="m"&gt;05&lt;/span&gt;:12:40 GMT
Content-Type: text/html&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nv"&gt;charset&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;UTF-8
Vary: Accept-Encoding
X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
X-Cache: MISS from cache-2
X-Cache-Lookup: MISS from cache-2:80
X-Cache: MISS from proxy-2_6
Transfer-Encoding: chunked
Via: &lt;span class="m"&gt;1&lt;/span&gt;.1 cache-2:80, &lt;span class="m"&gt;1&lt;/span&gt;.1 proxy-2_6:8006
Connection: keep-alive
​
当前 IP：61.148.226.66 来自：北京市 联通
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，这次成功了。这是因为当存在 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 后，&lt;code&gt;CMD&lt;/code&gt; 的内容将会作为参数传给 &lt;code&gt;ENTRYPOINT&lt;/code&gt;，而这里 &lt;code&gt;-i&lt;/code&gt; 就是新的 &lt;code&gt;CMD&lt;/code&gt;，因此会作为参数传给 &lt;code&gt;curl&lt;/code&gt;，从而达到了预期的效果。&lt;/p&gt;
&lt;h4&gt;场景二：应用运行前的准备工作&lt;/h4&gt;
&lt;p&gt;启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;mysql&lt;/code&gt; 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。&lt;/p&gt;
&lt;p&gt;此外，可能希望避免使用 &lt;code&gt;root&lt;/code&gt; 用户去启动服务，从而提高安全性，而在启动服务前还需要以 &lt;code&gt;root&lt;/code&gt; 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 &lt;code&gt;root&lt;/code&gt; 身份执行，方便调试等。&lt;/p&gt;
&lt;p&gt;这些准备工作是和容器 &lt;code&gt;CMD&lt;/code&gt; 无关的，无论 &lt;code&gt;CMD&lt;/code&gt; 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 中去执行，而这个脚本会将接到的参数（也就是 &lt;code&gt;&amp;lt;CMD&amp;gt;&lt;/code&gt;）作为命令，在脚本最后执行。比如官方镜像 &lt;code&gt;redis&lt;/code&gt; 中就是这么做的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;alpine:3.4&lt;/span&gt;
...
&lt;span class="k"&gt;RUN&lt;/span&gt; addgroup -S redis &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; adduser -S -G redis redis
...
&lt;span class="k"&gt;ENTRYPOINT&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;docker-entrypoint.sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 6379&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;redis-server&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 &lt;code&gt;ENTRYPOINT&lt;/code&gt; 为 &lt;code&gt;docker-entrypoint.sh&lt;/code&gt; 脚本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/sh&lt;/span&gt;
...
&lt;span class="c1"&gt;# allow the container to be started with `--user`&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;redis-server&amp;#39;&lt;/span&gt; -a &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;id -u&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
    find . &lt;span class="se"&gt;\!&lt;/span&gt; -user redis -exec chown redis &lt;span class="s1"&gt;&amp;#39;{}&amp;#39;&lt;/span&gt; +
    &lt;span class="nb"&gt;exec&lt;/span&gt; gosu redis &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$0&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;

&lt;span class="nb"&gt;exec&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$@&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该脚本的内容就是根据 &lt;code&gt;CMD&lt;/code&gt; 的内容来判断，如果是 &lt;code&gt;redis-server&lt;/code&gt; 的话，则切换到 &lt;code&gt;redis&lt;/code&gt; 用户身份启动服务器，否则依旧使用 &lt;code&gt;root&lt;/code&gt; 身份执行。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker run -it redis id
&lt;span class="nv"&gt;uid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;gid&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="nv"&gt;groups&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;root&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;ENV 设置环境变量&lt;/h3&gt;
&lt;p&gt;格式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ENV &amp;lt;key1&amp;gt;=&amp;lt;value1&amp;gt; &amp;lt;key2&amp;gt;=&amp;lt;value2&amp;gt;...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 &lt;code&gt;RUN&lt;/code&gt;，还是运行时的应用，都可以直接使用这里定义的环境变量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ENV&lt;/span&gt; &lt;span class="nv"&gt;VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.0 &lt;span class="nv"&gt;DEBUG&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;on &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="nv"&gt;NAME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Happy Feet&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。&lt;/p&gt;
&lt;p&gt;定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 &lt;code&gt;node&lt;/code&gt; 镜像 &lt;code&gt;Dockerfile&lt;/code&gt; 中，就有类似这样的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;ENV&lt;/span&gt; NODE_VERSION &lt;span class="m"&gt;7&lt;/span&gt;.2.0

&lt;span class="k"&gt;RUN&lt;/span&gt; curl -SLO &lt;span class="s2"&gt;&amp;quot;https://nodejs.org/dist/v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;/node-v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;-linux-x64.tar.xz&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; curl -SLO &lt;span class="s2"&gt;&amp;quot;https://nodejs.org/dist/v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;/SHASUMS256.txt.asc&amp;quot;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot; node-v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;-linux-x64.tar.xz\$&amp;quot;&lt;/span&gt; SHASUMS256.txt &lt;span class="p"&gt;|&lt;/span&gt; sha256sum -c - &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; tar -xJf &lt;span class="s2"&gt;&amp;quot;node-v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;-linux-x64.tar.xz&amp;quot;&lt;/span&gt; -C /usr/local --strip-components&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; rm &lt;span class="s2"&gt;&amp;quot;node-v&lt;/span&gt;&lt;span class="nv"&gt;$NODE_VERSION&lt;/span&gt;&lt;span class="s2"&gt;-linux-x64.tar.xz&amp;quot;&lt;/span&gt; SHASUMS256.txt.asc SHASUMS256.txt &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; ln -s /usr/local/bin/node /usr/local/bin/nodejs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里先定义了环境变量 &lt;code&gt;NODE_VERSION&lt;/code&gt;，其后的 &lt;code&gt;RUN&lt;/code&gt; 这层里，多次使用 &lt;code&gt;$NODE_VERSION&lt;/code&gt; 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 &lt;code&gt;7.2.0&lt;/code&gt; 即可，&lt;code&gt;Dockerfile&lt;/code&gt; 构建维护变得更轻松了。&lt;/p&gt;
&lt;p&gt;下列指令可以支持环境变量展开： &lt;code&gt;ADD&lt;/code&gt;、&lt;code&gt;COPY&lt;/code&gt;、&lt;code&gt;ENV&lt;/code&gt;、&lt;code&gt;EXPOSE&lt;/code&gt;、&lt;code&gt;FROM&lt;/code&gt;、&lt;code&gt;LABEL&lt;/code&gt;、&lt;code&gt;USER&lt;/code&gt;、&lt;code&gt;WORKDIR&lt;/code&gt;、&lt;code&gt;VOLUME&lt;/code&gt;、&lt;code&gt;STOPSIGNAL&lt;/code&gt;、&lt;code&gt;ONBUILD&lt;/code&gt;、&lt;code&gt;RUN&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，可以让一份 &lt;code&gt;Dockerfile&lt;/code&gt; 制作更多的镜像，只需使用不同的环境变量即可。&lt;/p&gt;
&lt;h3&gt;VOLUME 定义匿名卷&lt;/h3&gt;
&lt;p&gt;格式为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;VOLUME ["&amp;lt;路径1&amp;gt;", "&amp;lt;路径2&amp;gt;"...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VOLUME &amp;lt;路径&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之前说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 &lt;code&gt;Dockerfile&lt;/code&gt; 中，可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;VOLUME&lt;/span&gt;&lt;span class="s"&gt; /data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的 &lt;code&gt;/data&lt;/code&gt; 目录就会在运行时自动挂载为匿名卷，任何向 &lt;code&gt;/data&lt;/code&gt; 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker run -d -v mydata:/data xxxx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这行命令中，就使用了 &lt;code&gt;mydata&lt;/code&gt; 这个命名卷挂载到了 &lt;code&gt;/data&lt;/code&gt; 这个位置，替代了 &lt;code&gt;Dockerfile&lt;/code&gt; 中定义的匿名卷的挂载配置。&lt;/p&gt;
&lt;h3&gt;EXPOSE 暴露端口&lt;/h3&gt;
&lt;p&gt;格式为 &lt;code&gt;EXPOSE &amp;lt;端口1&amp;gt; [&amp;lt;端口2&amp;gt;...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EXPOSE&lt;/code&gt; 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 &lt;code&gt;docker run -P&lt;/code&gt; 时，会自动随机映射 &lt;code&gt;EXPOSE&lt;/code&gt; 的端口。&lt;/p&gt;
&lt;p&gt;要将 &lt;code&gt;EXPOSE&lt;/code&gt; 和在运行时使用 &lt;code&gt;-p &amp;lt;宿主端口&amp;gt;:&amp;lt;容器端口&amp;gt;&lt;/code&gt; 区分开来。&lt;code&gt;-p&lt;/code&gt;，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 &lt;code&gt;EXPOSE&lt;/code&gt; 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。&lt;/p&gt;
&lt;h3&gt;WORKDIR 指定工作目录&lt;/h3&gt;
&lt;p&gt;格式为 &lt;code&gt;WORKDIR &amp;lt;工作目录路径&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;WORKDIR&lt;/code&gt; 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，&lt;code&gt;WORKDIR&lt;/code&gt; 会帮你建立目录。&lt;/p&gt;
&lt;p&gt;之前提到一些初学者常犯的错误是把 &lt;code&gt;Dockerfile&lt;/code&gt; 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; /app
&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &amp;gt; world.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果将这个 &lt;code&gt;Dockerfile&lt;/code&gt; 进行构建镜像运行后，会发现找不到 &lt;code&gt;/app/world.txt&lt;/code&gt; 文件，或者其内容不是 &lt;code&gt;hello&lt;/code&gt;。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 &lt;code&gt;Dockerfile&lt;/code&gt; 中，这两行 &lt;code&gt;RUN&lt;/code&gt; 命令的执行环境根本不同，是两个完全不同的容器。这就是对 &lt;code&gt;Dockerfile&lt;/code&gt; 构建分层存储的概念不了解所导致的错误。&lt;/p&gt;
&lt;p&gt;之前说过每一个 &lt;code&gt;RUN&lt;/code&gt; 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 &lt;code&gt;RUN cd /app&lt;/code&gt; 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。&lt;/p&gt;
&lt;p&gt;因此如果需要改变以后各层的工作目录的位置，那么应该使用 &lt;code&gt;WORKDIR&lt;/code&gt; 指令。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /app&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &amp;gt; world.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你的 &lt;code&gt;WORKDIR&lt;/code&gt; 指令使用的相对路径，那么所切换的路径与之前的 &lt;code&gt;WORKDIR&lt;/code&gt; 有关：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /a&lt;/span&gt;
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; b&lt;/span&gt;
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; c&lt;/span&gt;

&lt;span class="k"&gt;RUN&lt;/span&gt; pwd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;pwd&lt;/code&gt; 输出的结果为 &lt;code&gt;/a/b/c&lt;/code&gt;。&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj32/</guid><pubDate>Sun, 20 Sep 2020 13:30:00 +0806</pubDate></item><item><title>Docker Compose笔记</title><link>/Xuxx_Blogs/archives/bj33/</link><description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 &lt;code&gt;OpenStack&lt;/code&gt; 中的 &lt;code&gt;Heat&lt;/code&gt; 十分类似。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。&lt;/p&gt;
&lt;p&gt;通过第一部分中的介绍，知道使用一个 &lt;code&gt;Dockerfile&lt;/code&gt; 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 恰好满足了这样的需求。它允许用户通过一个单独的 &lt;code&gt;docker-compose.yml&lt;/code&gt; 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 中有两个重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。&lt;/li&gt;
&lt;li&gt;项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件中定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 &lt;code&gt;Compose&lt;/code&gt; 来进行编排管理。&lt;/p&gt;
&lt;h2&gt;安装与卸载&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 支持 Linux、macOS、Windows 10 三大平台。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Compose&lt;/code&gt; 可以通过 Python 的包管理工具 &lt;code&gt;pip&lt;/code&gt; 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Docker Desktop for Mac/Windows&lt;/code&gt; 自带 &lt;code&gt;docker-compose&lt;/code&gt; 二进制文件，安装 Docker 之后可以直接使用。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-compose --versiondocker-compose version 1.25.5, build 4667896b&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Linux 系统请使用以下介绍的方法安装。&lt;/p&gt;
&lt;h3&gt;二进制包安装&lt;/h3&gt;
&lt;p&gt;在 Linux 上的也安装十分简单，从 &lt;a href="https://github.com/docker/compose/releases"&gt;官方 GitHub Release&lt;/a&gt; 处直接下载编译好的二进制文件即可。&lt;/p&gt;
&lt;p&gt;例如，在 Linux 64 位系统上直接下载对应的二进制包。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-&lt;span class="sb"&gt;`&lt;/span&gt;uname -s&lt;span class="sb"&gt;`&lt;/span&gt;-&lt;span class="sb"&gt;`&lt;/span&gt;uname -m&lt;span class="sb"&gt;`&lt;/span&gt; &amp;gt; /usr/local/bin/docker-compose

$ sudo chmod +x /usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;PIP 安装&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;注：&lt;/em&gt; &lt;code&gt;x86_64&lt;/code&gt; 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 &lt;code&gt;ARM&lt;/code&gt; (例如，树莓派)，再使用 &lt;code&gt;pip&lt;/code&gt; 安装。&lt;/p&gt;
&lt;p&gt;这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。&lt;/p&gt;
&lt;p&gt;执行安装命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo pip install -U docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到类似如下输出，说明安装成功。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Collecting docker-compose
  Downloading docker-compose-1.25.5.tar.gz &lt;span class="o"&gt;(&lt;/span&gt;149kB&lt;span class="o"&gt;)&lt;/span&gt;: 149kB downloaded
...
Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;bash 补全命令&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &amp;gt; /etc/bash_completion.d/docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;卸载&lt;/h3&gt;
&lt;p&gt;如果是二进制包方式安装的，删除二进制文件即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo rm /usr/local/bin/docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是通过 &lt;code&gt;pip&lt;/code&gt; 安装的，则执行如下命令即可删除。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo pip uninstall docker-compose
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;h3&gt;术语&lt;/h3&gt;
&lt;p&gt;首先介绍几个术语。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务 (&lt;code&gt;service&lt;/code&gt;)：一个应用容器，实际上可以运行多个相同镜像的实例。&lt;/li&gt;
&lt;li&gt;项目 (&lt;code&gt;project&lt;/code&gt;)：由一组关联的应用容器组成的一个完整业务单元。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可见，一个项目可以由多个服务（容器）关联而成，&lt;code&gt;Compose&lt;/code&gt; 面向项目进行管理。&lt;/p&gt;
&lt;h3&gt;场景&lt;/h3&gt;
&lt;p&gt;最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。&lt;/p&gt;
&lt;p&gt;下面用 &lt;code&gt;Python&lt;/code&gt; 来建立一个能够记录页面访问次数的 web 网站。&lt;/p&gt;
&lt;h4&gt;web 应用&lt;/h4&gt;
&lt;p&gt;新建文件夹，在该目录中编写 &lt;code&gt;app.py&lt;/code&gt; 文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;flask&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;redis&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Redis&lt;/span&gt;

&lt;span class="n"&gt;app&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Flask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="vm"&gt;__name__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;redis&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Redis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;redis&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;6379&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nd"&gt;@app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;route&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;redis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;incr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hits&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;Hello World! 该页面已被访问 &lt;/span&gt;&lt;span class="si"&gt;{}&lt;/span&gt;&lt;span class="s1"&gt; 次。&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;app&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;0.0.0.0&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Dockerfile&lt;/h4&gt;
&lt;p&gt;编写 &lt;code&gt;Dockerfile&lt;/code&gt; 文件，内容为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt; &lt;span class="s"&gt;python:3.6-alpine&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt; . /code
&lt;span class="k"&gt;WORKDIR&lt;/span&gt;&lt;span class="s"&gt; /code&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; pip install redis flask
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;app.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;docker-compose.yml&lt;/h4&gt;
&lt;p&gt;编写 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件，这个是 Compose 使用的主模板文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;web&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;build&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;.&lt;/span&gt;
    &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
     &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;5000:5000&amp;quot;&lt;/span&gt;
  &lt;span class="nt"&gt;redis&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;redis:alpine&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;运行 compose 项目&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose up
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时访问本地 &lt;code&gt;5000&lt;/code&gt; 端口，每次刷新页面，计数就会加 1。&lt;/p&gt;
&lt;h2&gt;命令说明&lt;/h2&gt;
&lt;h3&gt;命令对象与格式&lt;/h3&gt;
&lt;p&gt;对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。&lt;/p&gt;
&lt;p&gt;执行 &lt;code&gt;docker-compose [COMMAND] --help&lt;/code&gt; 或者 &lt;code&gt;docker-compose help [COMMAND]&lt;/code&gt; 可以查看具体某个命令的使用格式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker-compose&lt;/code&gt; 命令的基本的使用格式是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;docker-compose &lt;span class="o"&gt;[&lt;/span&gt;-f&lt;span class="o"&gt;=&lt;/span&gt;&amp;lt;arg&amp;gt;...&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;COMMAND&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt;ARGS...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;命令选项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f, --file FILE&lt;/code&gt; 指定使用的 Compose 模板文件，默认为 &lt;code&gt;docker-compose.yml&lt;/code&gt;，可以多次指定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p, --project-name NAME&lt;/code&gt; 指定项目名称，默认将使用所在目录名称作为项目名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--x-networking&lt;/code&gt; 使用 Docker 的可拔插网络后端特性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--x-network-driver DRIVER&lt;/code&gt; 指定网络后端的驱动，默认为 &lt;code&gt;bridge&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--verbose&lt;/code&gt; 输出更多调试信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v, --version&lt;/code&gt; 打印版本并退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;命令使用说明&lt;/h3&gt;
&lt;h4&gt;build&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose build [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;构建（重新构建）项目中的服务容器。&lt;/p&gt;
&lt;p&gt;服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。&lt;/p&gt;
&lt;p&gt;可以随时在项目目录下运行 &lt;code&gt;docker-compose build&lt;/code&gt; 来重新构建服务。&lt;/p&gt;
&lt;p&gt;选项包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--force-rm&lt;/code&gt; 删除构建过程中的临时容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-cache&lt;/code&gt; 构建镜像过程中不使用 cache（这将加长构建过程）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--pull&lt;/code&gt; 始终尝试通过 pull 来获取更新版本的镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;config&lt;/h4&gt;
&lt;p&gt;验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。&lt;/p&gt;
&lt;h4&gt;down&lt;/h4&gt;
&lt;p&gt;此命令将会停止 &lt;code&gt;up&lt;/code&gt; 命令所启动的容器，并移除网络&lt;/p&gt;
&lt;h4&gt;exec&lt;/h4&gt;
&lt;p&gt;进入指定的容器。&lt;/p&gt;
&lt;h4&gt;help&lt;/h4&gt;
&lt;p&gt;获得一个命令的帮助。&lt;/p&gt;
&lt;h4&gt;images&lt;/h4&gt;
&lt;p&gt;列出 Compose 文件中包含的镜像。&lt;/p&gt;
&lt;h4&gt;kill&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose kill [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通过发送 &lt;code&gt;SIGKILL(终止进程)&lt;/code&gt; 信号来强制停止服务容器。&lt;/p&gt;
&lt;p&gt;支持通过 &lt;code&gt;-s&lt;/code&gt; 参数来指定发送的信号，例如通过如下指令发送 &lt;code&gt;SIGINT&lt;/code&gt; 信号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker-compose kill -s SIGINT&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;logs&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose logs [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 &lt;code&gt;--no-color&lt;/code&gt; 来关闭颜色。&lt;/p&gt;
&lt;p&gt;该命令在调试问题的时候十分有用。&lt;/p&gt;
&lt;h4&gt;pause&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose pause [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;暂停一个服务容器。&lt;/p&gt;
&lt;h4&gt;port&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose port [options] SERVICE PRIVATE_PORT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;打印某个容器端口所映射的公共端口。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--protocol=proto&lt;/code&gt; 指定端口协议，tcp（默认值）或者 udp。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--index=index&lt;/code&gt; 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;ps&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose ps [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;列出项目中目前的所有容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-q&lt;/code&gt; 只打印容器的 ID 信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;pull&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose pull [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;拉取服务依赖的镜像。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--ignore-pull-failures&lt;/code&gt; 忽略拉取镜像过程中的错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;push&lt;/h4&gt;
&lt;p&gt;推送服务依赖的镜像到 Docker 镜像仓库。&lt;/p&gt;
&lt;h4&gt;restart&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose restart [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;重启项目中的服务。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 指定重启前停止容器的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;rm&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose rm [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;删除所有（停止状态的）服务容器。推荐先执行 &lt;code&gt;docker-compose stop&lt;/code&gt; 命令来停止容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f, --force&lt;/code&gt; 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 删除容器所挂载的数据卷。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;run&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose run [options] [-p PORT...] [-e KEY=VAL...] SERVICE [COMMAND] [ARGS...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在指定服务上执行一个命令。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose run ubuntu ping docker.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将会启动一个 ubuntu 服务容器，并执行 &lt;code&gt;ping docker.com&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。&lt;/p&gt;
&lt;p&gt;该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。&lt;/p&gt;
&lt;p&gt;两个不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定命令将会覆盖原有的自动运行命令；&lt;/li&gt;
&lt;li&gt;不会自动创建端口，以避免冲突。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果不希望自动启动关联的容器，可以使用 &lt;code&gt;--no-deps&lt;/code&gt; 选项，例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose run --no-deps web python manage.py shell
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将不会启动 web 容器所关联的其它容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 后台运行容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name NAME&lt;/code&gt; 为容器指定一个名字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--entrypoint CMD&lt;/code&gt; 覆盖默认的容器启动指令。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e KEY=VAL&lt;/code&gt; 设置环境变量值，可多次使用选项来设置多个环境变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u, --user=""&lt;/code&gt; 指定运行容器的用户名或者 uid。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-deps&lt;/code&gt; 不自动启动关联的服务容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--rm&lt;/code&gt; 运行命令后自动删除容器，&lt;code&gt;d&lt;/code&gt; 模式下将忽略。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p, --publish=[]&lt;/code&gt; 映射容器端口到本地主机。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--service-ports&lt;/code&gt; 配置服务端口并映射到本地主机。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-T&lt;/code&gt; 不分配伪 tty，意味着依赖 tty 的指令将无法运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;scale&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose scale [options] [SERVICE=NUM...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;设置指定服务运行的容器个数。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;service=num&lt;/code&gt; 的参数来设置数量。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker-compose scale &lt;span class="nv"&gt;web&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;3&lt;/span&gt; &lt;span class="nv"&gt;db&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。&lt;/p&gt;
&lt;p&gt;一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;start&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose start [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;启动已经存在的服务容器。&lt;/p&gt;
&lt;h4&gt;stop&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose stop [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;停止已经处于运行状态的容器，但不删除它。通过 &lt;code&gt;docker-compose start&lt;/code&gt; 可以再次启动这些容器。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;top&lt;/h4&gt;
&lt;p&gt;查看各个服务容器内运行的进程。&lt;/p&gt;
&lt;h4&gt;unpause&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose unpause [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;恢复处于暂停状态中的服务。&lt;/p&gt;
&lt;h4&gt;up&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose up [options] [SERVICE...]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。&lt;/p&gt;
&lt;p&gt;链接的服务都将会被自动启动，除非已经处于运行状态。&lt;/p&gt;
&lt;p&gt;可以说，大部分时候都可以直接通过该命令来启动一个项目。&lt;/p&gt;
&lt;p&gt;默认情况，&lt;code&gt;docker-compose up&lt;/code&gt; 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。&lt;/p&gt;
&lt;p&gt;当通过 &lt;code&gt;Ctrl-C&lt;/code&gt; 停止命令时，所有容器将会停止。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;docker-compose up -d&lt;/code&gt;，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。&lt;/p&gt;
&lt;p&gt;默认情况，如果服务容器已经存在，&lt;code&gt;docker-compose up&lt;/code&gt; 将会尝试停止容器，然后重新创建（保持使用 &lt;code&gt;volumes-from&lt;/code&gt; 挂载的卷），以保证新启动的服务匹配 &lt;code&gt;docker-compose.yml&lt;/code&gt; 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 &lt;code&gt;docker-compose up --no-recreate&lt;/code&gt;。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 &lt;code&gt;docker-compose up --no-deps -d &amp;lt;SERVICE_NAME&amp;gt;&lt;/code&gt; 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。&lt;/p&gt;
&lt;p&gt;选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 在后台运行服务容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-color&lt;/code&gt; 不使用颜色来区分不同的服务的控制台输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-deps&lt;/code&gt; 不启动服务所链接的容器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--force-recreate&lt;/code&gt; 强制重新创建容器，不能与 &lt;code&gt;--no-recreate&lt;/code&gt; 同时使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-recreate&lt;/code&gt; 如果容器已经存在了，则不重新创建，不能与 &lt;code&gt;--force-recreate&lt;/code&gt; 同时使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-build&lt;/code&gt; 不自动构建缺失的服务镜像。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t, --timeout TIMEOUT&lt;/code&gt; 停止容器时候的超时（默认为 10 秒）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;version&lt;/h4&gt;
&lt;p&gt;格式为 &lt;code&gt;docker-compose version&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;打印版本信息。&lt;/p&gt;
&lt;h2&gt;Compose 模板文件&lt;/h2&gt;
&lt;p&gt;模板文件是使用 &lt;code&gt;Compose&lt;/code&gt; 的核心，涉及到的指令关键字也比较多。但这里面大部分指令跟 &lt;code&gt;docker run&lt;/code&gt; 相关参数的含义都是类似的。&lt;/p&gt;
&lt;p&gt;默认的模板文件名称为 &lt;code&gt;docker-compose.yml&lt;/code&gt;，格式为 YAML 格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3"

services:
  webapp:
    image: examples/web
    ports:
      - "80:80"
    volumes:
      - "/data"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意每个服务都必须通过 &lt;code&gt;image&lt;/code&gt; 指令指定镜像或 &lt;code&gt;build&lt;/code&gt; 指令（需要 Dockerfile）等来自动构建生成镜像。&lt;/p&gt;
&lt;p&gt;如果使用 &lt;code&gt;build&lt;/code&gt; 指令，在 &lt;code&gt;Dockerfile&lt;/code&gt; 中设置的选项(例如：&lt;code&gt;CMD&lt;/code&gt;, &lt;code&gt;EXPOSE&lt;/code&gt;, &lt;code&gt;VOLUME&lt;/code&gt;, &lt;code&gt;ENV&lt;/code&gt; 等) 将会自动被获取，无需在 &lt;code&gt;docker-compose.yml&lt;/code&gt; 中重复设置。&lt;/p&gt;
&lt;p&gt;下面分别介绍各个指令的用法。&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;build&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定 &lt;code&gt;Dockerfile&lt;/code&gt; 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 &lt;code&gt;Compose&lt;/code&gt; 将会利用它自动构建这个镜像，然后使用这个镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: '3'
services:
  webapp:
    build: ./dir&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以使用 &lt;code&gt;context&lt;/code&gt; 指令指定 &lt;code&gt;Dockerfile&lt;/code&gt; 所在文件夹的路径。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;dockerfile&lt;/code&gt; 指令指定 &lt;code&gt;Dockerfile&lt;/code&gt; 文件名。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;arg&lt;/code&gt; 指令指定构建镜像时的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: '3'
services:
  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;cache_from&lt;/code&gt; 指定构建镜像的缓存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;build:
  context: .
  cache_from:
    - alpine:latest
    - corp/web_app:3.14&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;cap_add, cap_drop&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定容器的内核能力（capacity）分配。&lt;/p&gt;
&lt;p&gt;例如，让容器拥有所有能力可以指定为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cap_add:
  - ALL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;去掉 NET_ADMIN 能力可以指定为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cap_drop:
  - NET_ADMIN&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;command&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;覆盖容器启动后默认执行的命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command: echo "hello world"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;cgroup_parent&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定父 &lt;code&gt;cgroup&lt;/code&gt; 组，意味着将继承该组的资源限制。&lt;/p&gt;
&lt;p&gt;例如，创建了一个 cgroup 组名称为 &lt;code&gt;cgroups_1&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cgroup_parent: cgroups_1&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;container_name&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定容器名称。默认将会使用 &lt;code&gt;项目名称_服务名称_序号&lt;/code&gt; 这样的格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;container_name: docker-web-container&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;code&gt;devices&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定设备映射关系。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;devices:
  - "/dev/ttyUSB1:/dev/ttyUSB0"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;depends_on&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;解决容器的依赖、启动先后的问题。以下例子中会先启动 &lt;code&gt;redis&lt;/code&gt; &lt;code&gt;db&lt;/code&gt; 再启动 &lt;code&gt;web&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: '3'

services:
  web:
    build: .
    depends_on:
      - db
      - redis

  redis:
    image: redis

  db:
    image: postgres&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;&lt;p&gt;注意：&lt;code&gt;web&lt;/code&gt; 服务不会等待 &lt;code&gt;redis&lt;/code&gt; &lt;code&gt;db&lt;/code&gt; 「完全启动」之后才启动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;code&gt;dns&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;自定义 &lt;code&gt;DNS&lt;/code&gt; 服务器。可以是一个值，也可以是一个列表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dns: 8.8.8.8

dns:
  - 8.8.8.8
  - 114.114.114.114&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;dns_search&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;配置 &lt;code&gt;DNS&lt;/code&gt; 搜索域。可以是一个值，也可以是一个列表。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dns_search: example.com

dns_search:
  - domain1.example.com
  - domain2.example.com&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;tmpfs&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;挂载一个 tmpfs 文件系统到容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmpfs: /run
tmpfs:
  - /run
  - /tmp&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;env_file&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;从文件中获取环境变量，可以为单独的文件路径或列表。&lt;/p&gt;
&lt;p&gt;如果通过 &lt;code&gt;docker-compose -f FILE&lt;/code&gt; 方式来指定 Compose 模板文件，则 &lt;code&gt;env_file&lt;/code&gt; 中变量的路径会基于模板文件路径。&lt;/p&gt;
&lt;p&gt;如果有变量名称与 &lt;code&gt;environment&lt;/code&gt; 指令冲突，则按照惯例，以后者为准。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;env_file: .env

env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;环境变量文件中每一行必须符合格式，支持 &lt;code&gt;#&lt;/code&gt; 开头的注释行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# common.env: Set development environment
PROG_ENV=development&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;environment&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;设置环境变量。你可以使用数组或字典两种格式。&lt;/p&gt;
&lt;p&gt;只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;environment:
  RACK_ENV: development
  SESSION_SECRET:

environment:
  - RACK_ENV=development
  - SESSION_SECRET&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果变量名称或者值中用到 &lt;code&gt;true|false，yes|no&lt;/code&gt; 等表达 &lt;a href="https://yaml.org/type/bool.html"&gt;布尔&lt;/a&gt; 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;expose&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;暴露端口，但不映射到宿主机，只被连接的服务访问。&lt;/p&gt;
&lt;p&gt;仅可以指定内部端口为参数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expose:
 - "3000"
 - "8000"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;external_links&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;&lt;p&gt;注意：不建议使用该指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;链接到 &lt;code&gt;docker-compose.yml&lt;/code&gt; 外部的容器，甚至并非 &lt;code&gt;Compose&lt;/code&gt; 管理的外部容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;external_links:
 - redis_1
 - project_db_1:mysql
 - project_db_1:postgresql&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;extra_hosts&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;类似 Docker 中的 &lt;code&gt;--add-host&lt;/code&gt; 参数，指定额外的 host 名称映射信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extra_hosts:
 - "googledns:8.8.8.8"
 - "dockerhub:52.1.157.61"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会在启动后的服务容器中 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件中添加如下两条条目。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8.8.8.8 googledns
52.1.157.61 dockerhub&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;healthcheck&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;通过命令检查容器是否健康运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost"]
  interval: 1m30s
  timeout: 10s
  retries: 3&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;image&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定为镜像名称或镜像 ID。如果镜像在本地不存在，&lt;code&gt;Compose&lt;/code&gt; 将会尝试拉取这个镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;image: ubuntu
image: orchardup/postgresql
image: a4bc65fd&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;labels:
  com.startupteam.description: "webapp for a startup team"
  com.startupteam.department: "devops department"
  com.startupteam.release: "rc3 for v1.0"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;links&lt;/code&gt;&lt;/h4&gt;
&lt;blockquote&gt;&lt;p&gt;注意：不推荐使用该指令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;配置日志选项。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logging:
  driver: syslog
  options:
    syslog-address: "tcp://192.168.0.42:123"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前支持三种日志驱动类型。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;driver: "json-file"
driver: "syslog"
driver: "none"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;options&lt;/code&gt; 配置日志驱动的相关参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;options:
  max-size: "200k"
  max-file: "10"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;network_mode&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;设置网络模式。使用和 &lt;code&gt;docker run&lt;/code&gt; 的 &lt;code&gt;--network&lt;/code&gt; 参数一样的值。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;network_mode: "bridge"
network_mode: "host"
network_mode: "none"
network_mode: "service:[service name]"
network_mode: "container:[container name/id]"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;networks&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;配置容器连接的网络。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3"
services:

  some-service:
    networks:
     - some-network
     - other-network

networks:
  some-network:
  other-network:&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;pid&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pid: "host"&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;ports&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;暴露端口信息。&lt;/p&gt;
&lt;p&gt;使用宿主端口：容器端口 &lt;code&gt;(HOST:CONTAINER)&lt;/code&gt; 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ports:
 - "3000"
 - "8000:8000"
 - "49100:22"
 - "127.0.0.1:8001:8001"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意：当使用&lt;/em&gt; &lt;em&gt;HOST:CONTAINER&lt;/em&gt; &lt;em&gt;格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为&lt;/em&gt; &lt;em&gt;YAML&lt;/em&gt; &lt;em&gt;会自动解析&lt;/em&gt; &lt;em&gt;xx:yy&lt;/em&gt; &lt;em&gt;这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;存储敏感数据，例如 &lt;code&gt;mysql&lt;/code&gt; 服务密码。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3.1"
services:

mysql:
  image: mysql
  environment:
    MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
  secrets:
    - db_root_password
    - my_other_secret

secrets:
  my_secret:
    file: ./my_secret.txt
  my_other_secret:
    external: true&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;security_opt&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;security_opt:
    - label:user:USER
    - label:role:ROLE&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;stop_signal&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stop_signal: SIGUSR1&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;sysctls&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;配置容器内核参数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sysctls:
  net.core.somaxconn: 1024
  net.ipv4.tcp_syncookies: 0

sysctls:
  - net.core.somaxconn=1024
  - net.ipv4.tcp_syncookies=0&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;ulimits&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;指定容器的 ulimits 限制值。&lt;/p&gt;
&lt;p&gt;例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ulimits:
    nproc: 65535
    nofile:
      soft: 20000
      hard: 40000&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;code&gt;volumes&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;数据卷所挂载路径设置。可以设置为宿主机路径(&lt;code&gt;HOST:CONTAINER&lt;/code&gt;)或者数据卷名称(&lt;code&gt;VOLUME:CONTAINER&lt;/code&gt;)，并且可以设置访问模式 （&lt;code&gt;HOST:CONTAINER:ro&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;该指令中路径支持相对路径。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;volumes:
 - /var/lib/mysql
 - cache/:/tmp/cache
 - ~/configs:/etc/configs/:ro&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果路径为数据卷名称，必须在文件中配置数据卷。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3"

services:
  my_src:
    image: mysql:8.0
    volumes:
      - mysql_data:/var/lib/mysql

volumes:
  mysql_data:&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;其它指令&lt;/h4&gt;
&lt;p&gt;此外，还有包括 &lt;code&gt;domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir&lt;/code&gt; 等指令，基本跟 &lt;code&gt;docker run&lt;/code&gt; 中对应参数的功能一致。&lt;/p&gt;
&lt;p&gt;指定服务容器启动后执行的入口文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;entrypoint: /code/entrypoint.sh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定容器中运行应用的用户名。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user: nginx&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定容器中工作目录。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;working_dir: /code&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定容器中搜索域名、主机名、mac 地址等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;domainname: your_website.comhostname: testmac_address: 08-00-27-00-0C-0A&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;允许容器中运行一些特权命令。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;privileged: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 &lt;code&gt;always&lt;/code&gt; 或者 &lt;code&gt;unless-stopped&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;restart: always&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;read_only: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打开标准输入，可以接受外部输入。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stdin_open: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模拟一个伪终端。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tty: true&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;读取变量&lt;/h4&gt;
&lt;p&gt;Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 &lt;code&gt;.env&lt;/code&gt; 文件中的变量。&lt;/p&gt;
&lt;p&gt;例如，下面的 Compose 文件将从运行它的环境中读取变量 &lt;code&gt;${MONGO_VERSION}&lt;/code&gt; 的值，并写入执行的指令中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;version: "3"
services:

db:
  image: "mongo:${MONGO_VERSION}"&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果执行 &lt;code&gt;MONGO_VERSION=3.2 docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:3.2&lt;/code&gt; 镜像的容器；如果执行 &lt;code&gt;MONGO_VERSION=2.8 docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:2.8&lt;/code&gt; 镜像的容器。&lt;/p&gt;
&lt;p&gt;若当前目录存在 &lt;code&gt;.env&lt;/code&gt; 文件，执行 &lt;code&gt;docker-compose&lt;/code&gt; 命令时将从该文件中读取变量。&lt;/p&gt;
&lt;p&gt;在当前目录新建 &lt;code&gt;.env&lt;/code&gt; 文件并写入以下内容。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 支持 # 号注释MONGO_VERSION=3.6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行 &lt;code&gt;docker-compose up&lt;/code&gt; 则会启动一个 &lt;code&gt;mongo:3.6&lt;/code&gt; 镜像的容器。&lt;/p&gt;
&lt;h2&gt;Docker Compose部署应用程序&lt;/h2&gt;
&lt;h3&gt;部署Tomcat&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3.1&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="nt"&gt;tomcat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
        &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tomcat&lt;/span&gt;
        &lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tomcat&lt;/span&gt;
        &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;8080:8080&lt;/span&gt;
        &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./webapps:/usr/local/tomcat/webapps&lt;/span&gt;
        &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="c1"&gt;#时区&lt;/span&gt;
          &lt;span class="nt"&gt;TZ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Asia/Shanghai&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;部署MySQL_1&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3.1&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="nt"&gt;db&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mysql&lt;/span&gt;
        &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
        &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nt"&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;123456&lt;/span&gt;
        &lt;span class="nt"&gt;command&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c1"&gt;#默认的身份验证插件&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--default-authentication-plugin=mysql_native_password&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;#字符集&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--character-set-server=utf8mb4&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;#字符集编码规则&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--collation-server=utf8mb4_general_ci&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;#数据行更新时，timestamp类型字段不更新为当前时间&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--explicit_defaults_for_timestamp=true&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;#表名小写,不区分大小写&lt;/span&gt;
            &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--lower_case_table_names=1&lt;/span&gt;
        &lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;tomcat&lt;/span&gt;
        &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;3306:3306&lt;/span&gt;
        &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./data:/var/lib/mysql/data&lt;/span&gt;
    &lt;span class="c1"&gt;#MySQL 的Web客户端&lt;/span&gt;
    &lt;span class="nt"&gt;adminer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;adminer&lt;/span&gt;
        &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
        &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
          &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;8080:8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;部署MySQL_2&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;3.1&amp;quot;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
 &lt;span class="nt"&gt;db&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
  &lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mysql&lt;/span&gt;
  &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mysql&lt;/span&gt;
  &lt;span class="nt"&gt;command&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
   &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--lower_case_table_names=1&lt;/span&gt;
   &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--character-set-server=utf8mb4&lt;/span&gt;
   &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--collation-server=utf8mb4_unicode_ci&lt;/span&gt;
   &lt;span class="l l-Scalar l-Scalar-Plain"&gt;--explicit_defaults_for_timestamp=true&lt;/span&gt;
  &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="nt"&gt;TZ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Asia/Shanghai&lt;/span&gt;
   &lt;span class="nt"&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root@123456&lt;/span&gt;
  &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;3306:3306&lt;/span&gt;
  &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./mysql/data:/var/lib/mysql&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./mysql/config:/etc/mysql/conf.d&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./mysql/log:/var/log/mysql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;部署RabbitMQ&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;rabbitmq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;rabbitmq:3.8.3-management&lt;/span&gt;
    &lt;span class="nt"&gt;container_name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;rabbitmq&lt;/span&gt;
    &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
    &lt;span class="nt"&gt;hostname&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;myRabbitmq&lt;/span&gt;
    &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;15672:15672&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;5672:5672&lt;/span&gt;
    &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./data:/var/lib/rabbitmq&lt;/span&gt;
    &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;RABBITMQ_DEFAULT_USER=root&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;RABBITMQ_DEFAULT_PASS=root&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;RABBITMQ_DEFAULT_USER&lt;/code&gt;  和  &lt;code&gt;RABBITMQ_DEFAULT_PASS&lt;/code&gt; 用来设置超级管理员的账号和密码，如果不设置，默认都是 &lt;code&gt;guest&lt;/code&gt; 。&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj33/</guid><pubDate>Mon, 21 Sep 2020 01:10:00 +0806</pubDate></item><item><title>Docker Compose部署GitLab</title><link>/Xuxx_Blogs/archives/bj34/</link><description>&lt;h2&gt;什么是GitLab&lt;/h2&gt;
&lt;p&gt;GitLab是利用 Ruby on Rails 的一个开源的版本管理系统，实现一个自托管的Git项目仓库，可通过Web界面进行访问公开的或者私人项目。它拥有与 Github 类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。团队成员可以利用内置的简单聊天程序(Wall)进行交流。它还提供一个代码片段收集功能可以轻松实现代码复用，便于日后有需要的时候进行查找。&lt;/p&gt;
&lt;h2&gt;部署GitLab&lt;/h2&gt;
&lt;p&gt;使用Docker来安装和运行GitLab中文版，&lt;code&gt;docker-compose.yml&lt;/code&gt;配置如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;web&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;twang2218/gitlab-ce-zh&amp;#39;&lt;/span&gt;
        &lt;span class="nt"&gt;restart&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;always&lt;/span&gt;
        &lt;span class="nt"&gt;hostname&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;192.168.123.128&amp;#39;&lt;/span&gt;
        &lt;span class="nt"&gt;environment&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nt"&gt;TZ&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Asia/Shanghai&amp;#39;&lt;/span&gt;
            &lt;span class="nt"&gt;GITLAB_OMNIBUS_CONFIG&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p p-Indicator"&gt;|&lt;/span&gt;
                &lt;span class="no"&gt;external_url = &amp;#39;http://192.168.123.128&amp;#39;&lt;/span&gt;
                &lt;span class="no"&gt;gitlab_rails[&amp;#39;gitlab_shell_ssh_port&amp;#39;] = 2222&lt;/span&gt;
                &lt;span class="no"&gt;unicorn[&amp;#39;port&amp;#39;] = 8888&lt;/span&gt;
                &lt;span class="no"&gt;nginx[&amp;#39;listen_port&amp;#39;] = 80&lt;/span&gt;
        &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;80:80&amp;#39;&lt;/span&gt;
            &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;443:443&amp;#39;&lt;/span&gt;
            &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2222:22&amp;#39;&lt;/span&gt;
        &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./config:/etc/gitlab&lt;/span&gt;
        &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./data:/var/opt/gitlab&lt;/span&gt;
        &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./logs:/var/log/gitlab&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj34/</guid><pubDate>Tue, 22 Sep 2020 00:05:00 +0806</pubDate></item><item><title>动态规划算法</title><link>/Xuxx_Blogs/archives/bj35/</link><description>&lt;h2&gt;动态规划题目特点&lt;/h2&gt;
&lt;h3&gt;1.计数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有多少种方式走到右下角&lt;/li&gt;
&lt;li&gt;有多少种方法选出k个数使得和是Sum&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.求最大最小值&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;从左上角走到右下角路径的最大数字和&lt;/li&gt;
&lt;li&gt;最长上升子序列长度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.求存在性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;取石子游戏，先手是否必胜&lt;/li&gt;
&lt;li&gt;能不能选出k个数使得和是Sum&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;例题1：&lt;/h4&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 114.90066225165563" data-width="1735" data-height="755"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/9247a23d97f2fece3a14fba5ceba4fdb.png" alt="例题" /&gt;&lt;figcaption&gt;例题&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2&gt;动态规划四大步骤&lt;/h2&gt;
&lt;h3&gt;1.确定状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;状态在动态规划中的作用属于定海神针&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;简单的说，解动态规划的时候需要开一个数组，数组的每个元素 f [i] 或者 f [i] [j] 代表什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似数学题中，X , Y , Z代表什么&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;确定状态需要两个意识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后一步&lt;/li&gt;
&lt;li&gt;子问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;例题1：最后一步的分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 115.37515375153751" data-width="1876" data-height="813"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/09d2f09a9ca3fba481809edea9ba2cfd.png" alt="例题1_最后一步的分析" /&gt;&lt;figcaption&gt;例题1_最后一步的分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 108.472553699284" data-width="1818" data-height="838"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/7a5cebdcdc21e3c784211bb6aa6ec8a1.png" alt="例题1_最后一步的分析" /&gt;&lt;figcaption&gt;例题1_最后一步的分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题：子问题的分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 93.01775147928994" data-width="1572" data-height="845"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/c89b14d980f68a3011c590960f5cd894.png" alt="例题1_子问题的分析" /&gt;&lt;figcaption&gt;例题1_子问题的分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 103.06818181818181" data-width="1814" data-height="880"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/92350c2ad5dbfc26f80018d7aee73f57.png" alt="例题1_子问题的分析" /&gt;&lt;figcaption&gt;例题1_子问题的分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;2.转移方程&lt;/h3&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 136.99248120300751" data-width="1822" data-height="665"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/fecb94428d307e8c46fcd2649f66f94d.png" alt="例题1_转移方程" /&gt;&lt;figcaption&gt;例题1_转移方程&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;3.初始条件和边界情况&lt;/h3&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 111.36680613668061" data-width="1597" data-height="717"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/cb6e8d4107e9b234e90d65b5b87e20a8.png" alt="例题1_初始条件和边界情况" /&gt;&lt;figcaption&gt;例题1_初始条件和边界情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;4.计算顺序&lt;/h3&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 159.8330241187384" data-width="1723" data-height="539"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/412f373811cb0c9adcb28d5736669e8e.png" alt="例题1_计算顺序" /&gt;&lt;figcaption&gt;例题1_计算顺序&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题1_小结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 85.68840579710145" data-width="1419" data-height="828"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e5c27ea6caf5f396d76203ebddf34546.png" alt="例题1_小结" /&gt;&lt;figcaption&gt;例题1_小结&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;例题2：Unique Paths&lt;/h4&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 101.06263982102908" data-width="1807" data-height="894"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/55b4038aea8ab79caff5ff4cc9076838.png" alt="例题2" /&gt;&lt;figcaption&gt;例题2&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;确定状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 101.34529147982063" data-width="1808" data-height="892"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/3297241f4ef73d1d69385a0d5ac1bcbd.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 123.85752688172043" data-width="1843" data-height="744"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/208b4691f33eef8274bf7d00fcd97cc1.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转移方程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 101.83129855715872" data-width="1835" data-height="901"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/8911f4e263f277a09774e4b517d9c343.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始条件和边界情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 97.75533108866442" data-width="1742" data-height="891"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/e4149e997153756e993b24992e972f5d.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class="pswp-item" style="flex: 108.70083432657925" data-width="1824" data-height="839"&gt;&lt;img src="https://cdn.jsdelivr.net/gh/qq1820582487/Xuxx_Blogs@gh-pages/archives/assets/5b42931b6b5fd32d1518816ee1d6b8af.png" alt="例题2_分析" /&gt;&lt;figcaption&gt;例题2_分析&lt;/figcaption&gt;&lt;/figure&gt;&lt;/p&gt;
</description><author>xuxx3319@gmail.com (Xuxx)</author><guid isPermaLink="true">/Xuxx_Blogs/archives/bj35/</guid><pubDate>Tue, 22 Sep 2020 03:10:00 +0806</pubDate></item></channel></rss>