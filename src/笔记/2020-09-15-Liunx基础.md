---
layout: post
title: Liunx基础
slug: bj29
date: 2020-09-15 15:30
status: publish
author: Xuxx
categories: 
  - 笔记
tags: 
  - Liunx
excerpt: 笔记
---

# Liunx目录管理

| **目录**      | **说明**                                                     |
| ------------- | ------------------------------------------------------------ |
| **/root**     | 根目录，万物起源                                             |
| /**boot**     | 包含 Linux 内核，最初的 RMA 磁盘映像（系统启动时，由驱动程序所需），和启动加载程序 **有趣的文件**： /boot/grub/grub.conf or menu.lst，被用来配置启动；加载程序 /boot/vmlinuz， Linux 内核 |
| **/bin**      | 包含系统启动和运行所必须的二进制程序                         |
| **/sbin**     | s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序 |
| **/usr**      | 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。usr (unix software resource \| unix 软件资源) |
| **/usr/bin**  | 系统用户使用的应用程序                                       |
| **/usr/sbin** | 超级用户使用的比较高级的管理程序和系统守护程序               |
| /usr/src      | 内核源代码默认的放置目录                                     |
| **/proc**     | 系统内存的映射目录，提供内核与进程信息                       |
| /lost+found   | 一般情况下是空的，当系统非法关机后，这里就存放了一些文件，文件系统恢复时的恢复文件 |
| **/var**      | 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。存放邮件、系统日志等变化文件，存放系统或程序运行过程中的数据文件(variable) |
| **/tmp**      | 这个目录是用来存放一些临时文件的                             |
| **/etc**      | 存放系统配置文件。它也包含一系列的 shell 脚本，在系统启动时，这些脚本会运行每个系统服务。这个目录中的任何文件应该是可读的文本文件。  `/etc/crontab`，定义自动运行的任务。 `/etc/fstab`，包含存储设备的列表，以及与他们相关的 挂载点。 `/etc/passwd`，包含用户帐号列表。 |
| **/home**     | 用户主目录，在通常的配置环境下，系统会在 /home 下，给每个用户分配一个目录。普通只能在他们自己的目录下创建文件。这个限制保护系统免受错误的用户活动破坏。 |
| **/dev**      | 这是一个包含设备结点的特殊目录。“一切都是文件”，也使用于设备。在这个目录里，内核维护着它支持的设备 |
| **/lib**      | 动态连接共享库，`.so` 文件，类似于 Windows 里的 dll 文件。   |
| **/mnt**      | 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 |
| **/media**    | 系统会自动识别一些设备，例如 U 盘、光驱等等，把识别的设备挂载到这个目录下。 |
| /sys          | sys 虚拟文件系统挂载点                                       |
| /srv          | 存放服务相关数据                                             |
| /opt          | 这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。 |
| /srv          | 该目录存放一些服务启动之后需要提取的数据。                   |
| /selinux      | 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux 相关的文件的。 |

## 操作文件目录

| **命令** | **说明**                             | **语法**                    | **常用选项说明**                                             |
| -------- | ------------------------------------ | --------------------------- | ------------------------------------------------------------ |
| ls       | 显示文件和目录列表                   | ls [选项] [dest]            | -a：列出目录下的所有文件，包含.开头的隐藏文件<br/>-l：列出文件的详细信息<br/>-h：以容易读取的方式显示文件大小<br/>-d：仅列出目录本身，而不显示目录中的文件<br/>-t：按照时间顺序排序，时间越早越早下面 |
| mkdir    | 创建目录                             | mkdir [-选项] dest          | -p 创建多级目录（跨级创建）<br/>-v 查看目录创建的过程（创建目录可视化） |
| rmdir    | 仅删除空白目录                       | rmdir dest                  |                                                              |
| cd       | 切换目录                             | cd dest                     |                                                              |
| touch    | 生成一个空文件                       | touch dest                  |                                                              |
| echo     | 生成一个带内容的文件                 | echo 内容 > dest            | -e：激活转义字符<br/>>：复写<br/>>>：追加                    |
| cat      | 显示文本文件内容                     | cat [-选项] dest            | -n：有1开始对所有输出的行数编号；<br/>-b：和-n相似，只不过对于空白行不编号；<br/>-s：当遇到有连续两行以上的空白行，就代换为一行的空白行； |
| cp       | 复制文件或目录                       | cp [-选项] source  dest     | -a：此参数的效果和同时指定"-dpR"参数相同； <br/>-d：当复制符号连接时，把目标文件或目录也建立为符号连接，并指向与源文件或目录连接的原始文件或目录；<br/>-f：强行复制文件或目录，不论目标文件或目录是否已存在； <br/>-i：覆盖既有文件之前先询问用户； <br/>-l：对源文件建立硬连接，而非复制文件； <br/>-p：保留源文件或目录的属性； <br/>-R/r：递归处理，将指定目录下的所有文件与子目录一并处理； <br/>-s：对源文件建立符号连接，而非复制文件； <br/>-u：使用这项参数后只会在源文件的更改时间较目标文件更新时或是名称相互对应的目标文件并不存在时，才复制文件； <br/>-S：在备份文件时，用指定的后缀“SUFFIX”代替文件的默认后缀； <br/>-b：覆盖已存在的文件目标前将目标文件备份； <br/>-v：详细显示命令执行的操作。 |
| rm       | 删除文件或目录                       | rm [选项] dest              | -f：强制删除文件或目录； <br/>-i：删除已有文件或目录之前先询问用户； <br/>-r或-R：递归处理，将指定目录下的所有文件与子目录一并处理； <br/>-v：显示指令的详细执行过程。 |
| mv       | 移动/重命名文件或目录                | mv [选项] dest              | 常用：mv 文件名或目录  目标目录<br/>mv a.txt ../    将a文件移动到上级目录（将一个文件移动到另一个目录没有重命名）<br/>mv a.txt  ../b.txt   将a文件移动到上一级并改名为b文件（将一个文件移动到另一个目录并重命名） |
| find     | 查找文件                             | find [选项] [起始目录] dest | 常用选项有：<br/>find  . -name *.log    在当前目录查找以.log结尾的文件<br/>find  / -name  log   在根目录查找log命名的目录 |
| grep     | 在指定文件中查找字符（串）并打印该行 |                             | 用法：grep  字符串 文件名<br/>grep 123 fileName  在file文件中寻找字符串123 |
| tree     | 用于以树状图列出目录内容             |                             |                                                              |
| pwd      | 显示当前工作目录                     |                             |                                                              |
| ln       | 为文件创件连接                       |                             |                                                              |
| more     | 分屏/页显示文本文件内容              |                             | 切换至下一屏：空格键 <br/>切换至上一屏：Ctrl+B<br/>查看文档的总行数，使用命令：wc -l |
| head     | 显示文件开头的内容                   |                             |                                                              |
| tail     | 显示文件结尾的内容                   |                             |                                                              |



## 压缩/解压缩

### tar

**tar命令**可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。

首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。

为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（`gzip` `bzip2`)命令）。

**语法**：tar  [选项]   打包后文档的名称   欲打包的目录

**选项**：

- -c：打包
- -x：解包
- -z：通过gzip指令处理备份文件
- -j：支持bzip2解压文件
- -v：显示操作过程
- -f：指定备份文件
- -t：列出备份文件的内容

**实例**：

将文件全部打包成tar包：

```shell
tar -cvf log.tar log2012.log    仅打包，不压缩
tar -czvf log.tar.gz log2012.log   打包后，以 gzip 压缩 
tar -cjvf log.tar.bz2 log2012.log  打包后，以 bzip2 压缩 
```

在选项`f`之后的文件档名是自己取的，习惯上都用 .tar 来作为辨识。 如果加`z`选项，则以.tar.gz或.tgz来代表gzip压缩过的tar包；如果加`j`选项，则以.tar.bz2来作为tar包名。

将tar包解压缩：

```shell
tar -xzvf ./log.tar.gz
```

### gzip

**gzip命令**用来压缩文件。gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多处“.gz”扩展名。

gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和`tar`命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。

**语法**：gzip  [选项]     [欲打包的目录]

**选项**：

- -d或--decompress或----uncompress 　解开压缩文件。
- -f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。
- -h或--help 　在线帮助。
- -l或--list 　列出压缩文件的相关信息。
- -q或--quiet 　不显示警告信息。
- -r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。
- -t或--test 　测试压缩文件是否正确无误。
- -v或--verbose 　显示指令执行过程。

**实例**：

把当前目录下的每个文件压缩成.gz文件

```shell
gzip *
```

把上例中每个压缩的文件解压，并列出详细的信息

```shell
gzip -dv *
```

详细显示例1中每个压缩的文件的信息，并不解压

```
gzip -l *
```

压缩一个tar备份文件，此时压缩文件的扩展名为 .tar.gz

```shell
gzip -r log.tar
```

递归的压缩test目录

```shell
gzip -rv test
```

*这样，所有test下面的文件都变成了 .gz，目录依然存在，只是目录里面的文件相应变成了 .gz，这就是压缩，和打包不同。因为是对目录操作，所以需要加上 -r 选项，这样也可以对子目录进行递归了。*

递归地解压目录

```shell
gzip -dr test
```

### bzip2

**bzip2命令**用于创建和管理（包括解压缩）“.bz2”格式的压缩包。





# Liunx系统管理

## 系统管理命令

| **命令** | **说明**                                       |
| -------- | ---------------------------------------------- |
|stat| 显示指定文件的相关信息,比`Is`命令显示内容更多  |
| who      | 显示在线登录用户                               |
| hostname | 显示主机名称                                   |
| uname    | 显示系统信息                                   |
| top      | 显示当前系统中耗费资源最多的进程               |
| ps       | 显示瞬间的进程状态（-A\|e：显示所有程序。）    |
| du       | 显示指定的文件(目录)当前已使用的磁盘空间的总量 |
| df       | 显示文件系统磁盘空间的使用情况                 |
| free     | 显示当前内存和交换空间的使用情况               |
| ifconfig | 显示网络接口信息                               |
| ping     | 测试网络的连通性(心跳检测)                     |
| netstat  | 显示网络状态信息(可以查看端口)                 |
| clear    | 清屏                                           |
| kill     | 杀死一个进程(-9：强制终止)                     |

## 开关机命令

**shutdown 命令**

- shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序
- shutdown 也可以用来重开机。

| 命令     | 语法                                            | 参数       | 参数说明                                                     |
| -------- | ----------------------------------------------- | ---------- | ------------------------------------------------------------ |
| shutdown | shutdown [-t seconds] [-rkhncfF] time [message] |            |                                                              |
|          |                                                 | -t seconds | 设定在几秒钟之后进行关机程序                                 |
|          |                                                 | -k         | 并不会真的关机，只是将警告讯息传送给所有只用者               |
|          |                                                 | -r         | 关机后重新开机（重启）                                       |
|          |                                                 | -h         | 关机后停机                                                   |
|          |                                                 | -n         | 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机 |
|          |                                                 | -c         | 取消目前已经进行中的关机动作                                 |
|          |                                                 | -f         | 关机时，不做 fcsk 动作(检查 Linux 档系统)                    |
|          |                                                 | -F         | 关机时，强迫进行 fsck 动作                                   |
|          |                                                 | time       | 设定关机的时间                                               |
|          |                                                 | message    | 传送给所有使用者的警告讯息                                   |

**重启**

- reboot

  sudo：提权，以其他身份来执行命令，预设的身份为 root

  reboot提示没有权限时使用：sudo reboot

- shutdown -r now

  同上，加 sudo

**关机**

- shutdown -h now



# Vim编辑器

## 概述

Vim是从vi发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。

简单的来说，vi是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。Vim则可以说是程序开发者的一项很好用的工具。

## 运行模式

- 编辑模式：等待编辑命令输入

- 插入模式：编辑模式下，输入`i`进入插入模式，插入文本信息

- 命令模式：在编辑模式下，输入`:`进行命令模式

## 命令模式

- `:q`：退出vim
- `:wq`：保存后退出
- `:q!`：强制退出
- `:wq!`：强制保存后退出
- `:w file`：将当前内容保存成某个文件
- `/`：查找字符串
- `:set number`：显示行号
- `:set nonumber`：不显示行号
- `:set paste`：开启原样粘贴



# Liunx文件和目录访问权限设置

Linux用 户分为：拥有者(owner)、组群(group)、其他(other)，Linux系统中，预设的情況下，系统中所有的帐号与一般身份使用者，以及root的相关信息， 都是记录在`/etc/passwd`文件中。每个用户的密码则是记录在`/etc/shadow`文件下。 此外，所有的组群名称记录在`/etc/group`內。

Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。

如下图：

![](..\static\笔记图片\2020-09-15-Liunx基础_01.png)

权限数字对应权限组说明：

总共分为4部分

| 文件或文件夹          | owner权限 | group权限 | others权限 |
| --------------------- | --------- | --------- | ---------- |
| 文件是 - ，文件夹是 d | r/w/x相加 | r/w/x相加 | r/w/x相加  |

r(read)  可读	--	4；w(write) 可写	--   2；x(execute) 可执行	--	1；-  表示相应的权限还没有被授予

## chown命令

chown是 change owner (改变所有者) 的意思，主要作用就是改变某个文件或目录的所有者和所属的组。

- `chown  [-R]	用户名称   文件或目录`

- `chown  [-R]    用户名称   用户组名称   文件或目录`

  -R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限

## chmod命令

chmod命令用来变更文件或目录的权限。用户可以使用 chmod 命令去变更文件与目录的权限，设置方式采用文字或数字代号皆可。符号连接的权限无法变更，如果用户对符号连接修改权限，其改变会作用在被连接的原始文件。

### 语法

```shell
chmod [选项] [操作对象] [操作符合] [mode] 文件或目录
```

### 参数说明

- 操作对象

  可以是以下字母的一个或者组合

  - u：拥有者
  - g：组
  - o：其他
  - a：所有用户(默认)

- **操作符合**

  - +：表示添加某个权限
  - -：表示取消某个权限
  - =：赋予给定的权限，覆盖文件/目录原有的权限
  
- **mode**

  - r 表示可读取
  - w 表示可写入
  - x 表示可执行
  - X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。

### 数字设定法

数字设定法中数字表示的含义：

- 0 表示没有任何权限
- 1 表示有可执行权限 = x
- 2 表示有可写权限 = w
- 4 表示有可读权限 = r

也可以用数字来表示权限如：`chmod 755 fileName`

实例：

- chmod u+x file                　　　   给file的属主增加执行权限


- chmod 751 file                　　　   给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限


- chmod u=rwx,g=rx,o=x file      	上例的另一种形式


- chmod =r file                 　　　　为所有用户分配读权限


- chmod 444 file              　　　	同上例


- chmod a-wx,a+r   file   　　 　    同上例


- chmod -R u+r directory       　    递归地给directory目录下所有文件和子目录的属主分配读的权限

# 附: centos防火墙基本使用

```
启动： systemctl start firewalld  
关闭： systemctl stop firewalld  
查看状态： systemctl status firewalld   
开机禁用： systemctl disable firewalld  
开机启用： systemctl enable firewalld
```

[学习指南](https://frank-lam.github.io/fullstack-tutorial/#/Linux)